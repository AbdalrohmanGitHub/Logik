program main;
    var mTokenList; -- list of all tokens 
    var mIndex;     -- index to the next token

    testDiff("1", "x");
    testDiff("x", "x");
    testDiff("y", "x");
    testDiff("x + x", "x");
    testDiff("1 - x", "x");
    testDiff("x * x", "x");
    testDiff("c * x + d", "x");
    testDiff("1 / x", "x");
    testDiff("x / x", "x");
    testDiff("x * x / x", "x");
    testDiff("x ** 2", "x");
    testDiff("2 ** 2", "x");
    testDiff("exp(x)", "x");
    testDiff("ln(x)", "x");
    testDiff("sin(x) * sin(x)", "x");
    testDiff("sin(x) / cos(x)", "x");
    testDiff("tan(x)", "x");
    testDiff("sqrt(x)", "x");
    testDiff("arctan(x)", "x");
    testDiff("tan(arctan(x))", "x");
    testDiff("exp(ln(x))", "x");
    testDiff("ln(exp(x))", "x");
    testDiff("e ** x", "x");
    testDiff("x ** x", "x");

    -- The procedure testDiff(E, V) gets tow strings E and V as arguments.
    -- E is an arithmetical expression and V is the name of a variable.
    -- The expression  E is differentiated with respect to V and the result 
    -- is printed.
    procedure testDiff(E, V);
        mTokenList := scanExpr(E);
        mIndex     := 1;
        Expr       := parseExpr();
        print("Trying to differentiate ", prettyPrint(Expr));
        DiffExpr   := diff(Expr, V);
        print( "diff(", E, ", ", V, ") = ", prettyPrint(DiffExpr) );
        Simple     := simplify(DiffExpr);
        print( "simplified: = ", prettyPrint(Simple) );
        print("\n");
    end testDiff;

    -- E represents an arithmetical expression and X is the name of a variable.
    -- The expression E is derivated with respect to X.  An arithmetical expression
    -- is represented using the function 
    --          rep: Expr -> SETLObj
    -- This function is defined below
    --
    -- 1. rep(v) := v  for all variables.  Variables are represented as strings.
    -- 2. rep(x) := x  für alle Zahlen x.
    --
    -- 3. rep(s + t)      := [ rep(s), "+", rep(t) ] for arithmetical expressions s and t.
    -- 4. rep(s - t)      := [ rep(s), "-", rep(t) ] for arithmetical expressions s and t.
    -- 5. rep(s * t)      := [ rep(s), "*", rep(t) ] for arithmetical expressions s and t.
    -- 6. rep(s / t)      := [ rep(s), "/", rep(t) ] for arithmetical expressions s and t.
    -- 7. rep(s ^ t)      := [ rep(s), "**", rep(t) ] for arithmetical expressions s and t.
    --
    -- 8.  rep(sqrt(t))   := [ "sqrt", rep(t) ] 
    -- 9.  rep(sin(t))    := [ "sin", rep(t) ] 
    -- 10. rep(cos(t))    := [ "cos", rep(t) ] 
    -- 11. rep(tan(t))    := [ "tan", rep(t) ] 
    -- 12. rep(arctan(t)) := [ "arctan", rep(t) ] 
    -- 13. rep(exp(t))    := [ "exp", rep(t) ] 
    -- 14. rep(ln(t))     := [ "ln", rep(t) ] 
    procedure diff(Expr, X);
        case 
            when is_integer(Expr) => return 0;
            when isVariable(Expr) => 
                 if Expr = X then
                    return 1; -- dx/dx = 1                    
                 else 
                    return 0; -- dy/dx = 0 if x /= y
                 end if;
            when #expr = 3 =>  -- binary operator
                 g  := Expr(1);
                 h  := Expr(3);
                 gs := diff(g, X);
                 hs := diff(h, X);
                 op := Expr(2);
                 case    
                      when op = "+" => 
                           -- (g + h)' = g' + h'
                           return [ gs, "+", hs ];   
                      when op = "-" => 
                           -- (g - h)' = g' - h'
                           return [ gs, "-", hs ];   
                      when op = "*" => 
                           -- (g * h)' = g' * h + g * h'
                           return [ [ gs, "*", h ], "+", [ g, "*", hs ] ];   
                      when op = "/" => 
                           -- (g / h)' = (g' * h - g * h') / h^2
                           return [      [ [ gs, "*", h ], "-", [ g, "*", hs ] ], 
                                    "/", [ h, "*", h ] 
                                  ]; 
                      when op = "**" => 
                           if is_integer(h) then
                              -- If h is an integer, then because of the chain rule we have:
                              -- (g ** h)' = h * g ** (h - 1) * g'
                              return [[ h, "*", [ g, "**", h - 1 ]], "*", gs ];
                           else
                                -- In the general case we have: g ** h = exp(h * ln(g)) 
                                return diff( [ "exp", [ h, "*", [ "ln", g ] ] ], X );
                           end if;
                      otherwise =>
                           abort("Error in diff( " + str(Expr) + ", " + str(X) + " )");
                 end case;
            when #Expr = 2 =>  -- unary function
                 op := Expr(1);
                 g  := Expr(2);
                 gs := diff(g, X);
                 case
                     when op = "exp" => 
                          -- exp(g)' = exp(g) * g'
                          return [ Expr, "*", gs ];   
                     when op = "ln" => 
                          -- ln(g)' = g' / g
                          return [ gs, "/", g ];   
                     when op = "sin" => 
                          -- sin(g)' = g' * cos(g)
                          return [ gs, "*", [ "cos", g ] ];   
                     when op = "cos" => 
                          -- cos(g)' = - g' * sin(g)
                          return [ 0, "-", [ gs, "*", [ "sin", g ] ] ];   
                     when op = "tan" => 
                          -- tan(g)' = g' / cos(g)^2
                          return [ gs, "/", [ [ "cos", g ], "*", [ "cos", g ] ] ];   
                     when op = "arctan" => 
                          -- arctan(g) = g' / (1 + g^2)
                          return [ gs, "/", [ 1, "+", [ g, "*", g ] ] ];   
                     when op = "sqrt" => 
                          -- sqrt(g)' = g' / (2 * sqrt(g))
                          return [ gs, "/", [ 2, "*", Expr ] ];   
                     otherwise =>
                          abort("Error in diff( " + str(Expr) + ", " + str(X) + " )");
                 end case;
            otherwise =>
                abort("Error in diff( " + str(Expr) + ", " + str(X) + " )");
        end case;
    end diff;

    -- The procedure simplify(Expr) tries to simplify Expr through the following rules:
    --    0 * x = x * 0 = 0,
    --    1 * x = x * 1 = 1,
    --    0 + x = x + 0 = x
    procedure simplify(Expr);
        case 
            when is_string(Expr)  => return Expr;
            when is_integer(Expr) => return Expr;
            -- Evaluate constant expresseions.
            when #Expr = 3 =>  -- binary operator
                 g := simplify(Expr(1));
                 op := Expr(2);
                 h := simplify(Expr(3));
                 case
                      -- 0 + x = x
                      when op = "+" and g = 0 => return h;  
                      -- x + 0 = x
                      when op = "+" and h = 0 => return g;
                      -- 0 * x = 0
                      when op = "*" and g = 0 => return 0;
                      -- x * 0 = 0
                      when op = "*" and h = 0 => return 0;
                      -- 1 * x = x
                      when op = "*" and g = 1 => return h;
                      -- x * 1 = x
                      when op = "*" and h = 1 => return g;
                      -- x - 0 = x
                      when op = "-" and h = 0 => return g;
                      -- x - x = 0
                      when op = "-" and g = h => return 0;
                      -- x / x = 1
                      when op = "/" and g = h => return 1;
                      -- 0 / x = 0
                      when op = "/" and g = 0 => return 0;
                      -- x ** 1 = x
                      when op = "**" and h = 1 => return g;
                      when is_integer(g) and is_integer(h) => -- evaluate constant expressions
                           case 
                                when op = "+" => return g + h;
                                when op = "-" => return g - h;
                                when op = "*" => return g * h;
                                otherwise => return Expr;
                           end case;
                      otherwise => return [ g, op, h ];
                 end case;
            when #Expr = 2 =>
                 f := Expr(1);
                 a := simplify(Expr(2));
                 case 
                      when f = "ln" and a = "e" 
                           -- ln(e) = 1
                           => return 1;
                      when f = "exp" and a = 0 
                           -- exp(0) = 1
                           => return 1;
                      otherwise => return [ f, a ];
                 end case;
            otherwise => abort("Error in simplify( " + str(Expr) + " )");
        end case;
    end simplify;

    --------------------------------------------------------------------------------
    -- The following procedures are used for printing and parsing arithmetical    --
    -- expressions.                                                               --
    --------------------------------------------------------------------------------

    -- Transform a given arithmetical expression into a string.
    procedure prettyPrint(Expr);
        case 
            when isVariable(Expr) => return Expr;
            when is_integer(Expr) => return str(Expr);
            when is_real(Expr)    => return str(Expr);
            when #Expr = 3        =>
                 g  := Expr(1);
                 op := Expr(2);
                 h  := Expr(3);
                 case
                      when op = "+"      => return prettyPrint(g) + " + " + prettyPrint(h);
                      when op = "-"      => return prettyPrint(g) + " - " + prettyPrintParen(h);
                      when op = "*"      => return prettyPrintParen(g) + " * " + prettyPrintParen(h);
                      when op = "/"      => return prettyPrintParen(g) + " / " + prettyPrintParen(h);
                      when op = "**"     => return prettyPrintParen(g) + " ** " + prettyPrintParen(h);
                      otherwise => abort("Error in prettyPrint( " + str(Expr) + " )");
                 end case;
            when #Expr = 2      =>
                 f := Expr(1);
                 a := Expr(2);
                 case
                      when f = "-" => return "- " + prettyPrintParen(a);
                      when f = "+"      => return prettyPrint(a);
                      when f = "sin"    => return "sin(" + prettyPrint(a) +")";
                      when f = "cos"    => return "cos(" + prettyPrint(a) +")";
                      when f = "tan"    => return "tan(" + prettyPrint(a) +")";
                      when f = "sqrt"   => return "sqrt(" + prettyPrint(a) +")";
                      when f = "arcsin" => return "arcsin(" + prettyPrint(a) +")";
                      when f = "arccos" => return "arccos(" + prettyPrint(a) +")";
                      when f = "arctan" => return "arctan(" + prettyPrint(a) +")";
                      when f = "exp"    => return "exp(" + prettyPrint(a) +")";
                      when f = "ln"     => return "ln(" + prettyPrint(a) +")";
                      otherwise => abort("Error in prettyPrint( " + str(Expr) + " )");
                 end case;
            otherwise => abort("Error in prettyPrint( " + str(Expr) + " )");
        end case;
    end prettyPrint;

    -- Transforms the arithmetical expression into a string and sourround it with 
    -- parenthesis if necessary.
    procedure prettyPrintParen(Expr);
        FunctionNames := { "sin", "cos", "tan", "sqrt", "arcsin", "arccos", "arctan", "exp", "ln" };
        case 
            when isVariable(Expr) => return Expr;
            when is_integer(Expr) => return str(Expr);
            when is_real(Expr)    => return str(Expr);
            when #Expr = 2 and Expr(1) in FunctionNames =>
                 return prettyPrint(Expr);
            otherwise             =>
                 return "(" + prettyPrint(Expr) + ")";
        end case;
    end prettyPrintParen;

    -- Test whether  Expr is a variable.
    procedure isVariable(Expr);
        return is_string(Expr) and not is_integer(Expr) and not is_real(Expr);
     end isVariable;

    -----------------------------------------------------------------------------
    -- The following procedures are used for parsing arithmetical expressions. --
    -----------------------------------------------------------------------------

    -- This procedure transforms a list of tokens into the internal 
    -- representation of an arithmetical expression. 
    -- mTokenList and mIndex are used as global variables.
    -- The grammar is as follows:
    --
    --                  expr        : product exprRest
    --                              ;
    --
    --                  exprRest    : "+" product exprRest
    --                              | "-" product exprRest
    --                              | /* epsilon */
    --                              ;
    --
    --                  product     : power productRest
    --                              ;
    --
    --                  productRest : "*" power productRest
    --                              | "/" power productRest
    --                              | /* epsilon */
    --                              ;    
    -- 
    --                  power       : factor "**" power
    --                              | factor
    --                              ;
    -- 
    --                  factor      : "(" expr ")"
    --                              | "exp" "(" expr ")"
    --                              | "ln"  "(" expr ")"
    --                              | "sqrt" "(" expr ")"
    --                              | "sin" "(" expr ")"
    --                              | "cos" "(" expr ")"
    --                              | "tan" "(" expr ")"
    --                              | "arctan" "(" expr ")"
    --                              | NUMBER
    --                              | IDENTIFIER
    --                              ;
    --
    procedure parseExpr();
        product := parseProduct();
        result  := parseExprRest(product);
    	if mTokenList(mIndex) =")" then 
	    return result;
        end if;
	if #mTokenList + 1 /= mIndex then
            print("mTokenList = ", mTokenList);
            print("mIndex     = ", mIndex);
            print("result     = ", result);
            abort("Parse Error");
        end if;
	return result; 
    end parseExpr;    

    -- This procedure implements the following grammar rules:
    --                  exprRest    : "+" product exprRest
    --                              | "-" product exprRest
    --                              | /* epsilon */
    --                              ;
    procedure parseExprRest(sum);
        if check("+") then
            product := parseProduct();
            return parseExprRest([ sum, "+", product ]);
        end if;
        if check("-") then
            product := parseProduct();
            return parseExprRest([ sum, "-", product ]);
        end if;
        return sum;
    end parseExprRest;

    -- This procedure implements the following grammar rule:
    --                 product : power productRest 
    --                         ;
    procedure parseProduct();
        power := parsePower();
        return parseProductRest(power);
    end parseProduct;

    -- This procedure implements the following grammar rules:
    --                  productRest : "*" power productRest
    --                              | "/" power productRest
    --                              | /* epsilon */
    --                              ;    
    procedure parseProductRest(product);
        if check("*") then
            power := parsePower();
            return parseProductRest([ product, "*", power ]);
        end if;
        if check("/") then
            power := parsePower();
            return parseProductRest([ product, "/", power ]);
        end if;
        -- epsilon
        return product;
    end parseProductRest;

    -- This procedure implements the following grammar rules:
    --                  power       : factor "**" power
    --                              | factor
    --                              ;
    procedure parsePower();
        factor := parseFactor();
        if check("**") then
            power := parsePower();
            return [ factor, "**", power ];
        end if;
        return factor;
    end parsePower;

    -- This procedure implements the following grammar rules:
    --                  factor      : "(" expr ")"
    --                              | "exp" "(" expr ")"
    --                              | "ln"  "(" expr ")"
    --                              | "sqrt" "(" expr ")"
    --                              | "sin" "(" expr ")"
    --                              | "cos" "(" expr ")"
    --                              | "tan" "(" expr ")"
    --                              | "arctan" "(" expr ")"
    --                              | NUMBER
    --                              | IDENTIFIER
    --                              ;
    procedure parseFactor();
        if check("(") then
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return expr;    
        end if;
        if check("exp") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "exp", expr ];    
        end if;
        if check("ln") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "ln", expr ];    
        end if;
        if check("sqrt") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "sqrt", expr ];    
        end if;
        if check("sin") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "sin", expr ];    
        end if;
        if check("cos") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "cos", expr ];    
        end if;
        if check("tan") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "tan", expr ];    
        end if;
        if check("arctan") then
            if not check("(") then
                abort("Parse Error, '(' expected");
            end if;
            expr := parseExpr();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return [ "arctan", expr ];    
        end if;
        if is_string(mTokenList(mIndex)) then
            result := mTokenList(mIndex);
            mIndex := mIndex + 1;
            return result;
        end if;
        if is_integer(mTokenList(mIndex)) then
            result := mTokenList(mIndex);    
            mIndex := mIndex + 1;
            return result;
        end if;
        abort("Parse Error in parseFactor,");
    end parseFactor;

    -- Check, whether the argument is the next token to be consumed.  If this is the case
    -- the token is consumed.
    procedure check(token);
        -- no tokens left
        if mIndex > #mTokenList then
            return false;
        end if;
        if mTokenList(mIndex) = token then  -- success
            mIndex := mIndex + 1;           -- consume token
            return true;
        end if;
        return false;
    end check;

    -- Read a string an split it into a list of tokens.
    procedure scanExpr(s);
        letters := {};
        -- collect all letters, digits, and the dot.
        for x in { 46 } + { 48 .. 57 } + { 65 .. 90 } + { 97 .. 122 } loop
            letters := letters + { char(x) };
        end loop;
        case 
            when #s > 1 and s(1..2) = "**" => 
                 return [ "**" ] + scanExpr( s(3..) );
            when s    = ""   => return [];
            when s(1) = "("  => return [ "("  ] + scanExpr( s(2..) );
            when s(1) = ")"  => return [ ")"  ] + scanExpr( s(2..) );
            when s(1) = "+"  => return [ "+"  ] + scanExpr( s(2..) );
            when s(1) = "-"  => return [ "-"  ] + scanExpr( s(2..) );
            when s(1) = "*"  => return [ "*"  ] + scanExpr( s(2..) );
            when s(1) = "/"  => return [ "/"  ] + scanExpr( s(2..) );
            -- skip whitespace
            when s(1) = " "  => return scanExpr( s(2..) );
            when s(1) = "\t" => return scanExpr( s(2..) );
            when s(1) = "\n" => return scanExpr( s(2..) );
            when s(1) = "\r" => return scanExpr( s(2..) );
        end case;
        index := 1;
        word  := "";
        if s(index) notin letters then
            abort("Error in scanExpr(" + s + ")");
        end if;
        while s(index) in letters and index < #s loop
            index := index + 1;
        end loop;
        if onlyDigits( s(1 .. index-1) ) then  -- its a number
            token := ascii2int( s(1 .. index-1) );
        else
            token := s(1 .. index-1);    
        end if;
        if not s(index) in letters then
            return [ token ] + scanExpr( s(index ..) );
        end if;
        if index = #s then
            if onlyDigits( s(1 .. index) ) then
                token := ascii2int( s(1 .. index) );
            else
                token := s(1 .. index);
            end if;
            return [ token ];
        end if;
        abort( "Error in scanExpr: s = " + s );
    end scanExpr;

    -- Returns true if the string s consists of digits only.
    procedure onlyDigits(s);
        return { s(i) : i in [1..#s] } <= { char(i) : i in [abs("0")..abs("9")] };
    end onlyDigits;

    -- Transform a string into an integer.
    procedure ascii2int(s);
        -- The function abs(c) yields the ASCII code of the character c.
        return +/ [ (abs(s(i)) - abs("0")) * 10 ** (#s - i) : i in [1..#s] ];
    end ascii2int;

end main;
