program main;
    var mTokenList; -- list of all tokens 
    var mIndex;     -- index to the next token

    -- The princess has to be somewhere.
    f0 := parse("p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9");
    -- There is just one princess.
    f1 := parse("p1 -> -(p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9)");
    f2 := parse("p2 -> -(p1 + p3 + p4 + p5 + p6 + p7 + p8 + p9)");
    f3 := parse("p3 -> -(p1 + p2 + p4 + p5 + p6 + p7 + p8 + p9)");
    f4 := parse("p4 -> -(p1 + p2 + p3 + p5 + p6 + p7 + p8 + p9)");
    f5 := parse("p5 -> -(p1 + p2 + p3 + p4 + p6 + p7 + p8 + p9)");
    f6 := parse("p6 -> -(p1 + p2 + p3 + p4 + p5 + p7 + p8 + p9)");
    f7 := parse("p7 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p8 + p9)");
    f8 := parse("p8 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p9)");
    f9 := parse("p9 -> -(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8)");

    -- If the princess is in a room, the inscription of that room is true.
	f20 := parse("(p1 -> r1) * (p2 -> r2) * (p3 -> p3) * (p4 -> p4) * (p5 -> p5) * (p6 -> p6) * (p7 -> p7) * (p8 -> p8) * (p9 -> p9)");
    -- If a tiger is in a room, the inscription of that room is false.
	f21 := parse("(t1 -> -r1) * (t2 -> -r2) * (t3 -> -r3) * (t4 -> -r4) * (t5 -> -r5) * (t6 -> -r6) * (t7 -> -r7) * (t8 -> -r8) * (t9 -> -r9)");


    -- Room 1: The princess is in a room with an odd number.  (ungerade)
    --         The rooms with an even (gerade) number do not have a tiger.
	f11 := parse("r1 <-> (p1 + p3 + p5 + p7 + p9) * -t2 * -t4 * -t6 * -t8");
    -- Room 2: This room is empty.
	
	f12 := parse("r3 <-> (-p2 * -t2)");
    -- Room 3: The inscription on room no.~5 are true, the inscription on room no.~7
    --           is wrong and room no.~3 has a tiger.
	f13 := parse("r3 <-> r5 * -r7 * t3");

    -- Room 4: The inscription on room no.~1 is false, room no.~8 has a tiger, and the
    --         inscription on room no.~9 is true.
	f14 := parse("r4 <-> -r1 * t8 * r9");

    -- Room 5: If the inscription on room no.~2 or room no.~4 are true,
    --         then there is no tiger in room no.~1.
	f15 := parse("r5 <-> (r2 + r4) -> -t1");

    -- Room 6: The inscription on room no.~3 is false, the princess is in room no.~2 and
    --         room no.~4 does not have a tiger.
	f16 := parse("r6 <-> -r3 * p2 * -t4");

    -- Room 7: The princess is in room no.~1 and the inscription on room no.~5 is true.
	f17 := parse("r7 <-> p1 * r5");

    -- Room 8: This room does not have a tiger and room no.~9 is empty.
	f18 := parse("r8 <-> -t8 * -p9 * -t9");

    -- Room 9: Neither this room nor room no.~1 has a tiger and the inscription on
    --         room number 6 is true.
	f19 := parse("r9 <-> -t9 * -t1 * r6");

    -- Either all inscriptions on empty rooms are true, are all inscriptions on empty 
    -- rooms are false.
--	f10:= parse("e <-> ((-p1 * -t1) -> r1) * ((-p2 * -t2) -> r2) * ((-p3 * -t3) -> r3) * ((-p4 * -t4) -> r4) * ((-p5 * -t5) -> r5) * ((-p6 * -t6) -> r6) * ((-p7 * -t7) -> r7) * ((-p8 * -t8) -> r8) * ((-p9 * -t9) -> r9) ");
    
    Clauses := +/ {  f0,   f1,  f2,  f3,  f4,  f5,  f6,  f7,  f8,  f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21
                  };

    for x in [ "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9" ] loop
        if DavisPutnam(Clauses + {{ x }}, {}) /= false then
            print("The princess is in room ", x, ".");
        end if;
    end loop;     

    for x in [ "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9" ] loop
        if DavisPutnam(Clauses + {{ x }}, {}) /= false then
            print("A tiger might be in room ", x, ".");
        end if;
    end loop;     

    loesung := DavisPutnam(Clauses, {});
    print(loesung);

    -- This procedure parses the given string s and transforms it into a formula.
    procedure parse(s);
        mTokenList := scanFormula(s);
        mIndex     := 1;
        result     := parseFormula();
        print(result);
        print(prettyPrint(result));
        return normalize(result);
    end parse;

    -- Diese Prozedur parst eine aussagenlogische Formel gemäß der folgenden
    -- Grammatik:
    --
    --        formula         : implication "<->" implication
    --                        | implication
    --                        ;
    --
    --        implication     : conjunction "->" implication
    --                        | conjunction
    --                        ;
    --
    --        conjunction     : disjunction conjunctionRest;
    --                    
    --        conjunctionRest : "*" disjunction conjunctionRest
    --                        | /* epsilon */
    --                        ;
    --
    --        disjunction     : negation disjunctionRest;
    --
    --        disjunctionRest : "+" negation disjunctionRest
    --                        | /* epsilon */
    --                        ;
    --
    --        negation        : "-" negation
    --                        | atomic
    --                        ;
    -- 
    --        atomic          : "(" formula ")"
    --                        | IDENTIFIER
    --                        ;
    procedure parseFormula();
        implicationLhs := parseImplication();
        if mIndex <= #mTokenList and mTokenList(mIndex) /= ")" then
            check("<->");
            implicationRhs := parseImplication();
            return [ implicationLhs, "<->", implicationRhs ];
        else
            return implicationLhs;    
        end if;
    end parseFormula;

    -- Diese Prozedur implementiert die folgenden Grammatik-Regeln:
    --
    --        implication     : conjunction "->" implication
    --                        | conjunction
    --                        ; 
    procedure parseImplication();
        conjunction := parseConjunction();
        if mIndex <= #mTokenList and mTokenList(mIndex) notin { "<->", ")" } then
            check("->");
            implication := parseImplication();
            return [ conjunction, "->", implication ];
        else
            return conjunction;
        end if;
    end parseImplication;

    -- Diese Prozedur implementiert die folgende Grammatik-Regel:
    --
    --        conjunction     : disjunction conjunctionRest;
    --
    procedure parseConjunction();
        disjunction := parseDisjunction();
        return parseConjunctionRest(disjunction);
    end parseConjunction;

    -- Diese Prozedur implementiert die folgenden Grammatik-Regeln:
    --                    
    --        conjunctionRest : "*" disjunction conjunctionRest
    --                        | /* epsilon */
    --                        ;
    procedure parseConjunctionRest(formula);
        if check("*") then
            disjunction := parseDisjunction();
            return parseConjunctionRest([ formula, "*", disjunction ]);
        end if;
        return formula;
    end parseConjunctionRest;

    -- Diese Prozedur implementiert die folgende Grammatik-Regel:
    --
    --        disjunction     : negation disjunctionRest;
    --
    procedure parseDisjunction();
        negation := parseNegation();
        return parseDisjunctionRest(negation);
    end parseDisjunction;

    -- Diese Prozedur implementiert die folgenden Grammatik-Regeln:
    --
    --        disjunctionRest : "+" negation disjunctionRest
    --                        | /* epsilon */
    --                        ;
    procedure parseDisjunctionRest(formula);
        if check("+") then
            negation := parseNegation();
            return parseDisjunctionRest([ formula, "+", negation]);
        end if;
        return formula;
    end parseDisjunctionRest;

    -- Diese Prozedur implementiert die folgenden Grammatik-Regeln:
    --
    --        negation        : "-" negation
    --                        | atomic
    --                        ;
    procedure parseNegation();
        if check("-") then
            negation := parseNegation();
            return [ "-", negation ];            
        end if;
        return parseAtomic();
    end parseNegation;

    -- Diese Prozedur implementiert die folgenden Grammatik-Regeln:
    --
    --        atomic          : "(" formula ")"
    --                        | IDENTIFIER
    --                        ;
    procedure parseAtomic();
        if check("(") then
            formula := parseFormula();
            if not check(")") then
                abort("Parse Error, ')' expected");
            end if;
            return formula; 
        end if;
        if is_string(mTokenList(mIndex)) then
            result := mTokenList(mIndex);
            mIndex := mIndex + 1;
            return result;
        end if;
        abort("Parse Error in parseFactor,");
    end parseAtomic;

    -- Überprüfe, ob als nächstes token in der Eingabe steht.
    procedure check(token);
        -- no tokens left
        if mIndex > #mTokenList then
            return false;
        end if;
        if mTokenList(mIndex) = token then
            mIndex := mIndex + 1;
            return true;
        end if;
        return false;
    end check;

    -- Liest einen String und scannt den String.  Es wird eine Liste von Token
    -- zurück gegeben.
    procedure scanFormula(s);
        letters := {};
        -- collect all letters and digits
        for x in { 48 .. 57 } + { 65 .. 90 } + { 97 .. 122 } loop
            letters := letters + { char(x) };
        end loop;
        case 
            when s = ""                      => return [];
            when s(1) = "("                  => return [ "(" ] + scanFormula( s(2..) );
            when s(1) = ")"                  => return [ ")" ] + scanFormula( s(2..) );
            when s(1) = "+"                  => return [ "+" ] + scanFormula( s(2..) );
            when s(1) = "*"                  => return [ "*" ] + scanFormula( s(2..) );
            when #s >= 2 and s(1..2) = "->"  => return [ "->" ] + scanFormula( s(3..) );
            when #s >= 3 and s(1..3) = "<->" => return [ "<->" ] + scanFormula( s(4..) );
            when s(1) = "-"                  => return [ "-" ] + scanFormula( s(2..) );
            when s(1) = " " or s(1) = "    " => return scanFormula( s(2..) );
        end case;
        index := 1;
        word  := "";
        if s(index) notin letters then
            abort("Error in scanFormula(" + s + ")");
        end if;
        while s(index) in letters and index < #s loop
            index := index + 1;
        end loop;
        if not s(index) in letters then
            return [ s(1 .. index - 1) ] + scanFormula( s(index ..) );
        end if;
        if index = #s then
            return [ s ];
        end if;
        print( "Error in scanFormula: s = ", s );
    end scanFormula;

    -- Druckt die Formel f am Bildschirm aus.
    procedure prettyPrint(f);
        case
            when f = 1        => return "1";
            when f = 0        => return "0";
            when is_string(f) => return f;
            when f(1) = "-"   => return "-" + prettyPrint(f(2));
            when f(2) = "*"   => return "(" + prettyPrint(f(1)) + " * "   + prettyPrint(f(3)) + ")";
            when f(2) = "+"   => return "(" + prettyPrint(f(1)) + " + "   + prettyPrint(f(3)) + ")";
            when f(2) = "->"  => return "(" + prettyPrint(f(1)) + " -> "  + prettyPrint(f(3)) + ")";
            when f(2) = "<->" => return "(" + prettyPrint(f(1)) + " <-> " + prettyPrint(f(3)) + ")";
            otherwise => abort("Error in prettyPrint: " + str(f));
        end case;
    end prettyPrint;

    -- Clauses ist eine Menge von Klauseln und Literals ist eine Menge
    -- von Literalen.  Der Aufruf DavisPutnam(Clauses, Literals) versucht 
    -- eine Lösung der Menge
    --                        Clauses
    -- zu berechnen.  Wenn dies gelingt, wird eine Menge von Unit-Klauseln 
    -- zurück gegeben, die keine komplementären Literale enthält.  Aus dieser 
    -- Menge kann dann unmittelbar eine Belegung berechnet werden, die Clauses
    -- löst.
    --       Wenn die Menge Clauses unlösbar ist, wird false zurück gegeben.
    -- Das Argument Literals dient der Buchhaltung bei den rekursiven Aufrufen.
    -- Hier werden alle die Literale aufgesammelt, mit denen die Menge Clauses
    -- schon reduziert wurde.  Beim ersten Aufruf ist diese Menge leer.
    procedure DavisPutnam( Clauses, Literals );
        -- 1. Schritt: Bilde solange wie möglich Unit-Schnitte mit den Klauseln
        --             aus Clauses und entferne subsumierte Klauseln.
        Clauses := saturate(Clauses);
        -- 2. Schritt: Falls {} in Clauses, ist Clauses unerfüllbar,
        --             also gilt Clauses |= false und wir geben true zurück.
        if {} in Clauses then
            return false;
        end if;
        -- 3. Schritt: Falls für alle Klauseln k aus Clauses gilt card(k) = 1,
        --             so ist die Menge Clauses erfüllbar, wir geben dann
        --             die Menge Clauses zurück.
        if { k in Clauses | #k = 1 } = Clauses then
            return Clauses;
        end if;
        -- 4. Schritt: Wähle Literal l aus Clauses, dass noch nicht benutzt
        --             worden ist.
        literal := selectLiteral(Clauses, Literals);
        --   Fall (a): Prüfe rekursiv, ob Clauses + { {l} } |= false.
        --             Falls es eine Belegung I gibt, die die Menge Clauses + {l} erfüllt,
        --             gebe I zurück.
        --             Sonst weiter bei (b).
        Result := DavisPutnam(Clauses + {{literal}}, Literals + { literal });
        if Result /= false then
            return Result;
        end if;        
        --   Fall (b): Prüfe rekursiv, ob Clauses + { {-l} } |= false.
        --             Falls es eine Belegung I gibt, die die Menge Clauses + {-l} erfüllt,
        --             gebe I zurück.
        --             Sonst haben wir Clauses + {{l}} |= false. und Clauses + {{-l}} |= false
        --             und daraus folgt Clauses |= false, wir geben also true zurück.
        notLiteral := negateLiteral(literal);
        return DavisPutnam(Clauses + {{notLiteral}}, Literals + { notliteral } );
    end DavisPutnam;

    -- Gegeben ist eine Menge S von Klauseln.  Der Aufruf saturate(S) berechnet alle
    -- Klauseln, die mit Unit Schnitten aus S ableitbar sind.  Zusätzlich werden alle
    -- Klauseln, die von Unit-Klauseln subsumiert werden, aus der Menge S entfernt.
    procedure saturate(S);
        -- Wir berechnen zunächst alle Unit-Klauseln.
        Units := { k in S | #k = 1 };
        -- Wir müssen uns merken, welche Unit-Klauseln wir schon benutzt haben.
        Used := {};
        -- Solange wir unbenutzte Unit-Klauseln haben, wählen wir eine 
        -- Unit-Klausel aus, merken uns, dass wir diese Klausel benutzt haben 
        -- und bilden alle möglichen Schnitte mit anderen Klauseln.  
        while Units /= {} loop
            unit := arb Units;
            Used := Used + { unit };
            literal := arb unit;
            S := reduce(S, literal);
            -- Da bei der Reduktion neue Unit-Klauseln entstehen können, 
            -- müssen wir die Menge der Unit-Klauseln bei jedem Durchlauf
            -- der Schleife neu berechnen.  
            Units := { k in S | #k = 1 } - Used;        
        end loop;
        -- Wenn keine neuen Unit-Klauseln gefunden werden, geben wir S zurück.
        return S;
    end saturate;

    -- Die Prozedur reduce(S,l) führt alle Unit-Schnitte und alle Unit-Subsumptionen,
    -- die mit der Unit-Klausel {l} möglich sind, durch.
    procedure reduce( S, l );
        notL := negateLiteral(l);
        return   { k - { notL } : k in S | notL in k } 
               + { k in S | not notL in k and not l in k } 
               + { {l} };
    end reduce;

    -- Wir wählen ein beliebiges Literal aus einer beliebigen Klausel,
    -- so dass weder dieses Literal noch die Negation benutzt wurden.
    procedure selectLiteral( S, Forbidden );
        return arb { l : k in S, l in k | not l in Forbidden };
    end selectLiteral;

    -- Diese Prozedur berechnet das Komplement des Literals l.
    procedure negateLiteral(l);
        if l(1) = "-" then
            return l(2);
        else
            return [ "-", l ];
        end if;
    end negateLiteral;

    -- Diese Prozedur überführt die Formel f in konjunktive Normalform.
    procedure normalize(f);
        n1 := elimGdw(f);
        n2 := elimFolgt(n1);
        n3 := nnf(n2);
        n4 := knf(n3);
        return n4;
    end normalize;

    -- Eliminiert den Operator "gdw" aus der eingegebenen Formel f.
    procedure elimGdw(f);
        case
            when f = 1        => return 1;
            when f = 0        => return 0;
            when is_string(f) => return f;
            when f(1) = "-"   => return [ "-", elimGdw( f(2) ) ];
            when f(2) = "*"   => return [ elimGdw( f(1) ), "*", elimGdw( f(3) ) ];
            when f(2) = "+"   => return [ elimGdw( f(1) ), "+", elimGdw( f(3) ) ];
            when f(2) = "->"  => return [ elimGdw( f(1) ), "->", elimGdw( f(3) ) ];
            when f(2) = "<->" => return
	         elimGdw( [ [ f(1), "->", f(3) ], "*", [ f(3), "->", f(1) ] ] );
            otherwise         =>  print("Fehler in elimGdw( ", f, ")" );
        end case;
    end elimGdw;

    -- Eliminiert den Operator "->" aus der eingegebenen Formel f.
    -- Es wird vorausgesetzt, dass der Operator "<->" bereits vorher 
    -- eliminiert wurde.
    procedure elimFolgt(f);
        case
            when f = 1        =>  return 1;
            when f = 0        =>  return 0;
            when is_string(f) =>  return f;
            when f(1) = "-"   =>  return [ "-", elimFolgt(f(2)) ];
            when f(2) = "*"   =>  return [ elimFolgt(f(1)), "*", elimFolgt(f(3)) ];
            when f(2) = "+"   =>  return [ elimFolgt(f(1)), "+", elimFolgt(f(3)) ];
            when f(2) = "->"  =>  return elimFolgt( [ [ "-", f(1) ], "+", f(3) ] );
            otherwise         =>  print("Fehler in elimFolgt( ", f, ")" );
        end case;
    end elimFolgt;

    -- Berechnet die Negations-Normalform der Formel f.
    procedure nnf(f);
        case
            when f = 1        =>  return 1;
            when f = 0        =>  return 0;
            when is_string(f) =>  return f;
            when f(1) = "-"   =>  return neg( f(2) );
            when f(2) = "*"   =>  return [ nnf( f(1) ), "*", nnf( f(3) ) ];
            when f(2) = "+"   =>  return [ nnf( f(1) ), "+", nnf( f(3) ) ];
            otherwise         => print("Fehler in nnf( ", f, ")" );
        end case;
    end nnf;

    -- Diese Funktion berechnet die Negations-Normalform von (-f) und schiebt dabei
    -- das Negationszeichen soweit wie möglich nach innen.
    procedure neg(f);
        case
            when f = 1        => return 0;
            when f = 0        => return 1;
            when is_string(f) => return [ "-", f ];
            when f(1) = "-"   => return nnf( f(2) );
            when f(2) = "*"   => return [ neg( f(1) ), "+", neg( f(3) ) ];
            when f(2) = "+"   => return [ neg( f(1) ), "*", neg( f(3) ) ];
            otherwise  => print("Fehler in neg( ", f, ")" );
        end case;
    end neg;

    -- Diese Funktion berechnet die KNF von f durch Ausmultiplizieren.
    -- Die KNF wird als Menge von Mengen dargestellt.  Es wird vorausgesetzt,
    -- dass die Funktion f bereits in Negations-Normalform ist.
    procedure knf(f);
        case
            when f = 1        =>  return { };
            when f = 0        =>  return { {} };
            when is_string(f) =>  return { { f } };
            when f(1) = "-"   =>  return { { f } };
            when f(2) = "*"   =>  return knf( f(1) ) + knf( f(3) );
            when f(2) = "+"   =>  return { k1 + k2 : k1 in knf(f(1)), k2 in knf(f(3)) };
            otherwise  => print("Fehler in knf( ", f, ")" );
        end case;
    end knf;

end main;
