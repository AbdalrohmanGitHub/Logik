program main;
    -- Three missionaies and three infidels have to cross a river. Their boat 
    -- only provides room for two passengers. The infidels are also cannibals
    -- and are quite hungry.  If their are fewer missionaies than infidels on a
    -- shore, the missionaries have a problem.  Your task is to create a shedule
    -- that can be used to cross the river.  The constraint is that the 
    -- missionaries must not be consumed by the infidels.
    
    -- Every situatition is represented as a triple. The triple [ M, K, B ] 
    -- represents the fact that there are M missionaries, K infidels and B boats
    -- on the left shore.  The number of missionaries on the right shore is then
    -- obviously 3 - M, the number of infidels on the right shore is 3 - K
    -- and the number of boats on the right shore is 1 - B.

    -- P is the set of all those situations where the missionaries don't have  
    -- a problem.
    P := { [M, K, B] : M in {0 .. 3}, K in {0 .. 3}, B in {0 .. 1} 
                     | not problem(M, K) };

    -- R1 codes those transitions where a boat goes from the left shore to the right shore.
    -- MB is the number of missionaries in the boat, while KB is the number of infidels
    -- in the boat.
    R1 := {   [[M, K, 1], [M - MB, K - KB, 0]] 
            : [M, K, B] in P, MB in { 0 .. M }, KB in { 0 .. K }
            | not problem(M - MB, K - KB) and MB + KB in {1,2}  
          };

    -- R2 codes those transitions where the boat goes from the right shore to the left shore.
    R2 := {   [[M, K, 0], [M + MB, K + KB, 1]] 
            : [M, K, B] in P, MB in { 0 .. 3 - M}, KB in { 0 .. 3 - K }
            | not problem(M + MB, K + KB) and MB + KB in {1,2} 
          };

    -- R is the set of all transitions.
    R := R1 + R2;

    -- At the beginning, the missionaries and the infidels are on the left side.
    start := [3, 3, 1];
    -- After all crossings, everybody is on the right shore.
    goal  := [0, 0, 0];
    -- Compute all possible paths.
    path  := reachable(start, goal, R);
    printPath(path);

    -- Aufgabe 1:
    -- There is a problem on a shore if there are less missionaries than infidels,
    -- but there is no problem if there are no missionaries at all.
    procedure problem(M, K);
    --    return (M > 0 and M < K) or (3 - M > 0 and 3 - M < 3 - K);
        return not (M = 0 or M = 3 or M = K);
    end problem;

    --------------------------------------------------------------------------
    --                                                                      --
    -- The following procedures are needed to print the solution.           --
    --                                                                      --
    --------------------------------------------------------------------------    

    -- This procedure prints the solution.
    procedure printPath(path);
        print("Solution:\n");
        for i in {1 .. #path - 1} loop
            [ M1, K1, B1 ] := path(i);
            [ M2, K2, B2 ] := path(i+1);
            printState(M1, K1, B1);
            printBoat(M1, K1, B1, M2, K2, B2);
        end loop;
        [ M, K, B ] := path(#path);
        printState(M, K, B);
    end printPath;

    -- This procedure prints a given state.
    procedure printState(M, K, B);
         print( fillCharsRight(M * "M", 6) + 
                fillCharsRight(K * "I", 6) + 
                fillCharsRight(B * "B", 3) + "    |~~~~~|    " + 
                fillCharsLeft((3 - M) * "M", 6) + 
                fillCharsLeft((3 - K) * "I", 6) + 
                fillCharsLeft((1 - B) * "B", 3) 
              );
    end printState;
    
    -- This procedure prints the boat when the state changes from
    -- [M1, K1, B1] to [M2, K2, B2].
    procedure printBoat(M1, K1, B1, M2, K2, B2);
        if B1 = 1 then
            if M1 < M2 then
                print("Error in printBoat: negative number of missionaries in boat!");
            end if;
            if K1 < K2 then
                print("Error: in printBoat: negative number of infidels in boat!");
            end if;
            print( 19 * " " + "> " + fillCharsBoth( (M1 - M2) * "M" + " " + (K1 - K2) * "I", 3 ) + " >" );
        else
            if M1 > M2 then
                print("Error in printBoat: negative number of missionaries in boat!");
            end if;
            if K1 > K2 then
                print("Error in printBoat: negative number of infidels in boat!");
            end if;
            print( 19 * " " + "< " + fillCharsBoth( (M2 - M1) * "M" + " " + (K2 - K1) * "I", 3 ) + " <" );
        end if;
    end printBoat;

    -- The procedure fillCharsLeft(x, n) transforms x into a string of length n.
    -- The string is padded with blanks on the left side.
    procedure fillCharsLeft(x, n);
        s := str(x);
        m := n - #s;
        return m * " " + s;
    end fillCharsLeft;

    -- The procedure fillCharsRight(x, n) transforms x into a string of length n.
    -- The string is padded with blanks on the right side.
    procedure fillCharsRight(x, n);
        s := str(x);
        m := n - #s;
        return s + m * " ";
    end fillCharsRight;

    -- The procedure fillCharsBoth(x, n) transforms x into a string of length n.
    -- The string is padded with left on its left and right side.
    procedure fillCharsBoth(x, n);
        s := str(x);
        ml := (n     - #s) / 2;
        mr := (n + 1 - #s) / 2;
        return ml * " " + s + mr * " ";
    end fillCharsBoth;


    --------------------------------------------------------------------------
    --                                                                      --
    -- Die unten aufgeführten Prozeduren sind 1-zu-1 aus dem Programm zur   --
    -- Lösung des Wolf-Ziege-Kohl-Problems kopiert.                         --
    --                                                                      --
    --------------------------------------------------------------------------

    -- Check wether there is a path from x to y in R and compute it.
    procedure reachable(x, y, R);
        P := { [x] };
        loop
            Old_P := P;
            P     := P + path_product(P, R);
            Found := { p in P | p(#p) = y };
            if Found /= {} then
                return arb Found;
            end if;
            if P = Old_P then
                return;
            end if;
        end loop;
    end reachable;

    -- The procedure call product(P, Q) computes the path product P * Q.
    procedure path_product(P, Q);
        return { add(p,q) : p in P, q in Q | p(#p) = q(1) and not_cyclic(add(p,q)) };
    end path_product;    

    -- The procedure not_cyclic(p) checks whether the path p is cyclic.
    procedure not_cyclic(p);
        return #{ x : x in p } = #p;
    end not_cyclic;

    -- The product call add(p,q) computes the sum of the lists p and q.
    -- The last point of p has to be the first point of q.
    procedure add(p, q);
        return p + q(2..);
    end add;    

end main;

