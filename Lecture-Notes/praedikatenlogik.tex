\chapter{Pr\"{a}dikatenlogik}
In der Aussagenlogik haben wir die Verkn\"{u}pfung von elementaren Aussagen mit Junktoren untersucht.
Die Pr\"{a}dikatenlogik untersucht zus\"{a}tzlich auch die Struktur der Aussagen.  Dazu werden in der Pr\"{a}dikatenlogik 
die folgenden zus\"{a}tzlichen Begriffe eingef\"{u}hrt:
\begin{enumerate}
\item Als Bezeichnungen f\"{u}r Objekte werden {\emph{\color{blue}Terme}} verwendet.
\item Diese Terme werden aus {\emph{\color{blue}Variablen}} und {\emph{\color{blue}Funktions-Zeichen}}
      zusammengesetzt: 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{vater}(x),\quad \textsl{mutter}(\textsl{isaac}), \quad x+7, \quad \cdots$.
\item Verschiedene Objekte werden durch {\emph{\color{blue}Pr\"{a}dikats-Zeichen}} in Relation gesetzt:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{istBruder}\bigl(\textsl{albert}, \textsl{vater}(\textsl{bruno})\bigr),\quad x+7 < x\cdot 7,\quad n \in \mathbb{N}, \quad \cdots$.
      \\[0.2cm]
      Die dabei entstehenden Formeln werden als {\emph{\color{blue}atomare}} Formeln bezeichnet.
\item Atomare Formeln lassen sich durch aussagenlogische Junktoren verkn\"{u}pfen:
      \\[0.2cm]
      \hspace*{1.3cm}
      $x > 1 \rightarrow x + 7 < x \cdot  7$.
\item Schlie\ss{}lich werden {\emph{\color{blue}Quantoren}} eingef\"{u}hrt, um zwischen {\emph{\color{blue}existentiell}} und
      {\emph{\color{blue}universell}} quantifizierten Variablen unterscheiden
      zu k\"{o}nnen:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\forall x \in \mathbb{R}: \exists n \in \mathbb{N}: x < n$.
\end{enumerate}
Wir werden im n\"{a}chsten Abschnitt die Syntax der pr\"{a}dikatenlogischen Formeln festlegen und uns dann
im darauf folgenden Abschnitt mit der Semantik dieser Formeln besch\"{a}ftigen.

\section{Syntax der Pr\"{a}dikatenlogik}
Zun\"{a}chst definieren wir den Begriff der \emph{Signatur}.  Inhaltlich ist das nichts anderes als eine 
strukturierte Zusammenfassung von Variablen, Funktions- und Pr\"{a}dikats-Zeichen zusammen mit
einer Spezifikation der Stelligkeit dieser Zeichen.
 
\begin{Definition}[Signatur]
  Eine {\emph{\color{blue}Signatur}} ist ein 4-Tupel \\[0.2cm]
  \hspace*{1.3cm} $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$, \\[0.2cm]
  f\"{u}r das Folgendes gilt: 
  \begin{enumerate}
  \item $\mathcal{V}$ ist die Menge der Variablen.
  \item $\mathcal{F}$ ist die Menge der Funktions-Zeichen.
  \item $\mathcal{P}$ ist die Menge der Pr\"{a}dikats-Zeichen.
  \item $\textsl{arity}$ ist eine Funktion, die jedem Funktions- und jedem Pr\"{a}dikats-Zeichen seine
        {\emph{\color{blue}Stelligkeit}} zuordnet: \\[0.2cm]
        \hspace*{1.3cm} $\textsl{arity}: \mathcal{F} \cup \mathcal{P} \rightarrow \mathbb{N}_0$. \\[0.2cm]
        Wir sagen, dass das Funktions- oder Pr\"{a}dikats-Zeichen $f$ ein
        $n$-stelliges Zeichen ist, falls $\textsl{arity}(f) = n$ gilt.
  \item Da wir in der Lage sein m\"{u}ssen, Variablen, Funktions- und Pr\"{a}dikats-Zeichen
        unterscheiden zu k\"{o}nnen, vereinbaren wir, dass die Mengen $\mathcal{V}$,
        $\mathcal{F}$ und $\mathcal{P}$ paarweise disjunkt sein m\"{u}ssen: \\[0.2cm] 
        \hspace*{1.3cm} $\mathcal{V} \cap \mathcal{F} = \{\}$, \quad
                        $\mathcal{V} \cap \mathcal{P} = \{\}$, \quad und \quad
                        $\mathcal{F} \cap \mathcal{P} = \{\}$. \eox
  \end{enumerate}
\end{Definition}

\noindent
Als Bezeichner f\"{u}r Objekte verwenden wir Ausdr\"{u}cke, die aus Variablen und
Funktions-Zeichen aufgebaut sind.  Solche Ausdr\"{u}cke nennen wir {\emph{\color{blue}Terme}}.  
Formal werden diese wie folgt definiert.
\begin{Definition}[Terme,  $\mathcal{T}_\Sigma$]
  Ist $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$ eine Signatur, so definieren wir die Menge der $\Sigma$-Terme
  $\mathcal{T}_\Sigma$ induktiv:
  \begin{enumerate}
  \item F\"{u}r jede Variable $x \in \mathcal{V}$ gilt $x \in \mathcal{T}_\Sigma$.
  \item Ist $f \in \mathcal{F}$ ein n-stelliges Funktions-Zeichen und sind 
        $t_1,\cdots,t_n \el \mathcal{T}_\Sigma$, so gilt auch \\[0.2cm]
        \hspace*{1.3cm} $f(t_1,\cdots,t_n) \el \mathcal{T}_\Sigma$. \\[0.2cm]
        Falls $c \in \mathcal{F}$ ein 0-stelliges Funktions-Zeichen ist, lassen wir auch die Schreibweise
        $c$ anstelle von $c()$ zu.  In diesem Fall nennen wir $c$ eine {\emph{\color{blue}Konstante}}.
        \eox
  \end{enumerate}
\end{Definition}

\example
Es sei 
\begin{enumerate}
\item $\mathcal{V} := \{ x, y, z \}$ die Menge der Variablen,
\item $\mathcal{F} := \{ 0, 1, \mathtt{+}, \mathtt{-}, * \}$ die Menge der Funktions-Zeichen,
\item $\mathcal{P} := \{\mathtt{=}, \leq\}$ die Menge der Pr\"{a}dikats-Zeichen,
\item $\textsl{arity} := \bigl\{ \pair(0,0), \pair(1,0), \pair(\mathtt{+},2), \pair(\mathtt{-},2),
  \pair(*,2), \pair(=,2), \pair(\leq,2) \bigr\}$, \\[0.2cm]
      gibt die Stelligkeit der Funktions- und Pr\"{a}dikats-Zeichen an und
\item $\Sigma_\mathrm{arith} := \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$
      sei eine Signatur.
\end{enumerate}
Dann k\"{o}nnen wir wie folgt $\Sigma_{\mathrm{arith}}$-Terme konstruieren:
\begin{enumerate}
\item $x, y, z \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$, \\[0.2cm]
      denn alle Variablen sind auch $\Sigma_{\mathrm{arith}}$-Terme.
\item $0, 1 \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$,  \\[0.2cm]
      denn $0$ und $1$ sind $0$-stellige Funktions-Zeichen.
\item $\mathtt{+}(0,x) \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$, \\[0.2cm]
      denn es gilt $0 \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$, $x \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$ und 
      $\mathtt{+}$ ist ein 2-stelliges Funktions-Zeichen.
\item $*(\mathtt{+}(0,x),1) \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$, \\[0.2cm]
      denn $\mathtt{+}(0,x) \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$, $1 \in \mathcal{T}_{\Sigma_{\mathrm{arith}}}$ und
      $*$ ist ein 2-stelliges Funktions-Zeichen.
\end{enumerate}
In der Praxis werden wir f\"{u}r bestimmte zweistellige Funktionen eine Infix-Schreibweise
verwenden.  Diese ist dann als Abk\"{u}rzung f\"{u}r die oben definierte Darstellung zu verstehen.
\eox


Als n\"{a}chstes definieren wir den Begriff der {\emph{\color{blue}atomaren Formeln}}.  Darunter verstehen wir
solche Formeln, die man nicht in kleinere Formeln zerlegen kann, atomare Formeln enthalten also
weder Junktoren noch Quantoren. 
\begin{Definition}[Atomare Formeln,  $\mathcal{A}_\Sigma$]
  Gegeben sei eine Signatur $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$. 
  Die Menge der atomaren $\Sigma$-Formeln $\mathcal{A}_\Sigma$
  wird wie folgt definiert:  Ist $p \el \mathcal{P}$ ein $n$-stelliges Pr\"{a}dikats-Zeichen
  und sind $n$ $\Sigma$-Terme $t_1$, $\cdots$, $t_n$ gegeben, so ist
  $p(t_1,\cdots,t_n)$ eine {\emph{\color{blue}atomaren $\Sigma$-Formel}}: \\[0.2cm]
  \hspace*{1.3cm} $p(t_1,\cdots,t_n) \in \mathcal{A}_\Sigma$.  \\[0.2cm]
  Falls $p$ ein 0-stelliges Pr\"{a}dikats-Zeichen ist, dann schreiben wir auch $p$ anstelle von $p()$.
  In diesem Fall nennen wir $p$ eine {\emph{\color{blue}Aussage-Variable}}.
  \eox
\end{Definition}

\example
Setzen wir das letzte Beispiel fort, so k\"{o}nnen wir sehen, dass \\[0.2cm]
\hspace*{1.3cm} $\mathtt{=}(*(\mathtt{+}(0,x),1),0)$ \\[0.2cm]
eine atomare $\Sigma_\mathrm{arith}$-Formel ist.  Beachten Sie, dass wir bisher noch nichts \"{u}ber den Wahrheitswert von solchen 
Formeln ausgesagt haben.  Die Frage, wann eine Formel als wahr oder falsch gelten soll,
wird erst im n\"{a}chsten Abschnitt untersucht.
\eox

\noindent
Bei der Definition der pr\"{a}dikatenlogischen Formeln ist es notwendig,
zwischen sogenannten {\emph{\color{blue}gebundenen}} und {\emph{\color{blue}freien}} Variablen zu unterscheiden.
Wir f\"{u}hren diese Begriffe zun\"{a}chst informal mit Hilfe eines Beispiels aus der Analysis ein.
Wir betrachten die folgende Identit\"{a}t: \\[0.2cm]
\hspace*{1.3cm}
 $\ds\int_{0}^{x} y \cdot  t\, d t = \frac{1}{2} \cdot x^2 \cdot  y$ 
\\[0.2cm]
In dieser Gleichung treten die Variablen $x$ und $y$ {\emph{\color{blue}frei}} auf, w\"{a}hrend die Variable $t$ durch das Integral
{\emph{\color{blue}gebunden}} wird.  Damit meinen wir folgendes: Wir k\"{o}nnen in dieser Gleichung f\"{u}r $x$ und $y$ beliebige Werte
 einsetzen, ohne dass sich an der 
G\"{u}ltigkeit der Formel etwas \"{a}ndert.  Setzen wir zum Beispiel f\"{u}r $x$ den Wert $2$ ein, so erhalten wir \\[0.2cm]
\hspace*{1.3cm}
$\ds\int_{0}^{2} y \cdot  t\, d t = \frac{1}{2} \cdot 2^2 \cdot  y$ \\[0.2cm]
und diese Identit\"{a}t ist ebenfalls g\"{u}ltig.  Demgegen\"{u}ber macht es keinen Sinn, wenn wir f\"{u}r die gebundene Variable
 $t$ eine Zahl einsetzen w\"{u}rden.
Die linke Seite der entstehenden Gleichung w\"{a}re einfach undefiniert.  Wir k\"{o}nnen f\"{u}r $t$
h\"{o}chstens eine andere Variable einsetzen. 
Ersetzen wir die Variable $t$ beispielsweise durch $u$, so erhalten wir \\[0.2cm]
\hspace*{1.3cm}
$\ds\int_{0}^{x} y \cdot  u\, d u = \frac{1}{2} \cdot x^2 \cdot  y$ 
\\[0.2cm]
und das ist dieselbe Aussage wie oben.  Das funktioniert allerdings nicht mit jeder Variablen. Setzen wir
f\"{u}r $t$ die Variable $y$ ein, so erhalten wir \\[0.2cm]
\hspace*{1.3cm}
$\ds\int_{0}^{x} y \cdot  y\, d y = \frac{1}{2} \cdot x^2 \cdot  y$. \\[0.2cm]
Diese Aussage ist aber falsch!  Das Problem liegt darin, dass bei der Ersetzung von $t$ durch $y$ die vorher freie Variable
$y$ gebunden wurde.  

Ein \"{a}hnliches Problem erhalten wir, wenn wir f\"{u}r $y$ beliebige Terme einsetzen.  Solange diese Terme die Variable $t$ 
nicht enthalten, geht alles gut.  Setzen wir beispielsweise f\"{u}r $y$  den Term $x^2$ ein, so erhalten
wir \\[0.2cm]
\hspace*{1.3cm}
$\ds\int_{0}^{x} x^2 \cdot  t\, d t = \frac{1}{2} \cdot x^2 \cdot  x^2$ 
\\[0.2cm]
und diese Formel ist g\"{u}ltig.  Setzen wir allerdings f\"{u}r $y$ den Term $t^2$ ein, so erhalten wir \\[0.2cm]
\hspace*{1.3cm}
$\ds\int_{0}^{x} t^2 \cdot  t\, d t = \frac{1}{2} \cdot x^2 \cdot  t^2$ 
\\[0.2cm]
und diese Formel ist nicht mehr g\"{u}ltig. 

In der Pr\"{a}dikatenlogik binden die Quantoren ``$\forall$'' ({\emph{\color{blue}f\"{u}r alle}}) und ``$\exists$''
({\emph{\color{blue}es gibt}}) Variablen in \"{a}hnlicher Weise,  wie der Integral-Operator ``$\int \cdot\; \mathtt{d}t$'' in
der Analysis Variablen bindet.  Die oben gemachten Ausf\"{u}hrungen zeigen, dass es zwei verschiedene Arten von 
Variable gibt: {\emph{\color{blue}freie Variablen}} und {\emph{\color{blue}gebundene Variablen}}.
Um diese Begriffe pr\"{a}zisieren zu k\"{o}nnen, definieren wir zun\"{a}chst f\"{u}r einen
$\Sigma$-Term $t$ die Menge der in $t$ enthaltenen Variablen.

\begin{Definition}[$\var(t)$]
    Ist $t$ ein $\Sigma$-Term, mit $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$,
    so definieren wir die Menge $\var(t)$ der Variablen, die in $t$
    auftreten, durch Induktion nach dem Aufbau des Terms:
    \begin{enumerate}
    \item $\var(x) := \{ x \}$ \quad f\"{u}r alle $x \in \mathcal{V}$,
    \item $\var\bigl(f(t_1,\cdots,t_n)\bigr) := \var(t_1) \cup \cdots \cup \var(t_n)$.
          \eox
    \end{enumerate}
\end{Definition}


\begin{Definition}[$\Sigma$-Formel,  $\mathbb{F}_\Sigma$, gebundene und freie Variablen, $\textsl{BV}(F)$,  $\textsl{FV}(F)$] 
\label{praedikaten-formel} \hspace*{\fill} \\
    Es sei $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$ eine Signatur.
    Die Menge der \colorbox{yellow}{$\Sigma$-\emph{Formeln}} bezeichnen wir mit $\mathbb{F}_\Sigma$.
    Wir definieren diese Menge induktiv.
    Gleichzeitig definieren wir f\"{u}r jede Formel $F\el \mathbb{F}_\Sigma$ die Menge $\textsl{BV}(F)$ der in $F$ 
    {\emph{\color{blue}gebunden}} auftretenden Variablen und die Menge $\textsl{FV}(F)$ der in $F$ {\emph{\color{blue}frei}} auftretenden Variablen.
    \begin{enumerate}
    \item Es gilt $\falsum \in \mathbb{F}_\Sigma$ und $\verum \in \mathbb{F}_\Sigma$ und wir definieren \\[0.2cm]
          \hspace*{1.3cm} $\FV(\falsum) := \FV(\verum) := \BV(\falsum) := \BV(\verum) := \{\}$.
    \item Ist $F = p(t_1,\cdots,t_n)$ eine atomare $\Sigma$-Formel, so gilt $F \in \mathbb{F}_\Sigma$.  Weiter definieren wir:
          \begin{enumerate}
          \item $\FV\bigl(p(t_1,\cdots,t_n) \bigr) := \var(t_1) \cup \cdots \cup \var(t_n)$.
          \item $\BV\bigl(p(t_1,\cdots,t_n) \bigr) := \{\}$.
          \end{enumerate}
    \item Ist $F \in \mathbb{F}_\Sigma$, so gilt $\neg F \in \mathbb{F}_\Sigma$. Weiter definieren wir:
          \begin{enumerate}
          \item $\FV\bigl( \neg F \bigr) := \FV(F)$.
          \item $\BV\bigl( \neg F \bigr) := \BV(F)$.
          \end{enumerate}
    \item Sind $F, G \in \mathbb{F}_\Sigma$ und gilt au\ss{}erdem \\[0.2cm]
          \hspace*{1.3cm}
          $\bigl(\FV(F) \cup \FV(G)\bigr) \cap \bigl(\BV(F) \cup \BV(G)) = \{\}$,
          \\[0.2cm]
          so gilt auch
          \begin{enumerate}
          \item $(F \wedge G) \in \mathbb{F}_\Sigma$,
          \item $(F \vee G) \in \mathbb{F}_\Sigma$,
          \item $(F \rightarrow G) \in \mathbb{F}_\Sigma$,
          \item $(F \leftrightarrow G) \in \mathbb{F}_\Sigma$.
          \end{enumerate}
          Weiter definieren wir f\"{u}r alle Junktoren $\odot \in \{ \wedge, \vee, \rightarrow, \leftrightarrow \}$:
          \begin{enumerate}
          \item $\FV\bigl(F \odot G \bigr) := \FV(F) \cup \FV(G)$.
          \item $\BV\bigl( F \odot G \bigr) := \BV(F) \cup \BV(G)$.
          \end{enumerate}
    \item Sei $x \in \mathcal{V}$  und $F \in \mathbb{F}_\Sigma$ mit $x \not\in \BV(F)$.  Dann gilt:
          \begin{enumerate}
          \item $(\forall x \colon F) \in \mathbb{F}_\Sigma$.
          \item $(\exists x \colon F) \in \mathbb{F}_\Sigma$.
          \end{enumerate}
          Weiter definieren wir 
          \begin{enumerate}
          \item $\FV\bigl( (\forall x \colon F) \bigr) := \FV\bigl( (\exists x \colon F) \bigr) := \FV(F) \backslash \{x\}$.
          \item $\BV\bigl( (\forall x \colon F) \bigr) := \BV\bigl( (\exists x \colon F) \bigr) := \BV(F) \cup \{x\}$.  
          \end{enumerate}
    \end{enumerate}
    Ist die Signatur $\Sigma$ aus dem Zusammenhang klar oder aber unwichtig, so schreiben wir
    auch $\mathbb{F}$ statt $\mathbb{F}_\Sigma$ und sprechen dann einfach von Formeln statt von $\Sigma$-Formeln.
    \eox
\end{Definition}

Bei der oben gegebenen Definition haben wir darauf geachtet, dass eine Variable nicht gleichzeitig
frei und gebunden in einer Formel auftreten kann, denn durch eine leichte Induktion nach dem Aufbau
der Formeln l\"{a}sst sich zeigen, dass f\"{u}r alle $F \in \mathbb{F}_\Sigma$ folgendes gilt:
\\[0.2cm]
\hspace*{1.3cm}
$ \FV(F) \cap \BV(F) = \{\}$. 


\example
Setzen wir das oben begonnene Beispiel fort, so  sehen wir, dass \\[0.2cm]
\hspace*{1.3cm} $(\exists x \colon\, \leq\!(\mathtt{+}(y, x),y))$ \\[0.2cm]
eine Formel aus $\mathbb{F}_{\Sigma_{\mathrm{arith}}}$ ist. 
Die Menge der gebundenen Variablen ist $\{x\}$, die Menge der freien Variablen ist 
$\{ y \}$. \eox

Wenn wir Formeln immer in der oben definierten Pr\"{a}fix-Notation anschreiben w\"{u}rden, dann w\"{u}rde die Lesbarkeit unverh\"{a}ltnism\"{a}\ss{}ig leiden. 
Zur Abk\"{u}rzung vereinbaren wir, dass in der Pr\"{a}dikatenlogik dieselben Regeln zur Klammer-Ersparnis
gelten sollen,  die wir schon in der Aussagenlogik verwendet haben.  Zus\"{a}tzlich werden
gleiche Quantoren zusammengefasst: Beispielsweise schreiben wir  
\\[0.2cm]
\hspace*{1.3cm}
$\forall x, y \colon p(x, y)  \quad \mathrm{statt} \quad \forall x \colon ( \forall y \colon p(x,y))$.
\\[0.2cm]
Dar\"{u}ber hinaus legen wir fest, dass Quantoren st\"{a}rker binden als die aussagenlogischen Junktoren.
Damit k\"{o}nnen wir
\\[0.2cm]
\hspace*{1.3cm}
$\forall x \colon p(x) \wedge G \quad \mathrm{statt} \quad \bigl(\forall x \colon p(x)\bigr) \wedge G$
\\[0.2cm]
schreiben.
Au\ss{}erdem vereinbaren wir, dass wir zweistellige Pr\"{a}dikats- und Funktions-Zeichen auch in Infix-Notation angeben
d\"{u}rfen.  Um eine eindeutige Lesbarkeit zu erhalten, m\"{u}ssen wir dann gegebenenfalls Klammern setzen. 
Wir schreiben beispielsweise \\[0.2cm]
\hspace*{1.3cm} $\mathtt{n}_1 = \mathtt{n}_2$  \quad anstelle von \quad $=(\mathtt{n}_1, \mathtt{n}_2)$. \\[0.2cm]
Die Formel $(\exists x \colon \leq(\mathtt{+}(y, x),y))$ wird dann lesbarer als \\[0.2cm]
\hspace*{1.3cm} $\exists x \colon y + x \leq y$ \\[0.2cm]
geschrieben.  Au\ss{}erdem finden Sie in der Literatur h\"{a}ufig Ausdr\"{u}cke der Form
$\forall x\el M: F$ oder $\exists x\el M: F$.  Hierbei handelt es sich um Abk\"{u}rzungen, die durch
\\[0.2cm]
\hspace*{1.3cm}
$\ds \bigl(\forall x\el M: F\bigr) \stackrel{\mathrm{def}}{\Longleftrightarrow} \forall x: \bigl(x \el M \rightarrow F\bigr)$,
\quad und \quad 
$\ds\bigl(\exists x\el M: F\bigr) \stackrel{\mathtt{def}}{\Longleftrightarrow} \exists x: \bigl(x \el M \wedge F\bigr)$.
\\[0.2cm]
definiert sind.

\section{Semantik der Pr\"{a}dikatenlogik}
Als n\"{a}chstes legen wir die Bedeutung der Formeln fest.  Dazu definieren wir 
den Begriff einer {\emph{\color{blue}$\Sigma$-Struktur}}.  Eine solche Struktur legt fest, wie die
Funktions- und Pr\"{a}dikats-Zeichen der Signatur $\Sigma$ zu interpretieren sind.

\begin{Definition}[Struktur]
    Es sei eine  Signatur \\[0.2cm]
    \hspace*{1.3cm} $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$. \\[0.2cm]
    gegeben. Eine {\emph{\color{blue}$\Sigma$-Struktur}} $\struct$ ist ein
    Paar $\langle \mathcal{U}, \mathcal{J} \rangle$, so dass folgendes gilt:
    \begin{enumerate}
        \item $\mathcal{U}$ ist eine nicht-leere Menge. Diese Menge nennen wir auch das
              {\emph{\color{blue}Universum}} der $\Sigma$-Struktur.  Dieses Universum enth\"{a}lt die Werte,
              die sich sp\"{a}ter bei der Auswertung der Terme ergeben werden.
        \item $\mathcal{J}$ ist die {\emph{\color{blue}Interpretation}} der Funktions-- und Pr\"{a}dikats-Zeichen.
              Formal definieren wir $\mathcal{J}$ als eine Abbildung mit folgenden Eigenschaften:
        \begin{enumerate}
        \item Jedem Funktions-Zeichen $f \el \mathcal{F}$ mit $\textsl{arity}(f) = m$ wird
              eine $m$-stellige Funktion \\[0.2cm]
              \hspace*{1.3cm}
              $f^\mathcal{J}\colon \mathcal{U} \times \cdots \times \mathcal{U} \rightarrow \mathcal{U}$ \\[0.2cm]
              zugeordnet, die $m$-Tupel des Universums $\mathcal{U}$ in das Universum $\mathcal{U}$ abbildet.
        \item Jedem Pr\"{a}dikats-Zeichen $p \el \mathcal{P}$ mit $\textsl{arity}(p) = n$ wird
              eine $n$-stellige Funktion \\[0.2cm]
              \hspace*{1.3cm} 
              $p^\mathcal{J}\colon \mathcal{U} \times \cdots \times \mathcal{U} \rightarrow \mathbb{B}$ \\[0.2cm]
              zugeordnet, die jedem $n$-Tupel des Universums $\mathcal{U}$ einen Wahrheitswert aus
              der  Menge $\mathbb{B} =  \{\mathtt{true}, \mathtt{false}\}$ zuordnet.
        \item Ist das Zeichen ``$=$'' ein Element der Menge der Pr\"{a}dikats-Zeichen $\mathcal{P}$, so gilt
              \\[0.2cm]
              \hspace*{1.3cm}  
              $=^\mathcal{J}(u,v) = \mathtt{true}$ \quad g.d.w. \quad $u = v$, \\[0.2cm]
              das Gleichheits-Zeichen wird also durch die identische Relation
              $\id_\mathcal{U}$ interpretiert. \eox
        \end{enumerate}
    \end{enumerate}
\end{Definition}

\example
Wir geben ein Beispiel f\"{u}r eine $\Sigma_{\mathrm{arith}}$-Struktur
$\struct_{\mathrm{arith}} = \langle \mathcal{U}_{\mathrm{arith}}, \mathcal{J}_{\mathrm{arith}} \rangle$,
indem wir definieren:
\begin{enumerate}
\item $\mathcal{U}_{\mathrm{arith}} = \mathbb{N}$.
\item Die Abbildung $\mathcal{J}_{\mathrm{arith}}$ legen wir dadurch fest, dass die
      Funktions-Zeichen $0$, $1$, $\mathtt{+}$, $\mathtt{-}$, $*$
      durch die entsprechend benannten Funktionen auf der Menge $\mathbb{N}$ 
      der nat\"{u}rlichen Zahlen zu interpretieren sind.

      Ebenso sollen die Pr\"{a}dikats-Zeichen $=$ und $\leq$ durch die Gleichheits-Relation
      und die Kleiner-Gleich-Relation interpretiert werden. \eox
\end{enumerate}

\example
 Wir geben ein weiteres  Beispiel.
Die Signatur  $\Sigma_G$ der Gruppen-Theorie sei definiert als \\[0.2cm]
\hspace*{1.3cm} $\Sigma_G = \langle \mathcal{V}, \mathcal{F}, \mathcal{P},\textsl{arity}\rangle$ 
\quad mit
\begin{enumerate}
\item $\mathcal{V} := \{ x, y, z \}$
\item $\mathcal{F} := \{ 1, * \}$
\item $\mathcal{P} := \{ \mathtt{=} \}$
\item $\textsl{arity} = \bigl\{ \pair(1,0), \pair(*,2), \pair(\mathtt{=},2)\bigr\}$
\end{enumerate}
Dann k\"{o}nnen wir eine $\Sigma_G$ Struktur $\mathcal{Z} = \langle \{a,
b\},\mathcal{J}\rangle$ definieren, 
indem wir die Interpretation $\mathcal{J}$ 
wie folgt festlegen:
\begin{enumerate}
\item $1^\mathcal{J} := a$ 
\item $*^\mathcal{J} := \Bigl\{ \bigl\langle\pair(a,a), a\bigr\rangle,
                                   \bigl\langle\pair(a,b), b\bigr\rangle,
                                   \bigl\langle\pair(b,a), b\bigr\rangle,
                                   \bigl\langle\pair(b,b), a\bigr\rangle \Bigr\}$
\item $=^\mathcal{J}$ ist die Identit\"{a}t: \\[0.2cm]
       $=^\mathcal{J} \;:=\; \Bigl\{ \bigl\langle\pair(a,a), \mathtt{true}\bigr\rangle,
                                 \bigl\langle\pair(a,b), \mathtt{false}\bigr\rangle,
                                 \bigl\langle\pair(b,a), \mathtt{false}\bigr\rangle,
                                 \bigl\langle\pair(b,b), \mathtt{true}\bigr\rangle \Bigr\}$
                                 
      Beachten Sie, dass wir bei der Interpretation des Gleichheits-Zeichens 
      keinen Spielraum haben! \eox
\end{enumerate}

Falls wir Terme auswerten wollen, die Variablen enthalten, so m\"{u}ssen wir f\"{u}r diese
Variablen irgendwelche Werte aus dem Universum einsetzen.  Welche Werte wir einsetzen, kann
durch eine {\emph{\color{blue}Variablen-Belegung}} festgelegt werden.  Diesen Begriff definieren wir
nun.

\begin{Definition}[Variablen-Belegung]
    Es sei eine  Signatur \\[0.2cm]
    \hspace*{1.3cm} $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$ \\[0.2cm]
    gegeben.  Weiter sei $\struct = \langle \mathcal{U}, \mathcal{J} \rangle$ eine $\Sigma$-Struktur.  Dann bezeichnen wir 
     eine Abbildung \\[0.2cm]
    \hspace*{1.3cm} $\mathcal{I}: \mathcal{V} \rightarrow \mathcal{U}$ \\[0.2cm]
    als eine     \colorbox{yellow}{$\struct$-\emph{Variablen-Belegung}}.

    Ist $\mathcal{I}$ eine $\struct$-Variablen-Belegung,
    $x \in \mathcal{V}$ und $c \in \mathcal{U}$, so bezeichnet $\mathcal{I}[x/c]$ die Variablen-Belegung, die 
    der Variablen $x$ den Wert $c$ zuordnet und die ansonsten mit $\mathcal{I}$ \"{u}bereinstimmt: \\[0.2cm]
    \hspace*{1.3cm} 
    $\mathcal{I}[x/c](y) := \left\{
    \begin{array}{ll}
    c               & \mbox{falls}\; y = x;  \\
    \mathcal{I}(y)  & \mbox{sonst}.          \\
    \end{array}
    \right.$ \eox
\end{Definition}

\begin{Definition}[Semantik der Terme]
    Ist $\struct = \pair(\mathcal{U},\mathcal{J})$ eine $\Sigma$-Struktur und $\mathcal{I}$ eine $\struct$-Variablen-Belegung,
    so definieren wir f\"{u}r jeden Term $t$ den {\emph{\color{blue}Wert}} $\struct(\mathcal{I}, t)$ durch Induktion \"{u}ber den Aufbau
    von $t$:
    \begin{enumerate}
    \item F\"{u}r Variablen $x \in \mathcal{V}$ definieren wir: \\[0.2cm]
          \hspace*{1.3cm} $\struct(\mathcal{I}, x) := \mathcal{I}(x)$.
    \item F\"{u}r $\Sigma$-Terme der Form $f(t_1,\cdots,t_n)$ definieren wir \\[0.2cm]
          \hspace*{1.3cm} $\struct\bigl(\mathcal{I}, f(t_1,\cdots,t_n)\bigr) := 
                           f^\mathcal{J}\bigl( \struct(\mathcal{I}, t_1), \cdots, \struct(\mathcal{I}, t_n) \bigr)$.
                           \eox
    \end{enumerate}
\end{Definition}

\example
Mit der oben definieren $\Sigma_\mathrm{arith}$-Struktur
$\struct_{\mathrm{arith}}$ definieren wir eine
$\struct_{\mathrm{arith}}$-Variablen-Belegung $\mathcal{I}$ durch
\\[0.2cm]
\hspace*{1.3cm} $\mathcal{I} := \bigl\{ \pair(x,0), \pair(y,7), \pair(z,42)\bigr\}$,
\\[0.2cm]
es gilt also
\\[0.2cm]
\hspace*{1.3cm} $\mathcal{I}(\mathtt{x}) := 0$, \quad $\mathcal{I}(\mathtt{y}) := 7$,
\quad und \quad $\mathcal{I}(\mathtt{z}) := 42$.
\\[0.2cm]
Dann gilt offenbar \\[0.2cm]
\hspace*{1.3cm}  $\struct\bigl(\mathcal{I}, \mathtt{x} + \mathtt{y} \bigr) = 7$.

\begin{Definition}[Semantik der atomaren $\Sigma$-Formeln]
    Ist $\struct$ eine $\Sigma$-Struktur und $\mathcal{I}$ eine $\struct$-Variablen-Belegung,
    so definieren wir f\"{u}r jede atomare $\Sigma$-Formel 
    $p(t_1, \cdots, t_n)$ den Wert $\struct\bigl(\mathcal{I}, p(t_1, \cdots, t_n) \bigr)$ wie folgt: \\[0.2cm]
    \hspace*{1.3cm} $\struct\bigl(\mathcal{I}, p(t_1,\cdots,t_n)\bigr) := 
                     p^\mathcal{J}\bigl( \struct(\mathcal{I}, t_1), \cdots, \struct(\mathcal{I}, t_n) \bigr)$.
                     \eox
\end{Definition}

\example
In Fortf\"{u}hrung des obigen Beispiels gilt: \\[0.2cm]
\hspace*{1.3cm}  $\struct\bigl(\mathcal{I},z \leq x + y \bigr) = \mathtt{false}$.
\eox

Um die Semantik beliebiger $\Sigma$-Formeln definieren zu k\"{o}nnen, nehmen wir an, dass wir,
genau wie in der Aussagenlogik, die folgenden Funktionen zur Verf\"{u}gung haben:
\begin{enumerate}
\item $\circneg: \mathbb{B} \rightarrow \mathbb{B}$,
\item $\circvee: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$,
\item $\circwedge: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$,
\item $\circright: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$,
\item $\circleftright: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$.
\end{enumerate}
Die Semantik dieser Funktionen hatten wir durch die Tabelle in Abbildung
\ref{tab:aussagen-logik} auf Seite \pageref{tab:aussagen-logik} gegeben. 

\begin{Definition}[Semantik der $\Sigma$-Formeln]
    Ist $\struct$ eine $\Sigma$-Struktur und $\mathcal{I}$ eine $\struct$-Variablen-Belegung,
    so definieren wir f\"{u}r jede $\Sigma$-Formel $F$ den Wert $\struct(\mathcal{I},F)$
    durch Induktion \"{u}ber den Aufbau von $F$:
    \begin{enumerate}
    \item $\struct(\mathcal{I},\verum) := \mathtt{true}$ und $\struct(\mathcal{I},\falsum) := \mathtt{false}$.
    \item $\struct(\mathcal{I}, \neg F) \;:=\; \circneg\bigl(\struct(\mathcal{I}, F)\bigr)$.
    \item $\struct(\mathcal{I}, F \wedge G) \;:=\; \circwedge\bigl(\struct(\mathcal{I}, F), \struct(\mathcal{I}, G)\bigr)$.
    \item $\struct(\mathcal{I}, F \vee G) \;:=\; \circvee\bigl(\struct(\mathcal{I}, F), \struct(\mathcal{I}, G)\bigr)$.
    \item $\struct(\mathcal{I}, F \rightarrow G) \;:=\; \circright\!\bigl(\struct(\mathcal{I}, F), \struct(\mathcal{I}, G)\bigr)$.
    \item $\struct(\mathcal{I}, F \leftrightarrow G) \;:=\; \circleftright\bigl(\struct(\mathcal{I}, F), \struct(\mathcal{I}, G)\bigr)$.
    \item $\struct\bigl(\mathcal{I}, \forall x\colon F\bigr) \;:=\; \left\{
      \begin{array}{ll}
         \mathtt{true}  & \mbox{falls}\; \struct(\mathcal{I}[x/c], F) = \mathtt{true}\quad \mbox{f\"{u}r alle}\; c\in \mathcal{U}\;\mbox{gilt}; \\
         \mathtt{false} & \mbox{sonst}.
      \end{array}
      \right.$
    \item $\struct\bigl(\mathcal{I}, \exists x \colon F\bigr) \;:=\; \left\{
      \begin{array}{ll}
         \mathtt{true}  & \mbox{falls}\; \struct(\mathcal{I}[x/c], F) = \mathtt{true}\quad \mbox{f\"{u}r ein}\; c\in \mathcal{U}\;\mbox{gilt}; \\
         \mathtt{false} & \mbox{sonst}.
      \end{array}
      \right.$\eox    
    \end{enumerate}
\end{Definition}

\example
In Fortf\"{u}hrung des obigen Beispiels gilt \\[0.2cm]
\hspace*{1.3cm}  $\struct\bigl(\mathcal{I}, \forall \mathtt{x}: x *  0 < 1 \bigr) = \mathtt{true}$.
\eox

\begin{Definition}[Allgemeing\"{u}ltig]
    Ist $F$ eine $\Sigma$-Formel, so dass f\"{u}r jede $\Sigma$-Struktur $\struct$ und f\"{u}r jede
    $\struct$-Variablen-Belegung $\mathcal{I}$ \\[0.2cm]
    \hspace*{1.3cm} $\struct(\mathcal{I}, F) = \mathtt{true}$ \\[0.2cm]
    gilt, so bezeichnen wir $F$ als {\emph{\color{blue}allgemeing\"{u}ltig}}.  In diesem Fall schreiben wir \\[0.2cm]
    \hspace*{1.3cm} $\models F$. 
    \eox
\end{Definition}

Ist $F$ eine Formel f\"{u}r die $\FV(F) = \{\}$ ist, dann h\"{a}ngt der Wert $\struct(\mathcal{I}, F)$
offenbar gar nicht von der Interpretation $\mathcal{I}$ ab.  Solche Formeln bezeichnen wir auch als 
{\emph{\color{blue}geschlossene}} Formeln.   In diesem Fall schreiben wir k\"{u}rzer  $\struct(F)$
an Stelle von $\struct(\mathcal{I}, F)$.  Gilt dann zus\"{a}tzlich $\struct(F) = \mathtt{true}$, 
so sagen wir auch dass $\struct$ ein {\emph{\color{blue}Modell}} von $F$ ist.  Wir schreiben dann \\[0.2cm]
\hspace*{1.3cm} $\mathcal{S} \models F$.
\vspace{0.1cm}

Die Definition der Begriffe ``{\emph{\color{blue}erf\"{u}llbar}}'' und
``{\emph{\color{blue}\"{a}quivalent}}'' lassen sich nun aus der Aussagenlogik \"{u}bertragen. 
Um unn\"{o}tigen Ballast in den Definitionen zu vermeiden, nehmen wir im Folgenden immer eine
feste Signatur $\Sigma$ als gegeben an.  Dadurch k\"{o}nnen wir in den folgenden Definitionen
von Termen, Formeln, Strukturen, etc.~sprechen und meinen damit  $\Sigma$-Terme,
$\Sigma$-Formeln und $\Sigma$-Strukturen.

\begin{Definition}[\"{a}quivalent]
  Zwei Formeln $F$ und $G$ hei\ss{}en {\emph{\color{blue}\"{a}quivalent}} g.d.w. gilt \\[0.2cm]
  \hspace*{1.3cm} $\models F \leftrightarrow G$.
  \eox
\end{Definition}

\noindent
Alle aussagenlogischen \"{A}quivalenzen sind auch pr\"{a}dikatenlogische \"{A}quivalenzen.

\begin{Definition}[Erf\"{u}llbar]
    Eine Menge $M \subseteq \mathbb{F}_\Sigma$ ist genau dann {\emph{\color{blue}erf\"{u}llbar}},
    wenn es eine Struktur $\struct$ und eine Variablen-Belegung $\mathcal{I}$ gibt, so dass 
      \\[0.2cm]
    \hspace*{1.3cm} $\forall m \el M: \struct(\mathcal{I},m) = \mathtt{true}$ \\[0.2cm]
    gilt.  Andernfalls hei\ss{}t $M$ {\emph{\color{blue}unerf\"{u}llbar}} oder auch {\emph{\color{blue}widerspr\"{u}chlich}}. 
    Wir schreiben daf\"{u}r auch \\[0.2cm]
    \hspace*{1.3cm} $M \models \falsum$
    \eox
\end{Definition}

\noindent
Unser Ziel ist es, ein Verfahren anzugeben, mit dem wir in der Lage sind zu \"{u}berpr\"{u}fen,
ob eine Menge $M$ von Formeln {\emph{\color{blue}widerspr\"{u}chlich}} ist, ob also 
 $M \models \falsum$ gilt.  Es zeigt sich, dass dies im Allgemeinen nicht
m\"{o}glich ist, die Frage, ob $M \models \falsum$ gilt, ist unentscheidbar.  Ein Beweis
dieser Tatsache geht allerdings \"{u}ber den Rahmen dieser Vorlesung heraus.
Dem gegen\"{u}ber ist es m\"{o}glich, \"{a}hnlich wie in der Aussagenlogik
einen {\emph{\color{blue}Kalk\"{u}l}} $\vdash$ anzugeben, so dass gilt \\[0.2cm]
\hspace*{1.3cm} $M \vdash \falsum$ \quad g.d.w. \quad $M \models \falsum$. \\[0.2cm]
Ein solcher Kalk\"{u}l kann dann zur Implementierung eines
{\emph{\color{blue}Semi-Entscheidungs-Verfahrens}} benutzt werden:  Um zu \"{u}berpr\"{u}fen, ob
$M \models \falsum$ gilt, versuchen wir, aus der Menge $M$ die Formel $\falsum$
herzuleiten.  
Falls wir dabei systematisch vorgehen, indem wir alle m\"{o}glichen Beweise durchprobieren,
so werden wir, falls tats\"{a}chlich $M \models \falsum$ gilt, auch irgendwann einen Beweis
finden, der $M \vdash \falsum$ zeigt.   Wenn allerdings der Fall \\[0.2cm]
\hspace*{1.3cm}  $M \not\models \falsum$ \\[0.2cm]
vorliegt,  so werden wir dies im allgemeinen nicht feststellen k\"{o}nnen, denn die Menge aller Beweise ist unendlich gro\ss{}
und wir k\"{o}nnen nie alle Beweise ausprobieren.  Wir k\"{o}nnen lediglich sicherstellen, dass
wir jeden Beweis irgendwann versuchen.  Wenn es aber keinen Beweis gibt, so k\"{o}nnen wir das
nie sicher sagen, denn zu jedem festen Zeitpunkt haben wir ja immer nur einen Teil der in
Frage kommenden Schl\"{u}sse ausprobiert.

Die Situation ist \"{a}hnlich der, wie bei der \"{u}berpr\"{u}fung bestimmter zahlentheoretischer
Fragen.  Wir betrachten dazu ein konkretes Beispiel: Eine Zahl $n$ hei\ss{}t {\emph{\color{blue}perfekt}},
wenn die Summe aller echten Teiler von $n$ wieder die Zahl $n$ ergibt.  Beispielsweise ist
die Zahl $6$ perfekt, denn die Menge der echten Teiler von $6$ ist $\{1,2,3\}$ und es gilt
\\[0.2cm]
\hspace*{1.3cm}
$1 + 2 + 3 = 6$.
\\[0.2cm]
Bisher sind alle bekannten perfekten Zahlen durch $2$ teilbar.  Die Frage, ob es auch
ungerade Zahlen gibt, die perfekt sind, ist ein offenes mathematisches Problem.  Um dieses
Problem zu l\"{o}sen k\"{o}nnten wir eine Programm schreiben, dass der Reihe nach f\"{u}r alle
ungerade Zahlen \"{u}berpr\"{u}ft, ob die Zahl perfekt ist.  Abbildung \ref{fig:find-perfect.stlx}
auf Seite \pageref{fig:find-perfect.stlx} zeigt ein solches Programm.  Wenn es eine ungerade perfekte Zahl
gibt, dann wird dieses Programm diese Zahl auch irgendwann finden.  Wenn es aber keine
ungerade perfekte Zahl gibt, dann wird das Programm bis zum St.~Nimmerleinstag rechnen und
wir werden nie mit Sicherheit wissen, dass es keine ungeraden perfekten Zahlen gibt.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm
                ]
    perfect := procedure(n) {
        return +/ { x : x in {1 .. n-1} | n % x == 0 } == n;
    };    
    findPerfect := procedure() {
        n := 1;
        while (true) {
            if (perfect(n)) {
                if (n % 2 == 0) {
                    print(n);
                } else {
                    print("Heureka: Odd perfect number $n$ found!");
                }
            } 
            n := n + 1;
        }
    };
    findPerfect();
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Suche nach einer ungeraden perfekten Zahl.}
  \label{fig:find-perfect.stlx}
\end{figure} 


In den n\"{a}chsten Abschnitten gehen wir daran, den oben erw\"{a}hnten Kalk\"{u}l $\vdash$ zu definieren.
Es zeigt sich, dass die Arbeit wesentlich einfacher wird, wenn wir uns auf bestimmte
Formeln, sogenannte {\emph{\color{blue}Klauseln}}, beschr\"{a}nken.  Wir zeigen daher zun\"{a}chst im n\"{a}chsten
Abschnitt, dass jede Formel-Menge $M$ so in eine Menge von Klauseln $K$ transformiert
werden kann, dass $M$ genau dann erf\"{u}llbar ist, wenn $K$ erf\"{u}llbar ist.  Daher ist die
Beschr\"{a}nkung auf Klauseln keine echte Einschr\"{a}nkung.


\subsection{Implementierung pr\"{a}dikatenlogischer Strukturen in \textsc{SetlX}}
Der im letzten Abschnitt pr\"{a}sentierte Begriff einer pr\"{a}dikatenlogischen Struktur erscheint zun\"{a}chst
sehr abstrakt.  Wir wollen in diesem Abschnitt zeigen, dass sich dieser Begriff in einfacher Weise in
\textsc{SetlX} implementieren l\"{a}sst.  Dadurch gelingt es, diesen Begriff zu veranschaulichen.  Als konkretes
Beispiel wollen wir Strukturen zu Gruppen-Theorie betrachten.  Die Signatur $\Sigma_G$ der
Gruppen-Theorie war im letzten Abschnitt durch die Definition
\[ \Sigma_G = 
   \bigl\langle \{x,y,z\},\; \{1,*\},\; \{=\},\; \{ \pair(1,0), \pair(*,2), \pair(=,2) \} \bigr\rangle 
\]
gegeben worden.  Hierbei ist also ``$1$'' ein 0-stelliges Funktions-Zeichen, ``$*$'' ist
eine 2-stelliges Funktions-Zeichen und ``$=$'' ist ein 2-stelliges Pr\"{a}dikats-Zeichen.
Wir hatten bereits eine Struktur $\mathcal{S}$ angegeben, deren Universum aus der Menge
$\{ a, b \}$ besteht.  In \textsl{SetlX} k\"{o}nnen wir diese Struktur durch den in Abbildung
\ref{fig:gruppen.stl} gezeigten Code implementieren.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
   a := "a";
   b := "b"; 
   u := { a, b };  // the universe
   product := { [ [ a, a ], a ],  [ [ a, b ], b ],  [ [ b, a ], b ],  [ [ b, b ], a ] };
   equals  := { [ x, y ] : x in u, y in u | x == y };
   j := { [ "E", a ], [ "^product", product ], [ "^equals", equals ] };
   s := [ u, j ];
   i := { [ "x", a ], [ "y", b ], [ "z", a ] }; 
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Implementierung einer Struktur zur Gruppen-Theorie}
\label{fig:gruppen.stl}
\end{figure}

\begin{enumerate}
\item Zur Abk\"{u}rzung haben wir in den Zeile 1 und 2 die Variablen $a$ und $b$
      als die Strings \texttt{\symbol{34}a\symbol{34}} und \texttt{\symbol{34}b\symbol{34}}
      definiert.  Dadurch k\"{o}nnen wir weiter unten die Interpretation des
      Funktions-Zeichens ``$*$'' k\"{u}rzer angeben.
\item Das in Zeile 3 definierte Universum $u$ besteht aus den beiden Strings \quoted{a} und \quoted{b}.
\item In Zeile 4 definieren wir eine Funktion \texttt{product} als bin\"{a}re Relation.  F\"{u}r
      die so definierte Funktion gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{product}(\pair(\quoted{a},\quoted{a})) = \quoted{a}$, \quad
      $\mathtt{product}(\pair(\quoted{a},\quoted{b})) = \quoted{b}$, 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{product}(\pair(\quoted{b},\quoted{a})) = \quoted{b}$, \quad
      $\mathtt{product}(\pair(\quoted{b},\quoted{b})) = \quoted{a}$.
      \\[0.2cm]  
      Diese Funktion verwenden wir sp\"{a}ter als die Interpretation $*^\mathcal{J}$ des Funktions-Zeichens ``$*$''.
\item Ebenso haben wir in Zeile 5 die Interpretation $=^\mathcal{J}$ des
      Pr\"{a}dikats-Zeichens ``$=$'' als die bin\"{a}re Relation \texttt{equals} dargestellt. 
\item In Zeile 6 fassen wir die einzelnen Interpretationen zu der Relation $j$
      zusammen, so dass f\"{u}r ein Funktions-Zeichen $f$ die Interpretation $f^\mathcal{J}$ durch
      den Wert $j(f)$ gegeben ist. 

      Da wir sp\"{a}ter den in \textsc{SetlX} eingebauten Parser verwenden werden, stellen wir
      den Operator ``\texttt{*}'' durch das Funktions-Zeichen
      ``\texttt{\symbol{94}product}'' dar und das Pr\"{a}dikats-Zeichen ``\texttt{=}'' wird
      durch das Zeichen ``\texttt{\symbol{94}equals}'' dargestellt, denn dies sind die
      Namen, die von \textsc{SetlX} intern benutzt werden.  Das neutrale Element ``$1$''
      stellen wir durch das Funktions-Zeichen ``\texttt{E}'' dar, so dass sp\"{a}ter der
      Ausdruck ``$1$'' durch den Term ``\texttt{E()}'' repr\"{a}sentiert wird.
\item Die Interpretation $j$ wird dann in Zeile 7 mit dem
      Universum $u$ zu der Struktur $s$ zusammengefasst.  
\item Schlie\ss{}lich zeigt Zeile 8, dass eine
      Variablen-Belegung ebenfalls als Relation dargestellt werden kann.  Die erste Komponente
      der Paare, aus denen diese Relation besteht, sind die Variablen.  Die zweite Komponente
      ist ein Wert aus dem Universum.
\end{enumerate}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
   evalFormula := procedure(f, s, i) {
       u := s[1];
       match (f) {
           case true     :  return true;
           case false    :  return false;
           case !g       :  return !evalFormula(g, s, i);
           case g && h   :  return evalFormula(g, s, i) && evalFormula(h, s, i);
           case g || h   :  return evalFormula(g, s, i) || evalFormula(h, s, i);
           case g => h   :  return evalFormula(g, s, i) => evalFormula(h, s, i);
           case g <==> h :  return evalFormula(g, s, i) == evalFormula(h, s, i);
           case forall (x in _ | g) : 
                return forall (c in u | evalFormula(g, s, modify(i, x, c)));
           case exists (x in _ | g) : 
                return exists (c in u | evalFormula(g, s, modify(i, x, c)));
           default : return evalAtomic(f, s, i);  // atomic formula
       }
   };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Auswertung pr\"{a}dikatenlogischer Formeln}
\label{fig:pl-evaluate.stlx}
\end{figure}

Als n\"{a}chstes \"{u}berlegen wir uns, wie wir pr\"{a}dikatenlogische Formeln in einer solchen Struktur
auswerten k\"{o}nnen.  Abbildung \ref{fig:pl-evaluate.stlx} zeigt die Implementierung der Prozedur
$\textsl{evalFormula}(f, S, I)$, der als Argumente eine pr\"{a}dikatenlogische Formel $f$, eine Struktur
$\mathcal{S}$ und eine Variablen-Belegung $\mathcal{I}$ \"{u}bergeben werden.  Die Formel wird
dabei als Term dargestellt,  
ganz \"{a}hnlich, wie wir das bei der Implementierung der Aussagenlogik schon praktiziert haben.
Beispielsweise k\"{o}nnen wir die Formel
\[ \forall x: \forall y: x * y = y * x \]
durch den Term
\begin{verbatim}
  ^forall(^variable("x"), ^forall(^variable("y"), 
       ^equals(^product(^variable("x"), ^variable("y")), 
              ^product(^variable("y"), ^variable("x"))
              )))
\end{verbatim}
darstellen und dass ist im Wesentlichen auch die Struktur, die erzeugt wird, wenn wir den
String
\\[0.2cm]
\hspace*{1.3cm}
``\texttt{forall (x in u | exists (y in u | x * y == E()))}''
\\[0.2cm]
mit Hilfe der in \textsc{SetlX} vordefinierten Funktion \texttt{parse} in einen Term umwandeln. 

\remark
 An dieser Stelle wundern Sie sich vermutlich, warum wir oben 
``\texttt{x in \_}'' und ``\texttt{y in \_}'' schreiben, denn wir wollen die Variablen
\texttt{x} und \texttt{y} eigentlich ja gar nicht einschr\"{a}nken.  Der Grund ist, dass die
Syntax von \textsc{SetlX} nur solche Quantoren erlaubt, in denen die Variablen auf eine
Menge eingeschr\"{a}nkt sind.  Daher sind wir gezwungen, bei der Verwendung von Quantoren die
Variablen syntaktisch einzuschr\"{a}nken.  Wir schreiben deswegen 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (x in \_ | $g$)} \quad bzw. \quad
\texttt{exists (x in \_ | $g$)} 
\\[0.2cm]
an Stelle von 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (x | $g$)} \quad bzw. \quad
\texttt{exists (x | $g$)}. 
\\[0.2cm]
Da wir $x$ hier nicht wirklich einschr\"{a}nken wollen, schreiben wir ``\texttt{x in \_}'' und benutzen
``\texttt{\_}'' als sogenannte {\emph{\color{blue}anonyme} Variable}.
\eox

Die Auswertung einer pr\"{a}dikatenlogischen Formel ist nun analog zu der in Abbildung \ref{fig:evaluate.stlx}
auf Seite \pageref{fig:evaluate.stlx} gezeigten Auswertung aussagenlogischer Formeln.  
Neu ist nur die Behandlung der Quantoren.  In den Zeilen 11 und 12 behandeln wir die Auswertung
allquantifizierter Formeln.  Ist $f$ eine Formel der Form $\forall y \in u \colon h$,
so wird die Formel $f$ durch den Term 
\\[0.2cm]
\hspace*{1.3cm}
$f = \texttt{\symbol{94}forall(}y, u, h\mathtt{)}$
\\[0.2cm]
dargestellt.  Das Muster 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{forall (x in \_ | g)}
\\[0.2cm]
bindet daher \texttt{x} an die tats\"{a}chlich auftretende Variable $y$ und \texttt{g} an die Teilformel $h$.
Die Auswertung von $\forall x\colon g$
geschieht nach der Formel
\[\struct\bigl(\mathcal{I}, \forall x\colon g\bigr) \;:=\; \left\{
      \begin{array}{ll}
         \mathtt{true}  & \mbox{falls}\; \struct(\mathcal{I}[x/c], g) = \mathtt{true}\quad \mbox{f\"{u}r alle}\; c\in \mathcal{U}\;\mbox{gilt}; \\
         \mathtt{false} & \mbox{sonst}.
      \end{array}
      \right.
\]
Um die Auswertung implementieren zu k\"{o}nnen, verwenden wir eine Prozedur $\textsl{modify}()$, welche die
Variablen-Belegung $i$ an der Stelle $x$ zu $c$ ab\"{a}ndert, es gilt also
\[ \textsl{modify}(\mathcal{I},x,c) = \mathcal{I}[x/c]. \]
Die Implementierung dieser Prozedur wird sp\"{a}ter in Abbildung \ref{fig:fol-evaluate-term.stlx}
gezeigt.  Bei der Auswertung eines All-Quantors k\"{o}nnen wir ausnutzen, dass die Sprache \textsc{SetlX}
selber den Quantor \texttt{forall} unterst\"{u}tzt.  Wir k\"{o}nnen also direkt testen, ob die
Formel f\"{u}r alle m\"{o}glichen Werte $c$, die wir f\"{u}r die Variable $x$ einsetzen k\"{o}nnen,
richtig ist.  Die Auswertung eines Existenz-Quantors ist analog zur Auswertung eines All-Quantors.



\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
   evalAtomic := procedure(a, s, i) {
       j  := s[2];
       p  := fct(a); // predicate symbol
       pJ := j[p];
       argList := args(a);
       argsVal := evalTermList(argList, s, i);
       return argsVal in pJ;
   };  
   evalTerm := procedure(t, s, i) {
       if (fct(t) == "^variable") {
           varName := args(t)[1];
           return i[varName];
       }
       j       := s[2];
       f       := fct(t); // function symbol
       fJ      := j[f];
       argList := args(t);
       argsVal := evalTermList(argList, s, i);
       if (#argsVal > 0) {        
           result := fJ[argsVal]; 
       } else {
           result := fJ;   // t is a constant
       }
       return result;
   };
   evalTermList := procedure(tl, s, i) {
       return [ evalTerm(t, s, i) : t in tl ];
   };
   modify := procedure(i, v, c) {
       x := args(v)[1];  // v = ^variable(x)
       i[x] := c;
       return i;
   };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Auswertung von Termen und atomaren Formeln.}
\label{fig:fol-evaluate-term.stlx}
\end{figure}

Abbildung \ref{fig:fol-evaluate-term.stlx} zeigt die Auswertung atomarer Formeln und
pr\"{a}dikatenlogischer Terme.  Um eine atomare Formel der Form
\\[0.2cm]
\hspace*{1.3cm}
$a = P(t_1, \cdots, t_n)$ 
\\[0.2cm]
auszuwerten, verschaffen wir uns in Zeile 4 zun\"{a}chst die dem Pr\"{a}dikats-Zeichen $P$ in der
Struktur $S$ zugeordnete Menge $pJ$.  Anschlie\ss{}end werten wir die Argumente $t_1, \cdots, t_n$ 
aus und \"{u}berpr\"{u}fen dann, ob das Ergebnis dieser Auswertung tats\"{a}chlich ein Element der Menge $pJ$ ist.

Die Prozedur $\texttt{evalTerm}()$ arbeitet wie folgt:
Das erste Argument $t$  der Prozedur $\texttt{evalTerm}(t, \mathcal{S}, \mathcal{I})$  ist der
auszuwertende Term. Das zweite Argument $\mathcal{S}$ ist eine pr\"{a}dikatenlogische 
Struktur und das dritte Argument $\mathcal{I}$ ist eine Variablen-Belegung.
\begin{enumerate}
\item Falls $t$ eine Variable ist, so geben wir in Zeile 12 einfach den Wert zur\"{u}ck, der in
      der Variablen-Belegung 
      $\mathcal{I}$ f\"{u}r diese Variable eingetragen ist.  Die Variablen-Belegung wird dabei durch eine
      zweistellige Relation dargestellt, die wir als Funktion benutzen.
\item Falls der auszuwertende Term $t$ die Form 
      \\[0.2cm]
      \hspace*{1.3cm}
      $t = F(t_1,\cdots,t_n)$
      \\[0.2cm]
      hat,  werden in Zeile 18 zun\"{a}chst rekursiv die 
      Subterme $t_1$, $\cdots$, $t_n$ ausgewertet.  Anschlie\ss{}end wird die Interpretation
      $F^\mathcal{J}$ des Funktions-Zeichens $F$ herangezogen, um die Funktion
      $F^\mathcal{J}$ f\"{u}r die gegebenen
      Argumente auszuwerten, wobei in Zeile 20 der Fall betrachtet wird, dass tats\"{a}chlich Argumente
      vorhanden sind, w\"{a}hrend  in Zeile 22 der Fall behandelt wird, dass es sich bei dem
      Funktions-Zeichen $F$ um eine Konstante handelt, deren Wert dann unmittelbar durch $F^\mathcal{J}$ gegeben ist.
\end{enumerate}
Die Implementierung der Prozedur $\texttt{evalTermList}()$ wendet die Funktion
$\mathtt{evalTerm}()$ auf alle Terme der gegebenen Liste an.
Bei der Implementierung der in Zeile 31 gezeigten Prozedur $\texttt{modify}(\textsl{I},x,c)$, 
die als Ergebnis die Variablen-Belegung $\mathcal{I}[x/c]$ berechnet, nutzen wir aus, dass
wir bei einer Funktion, die als bin\"{a}re Relation gespeichert ist, den Wert, der in dieser
Relation f\"{u}r ein Argument $x$ eingetragen ist, durch eine Zuweisung der Form
$\mathcal{I}(x) \mathtt{:=} c$ ab\"{a}ndern k\"{o}nnen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
   g1 := parse("forall (x in u | x * E() == x)");
   g2 := parse("forall (x in u | exists (y in u | x * y == E()))");
   g3 := parse("forall (x in u | forall (y in u | forall (z in u | (x*y)*z == x*(y*z) )))");
   gt := { g1, g2, g3 };
   
   print("checking group theory in the structure ", s);
   for (f in gt) {
       print( "checking ", f, ": ", evalFormula(f, s, i) );
   }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Axiome der Gruppen-Theorie}
\label{fig:gruppen-theorie.stl}
\end{figure}

Wir zeigen nun, wie sich die in Abbildung \ref{fig:pl-evaluate.stlx} gezeigte Funktion
$\texttt{evalFormula}(f, \mathcal{S}, \mathcal{I})$ benutzen l\"{a}sst um zu \"{u}berpr\"{u}fen, ob die
in Abbildung \ref{fig:gruppen.stl} gezeigte Struktur die Axiome der \emph{Gruppen-Theorie}
erf\"{u}llt.  Die Axiome der Gruppen-Theorie sind wie folgt:
\begin{enumerate}
\item Die Konstante $1$ ist das rechts-neutrale Element der Multiplikation:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\forall x\colon x * 1 = x$.
\item F\"{u}r jedes Element $x$ gibt es ein rechts-inverses Element $y$, dass mit
      dem Element $x$ multipliziert die $1$ ergibt:      
      \\[0.2cm]
      \hspace*{1.3cm}
      $\forall x \colon \exists y \colon x * y = 1$.
\item Es gilt das Assoziativ-Gesetz:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\forall x \colon \forall y \colon \forall z \colon (x * y) * z = x * (y * z)$.
\end{enumerate}
Diese Axiome sind in den Zeilen 1 bis 3 der Abbildung \ref{fig:gruppen-theorie.stl}
wiedergegeben, wobei wir die ``$1$'' durch das Funktions-Zeichen ``\texttt{E}'' dargestellt haben.
Die Schleife in den Zeilen 7 bis 9 \"{u}berpr\"{u}ft schlie\ss{}lich, ob die Formeln in der oben
definierten Struktur erf\"{u}llt sind.
\vspace*{0.3cm}
\pagebreak

\noindent
\textbf{Bemerkung}:  Mit dem oben vorgestellten Programm k\"{o}nnen wir \"{u}berpr\"{u}fen, ob eine
pr\"{a}dikatenlogische Formel in einer vorgegebenen endlichen Struktur erf\"{u}llt ist. Wir k\"{o}nnen damit
allerdings nicht \"{u}berpr\"{u}fen, ob eine Formel allgemeing\"{u}ltig ist, denn einerseits k\"{o}nnen
wir das Programm nicht anwenden, wenn die Strukturen ein unendliches Universum haben,
andererseits ist selbst die Zahl der verschiedenen endlichen Stukturen, die wir ausprobieren
m\"{u}ssten, unendlich gro\ss{}.

\exercise
\begin{enumerate}
\item Zeigen Sie, dass die Formel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\forall x: \exists y: p(x,y) \rightarrow \exists y: \forall x: p(x,y)$
      \\[0.2cm]
      \underline{nicht} allgemeing\"{u}ltig ist, indem Sie eine geeignete pr\"{a}dikatenlogische Struktur
      $\mathcal{S}$ implementieren, in der diese Formel falsch ist.
\item Entwickeln Sie ein \textsc{SetlX}-Programm, dass die obige Formel in allen Strukturen
      ausprobiert, in denen das Universum  aus einer vorgegebenen Zahl $n$ verschiedener Elemente
      besteht und testen Sie Ihr Programm f\"{u}r $n=2$.
\item \"{U}berlegen Sie, wie viele verschiedene Strukturen mit $n$ Elementen es f\"{u}r die obige Formel gibt.
\item Geben Sie eine \underline{erf\"{u}llbare} pr\"{a}dikatenlogische Formel $F$ an, die in einer pr\"{a}dikatenlogischen
      Struktur $\mathcal{S} = \pair(\mathcal{U},\mathcal{J})$ immer falsch ist, wenn das Universum
      $\mathcal{U}$ endlich ist.  \exend  
\end{enumerate}

\section{Normalformen f\"{u}r pr\"{a}dikatenlogische Formeln}
In diesem Abschnitt werden wir verschiedene M\"{o}glichkeiten zur Umformung pr\"{a}dikatenlogischer Formeln
kennenlernen.  Zun\"{a}chst geben wir einige \"{A}quivalenzen an, mit deren Hilfe Quantoren manipuliert werden k\"{o}nnen.

\begin{Satz}
  Es gelten die folgenden \"{A}quivalenzen:
  \begin{enumerate}
  \item $\models \neg\big(\forall x\colon f\big) \leftrightarrow \big(\exists x\colon \neg f\big)$
  \item $\models \neg\big(\exists x\colon f\big) \leftrightarrow \big(\forall x\colon \neg f\big)$
  \item $\models \big(\forall x\colon f\big) \wedge \big(\forall x\colon g\big) \leftrightarrow \big(\forall x\colon f \wedge g\big)$
  \item $\models \big(\exists x\colon f\big) \vee \big(\exists x\colon g\big) \leftrightarrow \big(\exists x\colon f \vee g\big)$
  \item $\models \big(\forall x\colon \forall y\colon f \big) \leftrightarrow \big(\forall y\colon  \forall x\colon f \big)$
  \item $\models \big(\exists x\colon \exists y\colon f \big) \leftrightarrow \big(\exists y\colon  \exists x\colon f \big)$
  \item Falls $x$ eine Variable ist, f\"{u}r die $x \not\in \FV(f)$ ist, so haben wir \\[0.2cm]
        \hspace*{1.3cm} $\models  \big(\forall x\colon f) \leftrightarrow f$ \quad und \quad
                        $\models  \big(\exists x\colon f) \leftrightarrow f$.
  \item Falls $x$ eine Variable ist, f\"{u}r die  $x \not\in \FV(g) \cup \BV(g)$ gilt, so haben wir die folgenden \"{A}quivalenzen:
    \begin{enumerate}
    \item $\models \big(\forall x\colon f) \vee g \leftrightarrow \forall x\colon (f \vee g)$
    \item $\models g \vee \big(\forall x\colon f) \leftrightarrow \forall x\colon (g \vee f)$
    \item $\models \big(\exists x\colon f) \wedge g \leftrightarrow \exists x\colon (f \wedge g)$
    \item $\models g \wedge \big(\exists x\colon f) \leftrightarrow \exists x\colon (g \wedge f)$
    \end{enumerate}
  \end{enumerate}
\end{Satz}

Um die \"{A}quivalenzen der letzten Gruppe anwenden zu k\"{o}nnen, ist es notwendig,
gebundene Variablen umzubenennen. Ist $f$ eine pr\"{a}dikatenlogische Formel und sind $x$ und
$y$ zwei Variablen, so bezeichnet $f[x/y]$ die Formel, die aus $f$ dadurch entsteht, dass
jedes Auftreten der Variablen $x$ in $f$ durch $y$ ersetzt wird.  Beispielsweise gilt \\[0.2cm]
\hspace*{1.3cm} $\bigl(\forall u : \exists v : p(u,v)\bigr)[u/z] = \forall z : \exists v : p(z,v)$
\\[0.2cm]
Damit k\"{o}nnen wir eine letzte \"{A}quivalenz angeben: Ist $f$ eine pr\"{a}dikatenlogische Formel,
ist $x \in BV(F)$ und ist $y$ eine Variable, die in $f$ nicht auftritt, so gilt \\[0.2cm]
\hspace*{1.3cm} $\models f \leftrightarrow f[x/y]$.
\vspace{0.3cm}

Mit Hilfe der oben stehenden \"{A}quivalenzen k\"{o}nnen wir eine Formel so umformen, dass die Quantoren nur
noch au\ss{}en stehen.  Eine solche Formel ist dann in {\emph{\color{blue}pr\"{a}nexer Normalform}}.  Wir f\"{u}hren
das Verfahren an einem Beispiel vor: Wir zeigen, dass die Formel 
\\[0.2cm]
\hspace*{1.3cm}
$\big(\forall x\colon p(x)\big) \rightarrow \big(\exists x\colon p(x)\big)$ 
\\[0.2cm]
allgemeing\"{u}ltig ist: 
$$ 
\begin{array}{ll}
                 & \big(\forall x\colon p(x)\big) \rightarrow \big(\exists x\colon p(x)\big)  \\
 \Leftrightarrow & \neg \big(\forall x\colon p(x)\big) \vee \big(\exists x\colon p(x)\big)    \\
 \Leftrightarrow & \big(\exists x\colon \neg p(x)\big) \vee \big(\exists x\colon p(x)\big)    \\
 \Leftrightarrow & \exists x\colon \bigl(\neg p(x) \vee p(x)\bigr) \\
 \Leftrightarrow & \exists x\colon \verum                                                  \\
 \Leftrightarrow & \verum                                                  \\
\end{array}
$$
\\[0.2cm]
In diesem Fall haben wir Gl\"{u}ck gehabt, dass es uns gelungen ist, die Formel als Tautologie zu
erkennen.  Im Allgemeinen reichen die obigen Umformungen aber nicht aus, um pr\"{a}dikatenlogische
Tautologien erkennen zu k\"{o}nnen.
Um Formeln noch st\"{a}rker normalisieren zu k\"{o}nnen, 
f\"{u}hren wir einen weiteren
\"{A}quivalenz-Begriff ein.  Diesen Begriff wollen wir vorher durch ein Beispiel motivieren.
Wir betrachten die beiden Formeln \\[0.2cm]
\hspace*{1.3cm} $f_1 = \forall x \colon \exists y \colon p(x,y)$ \quad und \quad $f_2 = \forall x \colon p\bigl(x,s(x)\bigr)$.\\[0.2cm]
Die beiden Formeln $f_1$ und $f_2$ sind nicht \"{a}quivalent, denn sie entstammen noch nicht
einmal der gleichen Signatur: In der Formel $f_2$ wird das Funktions-Zeichen $s$
verwendet, das in der Formel $f_1$ \"{u}berhaupt nicht auftritt. 
Auch wenn die beiden Formeln $f_1$ und $f_2$ nicht \"{a}quivalent sind, so besteht zwischen
ihnen doch die folgende Beziehung:  Ist $\textsl{S}_1$ eine
pr\"{a}dikatenlogische Struktur, in der die Formel $f_1$ gilt:
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{S}_1 \models f_1$,
\\[0.2cm]
dann k\"{o}nnen wir diese Struktur zu einer Struktur $\textsl{S}_2$ erweitern, in der die
Formel $f_2$ gilt:
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{S}_2 \models f_2$.
\\[0.2cm]
Dazu muss lediglich die Interpretation des Funktions-Zeichens $s$ so gew\"{a}hlt werden, dass
f\"{u}r jedes $x$ tats\"{a}chlich $p\bigl(x,s(x)\bigr)$ gilt.  Dies ist m\"{o}glich, denn die Formel
$f_1$ sagt ja aus, dass wir tats\"{a}chlich zu jedem $x$ einen Wert $y$ finden, f\"{u}r den
$p(x,y)$ gilt.   Die Funktion $s$ muss also lediglich zu jedem $x$ dieses $y$ zur\"{u}ck geben.



\begin{Definition}[Skolemisierung]
  Es sei $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$
  eine Signatur.  Ferner sei $f$ eine geschlossene $\Sigma$-Formel der Form \\[0.2cm]
  \hspace*{1.3cm} 
  $f = \forall x_1, \cdots, x_n \colon \exists y \colon g(x_1, \cdots, x_n, y)$. \\[0.2cm]
  Dann w\"{a}hlen wir ein neues $n$-stelliges Funktions-Zeichen $s$, d.h.~wir nehmen ein Zeichen $s$, dass in
  der Menge $\mathcal{F}$ nicht auftritt und erweitern die Signatur $\Sigma$ zu der Signatur \\[0.2cm]
  \hspace*{1.3cm} 
  $\Sigma' := \Bigl\langle \mathcal{V}, \mathcal{F} \cup \{s\}, \mathcal{P}, \textsl{arity} \cup \bigl\{\pair(s,n)\bigr\} \Bigr\rangle$, \\[0.2cm]
  in der wir $s$ als neues $n$-stelliges Funktions-Zeichen deklarieren.  Anschlie\ss{}end definieren wir die $\Sigma'$-Formel
  $f'$ wie folgt: \\[0.2cm]
  \hspace*{1.3cm} 
  $f' := \textsl{Skolem}(f) := 
  \forall x_1 \colon \cdots \forall x_n \colon g\bigl(x_1, \cdots, x_n, s(x_1,\cdots,x_n)\bigr)$
  \\[0.2cm]
  Wir lassen also den Existenz-Quantor $\exists y$ weg und ersetzen jedes Auftreten
  der Variable $y$ durch den Term $s(x_1,\cdots,x_n)$.  Wir sagen, dass die Formel $f'$ aus der Formel $f$
  durch einen {\emph{\color{blue}Skolemisierungs-Schritt}} hervorgegangen ist. 
  \eox
\end{Definition}

In welchem Sinne sind eine Formel $f$ und eine Formel $f'$, die aus $f$ durch einen 
Skolem\-isierungs-Schritt hervorgegangen sind, \"{a}quivalent?  Zur Beantwortung dieser Frage
dient die folgende Definition. 

\begin{Definition}[Erf\"{u}llbarkeits-\"{A}quivalenz]
   Zwei geschlossene Formeln $f$ und $g$ hei\ss{}en 
   {\emph{\color{blue}erf\"{u}llbarkeits-\"{a}quivalent}}
   falls $f$ und $g$ entweder beide erf\"{u}llbar oder beide unerf\"{u}llbar sind.
   Wenn $f$ und $g$ erf\"{u}llbarkeits-\"{a}quivalent sind, so schreiben wir \\[0.2cm]
   \hspace*{1.3cm} $f \approx_e g$.
\eox
\end{Definition}


\noindent
\begin{Satz}
  Falls die Formel $f'$ aus der Formel $f$ durch einen Skolemisierungs-Schritt 
  hervorgegangen ist, so sind $f$ und $f'$ erf\"{u}llbarkeits-\"{a}quivalent.
\end{Satz}


Wir k\"{o}nnen nun ein einfaches Verfahren angeben, um Existenz-Quantoren aus einer Formel
zu eliminieren.  Dieses Verfahren besteht aus zwei Schritten:  Zun\"{a}chst bringen wir die Formel
in pr\"{a}nexe Normalform. Anschlie\ss{}end k\"{o}nnen wir die Existenz-Quantoren der Reihe nach durch 
Skolemisierungs-Schritte eliminieren.  Nach dem eben gezeigten Satz ist die resultierende 
Formel zu der urspr\"{u}nglichen Formel erf\"{u}llbarkeits-\"{a}quivalent.  Dieses
Verfahren der Eliminierung von Existenz-Quantoren durch die Einf\"{u}hrung neuer
Funktions-Zeichen wird als {\emph{\color{blue}Skolemisierung}} bezeichnet.  Haben wir eine Formel $F$
in pr\"{a}nexe Normalform gebracht und anschlie\ss{}end skolemisiert, so hat das Ergebnis die Gestalt\\[0.2cm]
\hspace*{1.3cm} $\forall x_1, \cdots, x_n: g$ \\[0.2cm]
und in der Formel $g$ treten keine Quantoren mehr auf.  Die Formel $g$ wird auch als die
{\emph{\color{blue}Matrix}} der obigen Formel bezeichnet.  Wir k\"{o}nnen nun  $g$ mit Hilfe
der uns aus dem letzten Kapitel bekannten aussagenlogischen
 \"{A}quivalenzen in konjunktive Normalform bringen.  Wir haben dann eine
Formel der Gestalt \\[0.2cm]
\hspace*{1.3cm} $\forall x_1, \cdots, x_n: (k_1 \wedge \cdots \wedge k_m)$. \\[0.2cm]
Dabei sind die $k_i$ Disjunktionen von {\emph{\color{blue}Literalen}}.  In der Pr\"{a}dikatenlogik ist ein
{\emph{\color{blue}Literal}} entweder eine atomare Formel oder die Negation einer atomaren Formel.  Wenden wir
hier  die \"{A}quivalenz 
$(\forall x\colon f_1\wedge f_2) \leftrightarrow (\forall x\colon f_1) \wedge (\forall x\colon f_2)$
an, so k\"{o}nnen wir die All-Quantoren auf die einzelnen $k_i$ verteilen und
die resultierende Formel hat die Gestalt \\[0.2cm]
\hspace*{1.3cm} 
$\big(\forall x_1, \cdots, x_n: k_1\big) \wedge \cdots \wedge \big(\forall x_1, \cdots, x_n: k_m\big)$. \\[0.2cm]
Ist eine Formel $F$ in der obigen
Gestalt, so sagen wir, dass $F$ in {\emph{\color{blue}pr\"{a}dikatenlogischer Klausel-Normalform}} ist und eine
Formel der Gestalt \\[0.2cm]
\hspace*{1.3cm} $\forall x_1, \cdots, x_n: k$, \\[0.2cm]
bei der $k$ eine Disjunktion pr\"{a}dikatenlogischer Literale ist,
bezeichnen wir als {\emph{\color{blue}pr\"{a}dikatenlogische Klausel}}.  Ist $M$
eine Menge von Formeln deren Erf\"{u}llbarkeit wir untersuchen wollen, so k\"{o}nnen wir nach dem
bisher gezeigten $M$ immer in eine Menge pr\"{a}dikatenlogischer Klauseln umformen.
Da  dann nur noch All-Quantoren vorkommen, k\"{o}nnen wir hier die  Notation noch vereinfachen
indem wir vereinbaren, dass alle Formeln implizit allquantifiziert sind, wir lassen also
die All-Quantoren weg.

Wozu sind nun die Umformungen in Skolem-Normalform gut?  Es geht darum, dass wir 
ein Verfahren entwickeln wollen, mit dem es m\"{o}glich ist f\"{u}r eine pr\"{a}dikatenlogische Formel
$f$ zu zeigen, dass $f$ allgemeing\"{u}ltig ist, dass also \\[0.2cm]
\hspace*{1.3cm} $\models f$ \\[0.2cm]
gilt.  Wir wissen, dass \\[0.2cm]
\hspace*{1.3cm} $\models f$ \quad g.d.w. \quad $\{\neg f\} \models \falsum$ \\[0.2cm]
gilt, denn die Formel $f$ ist genau dann allgemeing\"{u}ltig, wenn es keine Struktur gibt, in
der die Formel $\neg f$ erf\"{u}llbar ist. 
 Wir bilden daher zun\"{a}chst $\neg f$ und formen $\neg f$ in pr\"{a}dikatenlogische
Klausel-Normalform um.  Wir erhalten Klauseln $k_1, \cdots, k_n$, so dass  \\[0.2cm]
\hspace*{1.3cm} $\neg f \approx_e k_1 \wedge \cdots \wedge k_n$ \\[0.2cm]
gilt.  Anschlie\ss{}end versuchen wir,
aus den Klauseln $k_1,\cdots,k_n$ eine Widerspruch herzuleiten: \\[0.2cm]
\hspace*{1.3cm} $\{k_1, \cdots, k_n\} \vdash \falsum$ \\[0.2cm]
Wenn dies gelingt wissen wir, dass die Menge $\{k_1, \cdots, k_n\}$ unerf\"{u}llbar ist.
Dann ist auch $\neg f$ unerf\"{u}llbar und damit ist $f$ allgemeing\"{u}ltig.
Damit wir aus den Klauseln $k_1,\cdots,k_n$ einen Widerspruch herleiten k\"{o}nnen,
brauchen wir nat\"{u}rlich noch einen Kalk\"{u}l, der mit pr\"{a}dikatenlogischen Klauseln arbeitet. 
Einen solchen Kalk\"{u}l werden wir am Ende dieses Kapitel vorstellen.

Um das Verfahren n\"{a}her zu erl\"{a}utern demonstrieren wir es an einem Beispiel. 
Wir wollen untersuchen, ob \\[0.2cm]
\hspace*{1.3cm} 
$\models \big(\exists x\colon \forall y\colon  p(x,y)\big) \rightarrow \big(\forall y\colon \exists x\colon p(x,y)\big)$ \\[0.2cm]
gilt.  Wir wissen, dass dies \"{a}quivalent dazu ist, dass  \\[0.2cm]
\hspace*{1.3cm} 
$\Big\{ \neg \Big(\big(\exists x\colon \forall y\colon  p(x,y)\big) \rightarrow  \big(\forall y\colon \exists x\colon p(x,y)\big)\Big)\Big\} \models \falsum$ \\[0.2cm]
gilt.  Wir bringen zun\"{a}chst die negierte Formel in pr\"{a}nexe Normalform. 
$$
\begin{array}{ll}
                  & \neg \Big(\big(\exists x\colon \forall y\colon  p(x,y)\big) \rightarrow \big(\forall y\colon \exists x\colon p(x,y)\big)\Big) \\
  \leftrightarrow & \neg \Big(\neg \big(\exists x\colon \forall y\colon  p(x,y)\big) \vee \big(\forall y\colon \exists x\colon p(x,y)\big)\Big) \\
  \leftrightarrow &                \big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge \neg \big(\forall y\colon \exists x\colon p(x,y)\big) \\
  \leftrightarrow &\big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge  \big(\exists y\colon  \neg \exists x\colon p(x,y)\big) \\
  \leftrightarrow &\big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge  \big(\exists y\colon  \forall x\colon \neg p(x,y)\big) \\
\end{array}
$$
Um an dieser Stelle weitermachen zu k\"{o}nnen, ist es n\"{o}tig, die Variablen in dem  zweiten
Glied der Konjunktion umzubenennen.  Wir ersetzen $x$ durch $u$ und $y$ durch $v$ und erhalten
$$
\begin{array}{ll}
                  &\big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge  \big(\exists y\colon  \forall x\colon \neg p(x,y)\big) \\
  \leftrightarrow &\big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge  \big(\exists v\colon  \forall u\colon \neg p(u,v)\big) \\
  \leftrightarrow &\exists v\colon  \Big( \big(\exists x\colon \forall y\colon  p(x,y)\big) \wedge  \big(\forall u\colon \neg p(u,v)\big) \Big)\\
  \leftrightarrow &\exists v\colon  \exists x\colon  \Big( \big(\forall y\colon  p(x,y)\big) \wedge \big(\forall u\colon \neg p(u,v)\big) \Big)\\
  \leftrightarrow &\exists v\colon  \exists x\colon \forall y\colon \Big( p(x,y) \wedge \big(\forall u\colon \neg p(u,v)\big) \Big)\\
  \leftrightarrow &\exists v\colon  \exists x\colon \forall y\colon \forall u\colon \Big( p(x,y) \wedge \neg p(u,v) \Big)\\
\end{array}
$$
An dieser Stelle m\"{u}ssen wir skolemisieren um die Existenz-Quantoren los zu werden. 
Wir f\"{u}hren dazu zwei neue Funktions-Zeichen $s_1$ und $s_2$ ein. 
Dabei gilt $\mathtt{arity}(s_1) = 0$ und $\mathtt{arity}(s_2) = 0$, denn vor den
Existenz-Quantoren stehen keine All-Quantoren.
$$
\begin{array}{ll}
           & \exists v\colon  \exists x\colon \forall y\colon \forall u\colon \Big( p(x,y) \wedge \neg p(u,v) \Big)\\
 \approx_e & \exists x\colon \forall y\colon \forall u\colon \Big( p(x,y) \wedge \neg p(u,s_1) \Big)\\
 \approx_e & \forall y\colon \forall u\colon \Big( p(s_2,y) \wedge \neg p(u,s_1) \Big)\\
\end{array}
$$
Da jetzt nur noch All-Quantoren auftreten, k\"{o}nnen wir diese auch noch weglassen,
da wir ja vereinbart haben, dass alle freien Variablen implizit allquantifiziert sind.
Damit k\"{o}nnen wir nun die pr\"{a}dikatenlogische Klausel-Normalform angeben, diese ist\\[0.2cm]
\hspace*{1.3cm}
$M := \Big\{ \big\{ p(s_2,y) \big\}, \big\{\neg p(u,s_1)\big\}\Big\}$. \\[0.2cm]
Wir zeigen, dass die Menge $M$ widerspr\"{u}chlich ist.
Dazu betrachten wir zun\"{a}chst die Klausel $\big\{ p(s_2,y) \big\}$ und setzen in
dieser Klausel f\"{u}r $y$ die Konstante $s_1$ ein.  Damit erhalten wir die Klausel \\[0.2cm]
\hspace*{1.3cm}  $\big\{ p(s_2,s_1) \big\}$. \hspace*{\fill}(1)\\[0.2cm]
Das Ersetzung von $y$ durch $s_1$ begr\"{u}nden wir damit, dass die obige Klausel ja implizit
allquantifiziert ist und wenn etwas f\"{u}r alle $y$ gilt, dann sicher auch f\"{u}r $y = s_1$.

Als n\"{a}chstes betrachten wir die Klausel $\big\{\neg p(u,s_1)\big\}$.
Hier setzen wir f\"{u}r die Variablen $u$ die Konstante $s_2$ ein und erhalten dann die
Klausel \\[0.2cm]
\hspace*{1.3cm} $\big\{\neg p(s_2,s_1)\big\}$ \hspace*{\fill} (2) \\[0.2cm]
Nun wenden wir auf die Klauseln (1) und (2) die Schnitt-Regel an und finden \\[0.2cm]
\hspace*{1.3cm} 
$\big\{ p(s_2,s_1) \big\}$, \quad$\big\{\neg p(s_2,s_1)\big\}$ \quad $\vdash \quad \{\}$.
\\[0.2cm]
Damit haben wir einen Widerspruch hergeleitet und gezeigt, dass die Menge $M$ unerf\"{u}llbar
ist. Damit ist dann auch \\[0.2cm]
\hspace*{1.3cm} 
$\Big\{ \neg \Big(\big(\exists x\colon \forall y\colon  p(x,y)\big) \rightarrow  \big(\forall y\colon \exists x\colon p(x,y)\big)\Big)\Big\}$
\\[0.2cm]
unerf\"{u}llbar und folglich gilt \\[0.2cm]
\hspace*{1.3cm} 
$\models \big(\exists x\colon \forall y\colon  p(x,y)\big) \rightarrow  \big(\forall y\colon \exists x\colon p(x,y)\big)$.

\section{Unifikation}
In dem  Beispiel im letzten Abschnitt haben wir die Terme $s_1$ und $s_2$ geraten, die wir f\"{u}r die Variablen
$y$ und $u$ in den Klauseln $\big\{ p(s_2,y) \big\}$ und  $\big\{\neg p(u,s_1)\big\}$
eingesetzt haben.  Wir haben diese Terme mit dem Ziel gew\"{a}hlt, sp\"{a}ter die Schnitt-Regel
anwenden zu k\"{o}nnen.  In diesem Abschnitt zeigen wir nun ein Verfahren, mit dessen Hilfe
wir die ben\"{o}tigten Terme ausrechnen k\"{o}nnen.
Dazu ben\"{o}tigen wir zun\"{a}chst den Begriff einer {\emph{\color{blue}Substitution}}.
\begin{Definition}[Substitution]
    Es sei eine Signatur \\[0.2cm]
    \hspace*{1.3cm} $\Sigma = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$ \\[0.2cm]
    gegeben.  Eine \colorbox{yellow}{$\Sigma$-Substitution} ist eine endliche Menge von Paaren der Form \\[0.2cm]
    \hspace*{1.3cm} $\sigma = \bigl\{ \langle x_1, t_1 \rangle, \cdots, \langle x_n, t_n \rangle \bigr\}$. \\[0.2cm]
    Dabei gilt:
    \begin{enumerate}
    \item $x_i \in \mathcal{V}$, die $x_i$ sind also Variablen.
    \item $t_i \in \mathcal{T}_\Sigma$, die $t_i$ sind also Terme.
    \item F\"{u}r $i\not=j$ ist $x_i \not= x_j$, die Variablen sind also paarweise verschieden.
    \end{enumerate}
    
    Ist $\sigma = \bigl\{ \langle x_1, t_1 \rangle, \cdots, \langle x_n, t_n \rangle \bigr\}$ eine
    $\Sigma$-Substitution, so schreiben wir  \\[0.2cm]
    \hspace*{1.3cm} $\sigma = \bigl[ x_1 \mapsto t_1, \cdots, x_n \mapsto t_n \bigr]$.  \\[0.2cm]
    Au\ss{}erdem definieren wir den \emph{Domain} einer Substitution als \\[0.2cm]
    \hspace*{1.3cm} $\textsl{dom}(\sigma) = \{ x_1, \cdots, x_n\}$.
    \\[0.2cm]
    Die Menge aller Substitutionen bezeichnen wir mit \textsl{Subst}.
    \eox
\end{Definition}

\noindent
Substitutionen werden f\"{u}r uns dadurch interessant, dass wir sie auf Terme {\emph{\color{blue}anwenden}}
k\"{o}nnen.  Ist $t$ ein Term und  
$\sigma$ eine Substitution, so ist $t\sigma$ der Term, der aus $t$ dadurch entsteht, dass jedes Vorkommen einer Variablen
$x_i$ durch den zugeh\"{o}rigen Term $t_i$ ersetzt wird.  Die formale Definition folgt. 
\begin{Definition}[Anwendung einer Substitution]
\hspace*{\fill} \\
Es sei $t$ ein Term und es sei $\sigma = \bigl[ x_1 \mapsto t_1, \cdots, x_n \mapsto t_n \bigr]$
eine Substitution. Wir definieren die \emph{Anwendung} von $\sigma$ auf $t$ (Schreibweise $t\sigma$) durch Induktion \"{u}ber
den Aufbau von $t$: 
\begin{enumerate}
\item Falls $t$ eine Variable ist, gibt es zwei F\"{a}lle:
  \begin{enumerate}
  \item $t = x_i$ f\"{u}r ein $i\in\{1,\cdots,n\}$.  Dann definieren wir \quad  $x_i\sigma := t_i$.
  \item $t = y$ mit $y\in\mathcal{V}$, aber $y \not\in \{x_1,\cdots,x_n\}$. Dann definieren wir \quad $y\sigma := y$.
  \end{enumerate}
\item Andernfalls muss $t$ die Form $t= f(s_1,\cdots,s_m)$ haben. Dann k\"{o}nnen wir $t\sigma$ durch \\[0.2cm]
      \hspace*{1.3cm} $f(s_1, \cdots, s_m)\sigma := f(s_1\sigma, \cdots, s_m\sigma)$. \\[0.2cm]
      definieren, denn nach Induktions-Voraussetzung sind die Ausdr\"{u}cke $s_i\sigma$ bereits definiert.      
      \eox
\end{enumerate}
\end{Definition}

Genau wie wir Substitutionen auf Terme anwenden k\"{o}nnen, k\"{o}nnen wir eine Substitution
auch auf pr\"{a}dikatenlogische Klauseln anwenden.  Dabei werden Pr\"{a}dikats-Zeichen und
Junktoren wie Funktions-Zeichen behandelt.
Wir ersparen uns eine formale Definition und geben statt dessen zun\"{a}chst einige Beispiele. 
Wir definieren eine Substitution $\sigma$ durch \\[0.2cm]
\hspace*{1.3cm} $\sigma := \big[ x_1 \mapsto c,\; x_2 \mapsto f(d) \big]$. \\[0.2cm]
In den folgenden drei Beispielen demonstrieren wir zun\"{a}chst, wie eine Substitution
auf einen Term angewendet werden kann.  Im vierten Beispiel wenden wir die Substitution
dann auf eine Formel an:
\begin{enumerate}
\item $x_3\sigma = x_3$,
\item $f(x_2)\sigma = f\bigl(f(d)\bigr)$,
\item $h(x_1,g(x_2))\sigma = h\bigl(c,g(f(d))\bigr)$.
\item $\bigl\{ p(x_2), q(d,h(x_3,x_1))\bigr\}\sigma = \bigl\{ p(f(d)),\; q(d,h(x_3,c))\bigr\}$.
\end{enumerate}


\noindent
Als n\"{a}chstes zeigen wir, wie  Substitutionen miteinander verkn\"{u}pft werden k\"{o}nnen.
\begin{Definition}[Komposition von Substitutionen] 
    Es seien\\[0.2cm]
    \hspace*{1.3cm}  $\sigma = \big[ x_1 \mapsto s_1, \cdots, x_m \mapsto s_m \big]$ \quad und \quad  $\tau = \big[ y_1 \mapsto t_1, \cdots, y_n \mapsto t_n \big]$ \\[0.2cm]
    zwei Substitutionen mit $\textsl{dom}(\sigma) \cap \textsl{dom}(\tau) = \{\}$. Dann definieren
    wir die {\emph{\color{blue}Komposition}} $\sigma\tau$ von $\sigma$ und $\tau$ als \\[0.2cm]
    \hspace*{1.3cm} $\sigma\tau := \big[ x_1 \mapsto s_1\tau, \cdots, x_m \mapsto s_m\tau,\; y_1 \mapsto t_1, \cdots, y_n \mapsto t_n \big]$
    \eox
\end{Definition}

\example
Wir f\"{u}hren das obige Beispiel fort und setzen \\[0.2cm]
\hspace*{1.3cm} $\sigma := \big[ x_1 \mapsto c,\; x_2 \mapsto f(x_3) \big]$
                \quad und \quad $\tau := \big[ x_3 \mapsto h(c,c),\; x_4 \mapsto d \big]$. \\[0.2cm]
Dann gilt: \\[0.2cm]
\hspace*{1.3cm} $ \sigma\tau = \big[ x_1 \mapsto c,\; x_2 \mapsto f(h(c,c)),\; x_3 \mapsto h(c,c),\;x_4 \mapsto d \big]$.
\hspace*{\fill} $\Box$
\vspace{0.3cm}

\noindent
Die Definition der Komposition von Substitutionen ist mit dem Ziel gew\"{a}hlt worden, dass
der folgende Satz gilt.
\begin{Satz} \label{satz:komposition}
    Ist $t$ ein Term und sind $\sigma$ und $\tau$ Substitutionen mit 
    $\textsl{dom}(\sigma) \cap \textsl{dom}(\tau) = \{\}$, so gilt \\[0.2cm]
    \hspace*{1.3cm} $(t \sigma)\tau = t (\sigma\tau)$.
    \hspace*{\fill} $\Box$
\end{Satz}
Der Satz kann durch Induktion \"{u}ber den Aufbau des Termes $t$ bewiesen werden.


\begin{Definition}[Syntaktische Gleichung]
Unter einer {\emph{\color{blue}syntaktischen Gleichung}} verstehen wir in diesem Abschnitt ein Konstrukt der Form
$s \doteq t$, wobei einer der beiden folgenden F\"{a}lle vorliegen muss:
\begin{enumerate}
\item $s$ und $t$ sind Terme  oder
\item $s$ und $t$ sind atomare Formeln.
\end{enumerate}
Weiter definieren wir ein {\emph{\color{blue}syntaktisches Gleichungs-System}} als eine Menge
von syntaktischen Gleichungen.
\eox
\end{Definition}

Was syntaktische Gleichungen angeht machen wir keinen Unterschied zwischen Funktions-Zeichen und
Pr\"{a}dikats-Zeichen.   Dieser Ansatz ist deswegen berechtigt, weil wir Pr\"{a}dikats-Zeichen
ja auch als spezielle Funktions-Zeichen auffassen k\"{o}nnen, n\"{a}mlich als 
Funktions-Zeichen, die einen Wahrheitswert aus der Menge   $\mathbb{B}$ berechnen.

\begin{Definition}[Unifikator]
Eine Substitution $\sigma$ {\emph{\color{blue}l\"{o}st}} eine syntaktische Gleichung $s \doteq t$ genau dann, wenn
$s\sigma = t\sigma$ ist, wenn also durch die Anwendung von $\sigma$ auf $s$ und $t$
tats\"{a}chlich identische Objekte entstehen.  Ist $E$ ein syntaktisches Gleichungs-System, so 
sagen wir, dass $\sigma$ ein {\emph{\color{blue}Unifikator}} von $E$ ist wenn $\sigma$ jede
syntaktische Gleichung in $E$ l\"{o}st. 
\eox
\end{Definition}
Ist $E = \{ s_1 \doteq t_1, \cdots, s_n \doteq t_n \}$ eine syntaktisches Gleichungs-System
und ist $\sigma$ eine Substitution, so definieren wir \\[0.2cm]
\hspace*{1.3cm}  $E\sigma := \{ s_1\sigma \doteq t_1\sigma, \cdots, s_n\sigma \doteq t_n\sigma \}$.
\vspace{0.3cm}

\example
Wir verdeutlichen die bisher eingef\"{u}hrten Begriffe anhand eines Beispiels.  
Wir betrachten die Gleichung \\[0.2cm]
\hspace*{1.3cm} $p(x_1, f(x_4)) \doteq p( x_2, x_3)$ \\[0.2cm]
und definieren die Substitution \\[0.2cm]
\hspace*{1.3cm} $\sigma := \big[ x_1 \mapsto x_2,\; x_3 \mapsto f(x_4) \big]$. \\[0.2cm]
Die Substitution $\sigma$ l\"{o}st die obige syntaktische Gleichung, denn es gilt \\[0.2cm]
\hspace*{1.3cm} $p(x_1, f(x_4))\sigma = p(x_2, f(x_4))$ \quad und \quad \\[0.2cm]
\hspace*{1.3cm} $p(x_2, x_3)\sigma \;\quad = p(x_2, f(x_4))$.  \eox


Als n\"{a}chstes entwickeln wir ein Verfahren, mit dessen Hilfe wir von einer vorgegebenen
Menge $E$ von syntaktischen Gleichungen entscheiden k\"{o}nnen, ob es einen Unifikator $\sigma$ f\"{u}r $E$
gibt.  Wir \"{u}berlegen uns zun\"{a}chst, in welchen F\"{a}llen wir eine syntaktischen Gleichung $s \doteq t$
garantiert nicht l\"{o}sen k\"{o}nnen.  Da gibt es zwei M\"{o}glichkeiten: Eine syntaktische Gleichung  \\[0.2cm]
\hspace*{1.3cm} $f(s_1,\cdots,s_m) \doteq g(t_1,\cdots, t_n)$ \\[0.2cm]
ist sicher dann nicht durch eine Substitution l\"{o}sbar, wenn $f$ und $g$ verschiedene
Funktions-Zeichen sind, denn f\"{u}r jede Substitution $\sigma$ gilt ja \\[0.2cm]
\hspace*{1.0cm} $f(s_1,\cdots,s_m)\sigma = f(s_1\sigma,\cdots,s_m\sigma)$ \quad und \quad
                $g(t_1,\cdots, t_n)\sigma = g(t_1\sigma,\cdots,t_n\sigma)$. \\[0.2cm]
Falls $f \not = g$ ist, haben die Terme  $f(s_1,\cdots,s_m)\sigma$ und $g(t_1,\cdots, t_n)\sigma$ verschieden
Funktions-Zeichen und k\"{o}nnen daher syntaktisch nicht identisch werden.

Die andere Form einer syntaktischen Gleichung, die garantiert unl\"{o}sbar ist, ist\\[0.2cm]
\hspace*{1.3cm} $x \doteq f(t_1,\cdots,t_n)$  \quad falls $x \in \textsl{Var}\big(f(t_1,\cdots,t_n)\big)$. \\[0.2cm]
Das diese syntaktische Gleichung unl\"{o}sbar ist liegt daran, dass die rechte Seite immer mindestens ein
Funktions-Zeichen mehr enth\"{a}lt als die linke.  

Mit diesen Vorbemerkungen k\"{o}nnen wir nun ein Verfahren angeben, mit dessen Hilfe es
m\"{o}glich ist, Mengen von syntaktischen Gleichungen zu l\"{o}sen, oder festzustellen, dass es
keine L\"{o}sung gibt.  Das Verfahren operiert auf Paaren der Form 
$\langle F, \tau \rangle$.  Dabei ist $F$ ein syntaktisches Gleichungs-System und
$\tau$ ist eine Substitution.  Wir starten das Verfahren mit dem Paar 
$\langle E, [] \rangle$. Hierbei ist $E$ das zu l\"{o}sende Gleichungs-System und $[]$ ist die leere Substitution.
Das Verfahren arbeitet indem die im Folgenden
dargestellten Reduktions-Regeln solange angewendet werden, bis entweder feststeht, dass
die Menge der Gleichungen keine L\"{o}sung hat, oder aber ein Paar der Form 
$\langle \{\}, \sigma \rangle$ erreicht wird.  In diesem Fall ist $\sigma$ ein
Unifikator der Menge $E$, mit der wir gestartet sind.  Es folgen die Reduktions-Regeln:
\begin{enumerate}
\item Falls $y\in\mathcal{V}$ eine Variable ist, die nicht in dem Term $t$ auftritt, so
      k\"{o}nnen wir die folgende Reduktion durchf\"{u}hren: 
      \[ \Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle \quad\leadsto\quad 
         \Big\langle E[y \mapsto t], \sigma\big[ y \mapsto t \big] \Big\rangle 
      \]
      Diese Reduktions-Regel ist folgenderma\ss{}en zu lesen: Enth\"{a}lt die zu untersuchende
      Menge von syntaktischen Gleichungen eine Gleichung der Form $y \doteq t$, wobei die
      Variable $y$ nicht in $t$ auftritt, dann k\"{o}nnen wir diese Gleichung aus der
      gegebenen Menge von Gleichungen entfernen.  Gleichzeitig wird die Substitution
      $\sigma$ in die Substitution $\sigma\big[ y \mapsto t \big]$ transformiert und auf die restlichen syntaktischen Gleichungen
      wird die Substitution $[y \mapsto t]$ angewendet.
\item Wenn die Variable $y$  in dem Term $t$ auftritt, falls also $y \in \textsl{var}(t)$
      ist und wenn au\ss{}erdem $t \not= y$ ist, dann hat das Gleichungs-System 
      $E \cup \big\{ y \doteq t \big\}$ keine L\"{o}sung, wir schreiben 
      \[ \Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle\;\leadsto\; \Omega. \]
\item Falls $y\in\mathcal{V}$ eine Variable ist und $t$ keine Variable ist, so haben wir folgende Reduktions-Regel:
      \[ \Big\langle E \cup \big\{ t \doteq y \big\}, \sigma \Big\rangle \quad\leadsto\quad 
         \Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle.
      \]   
      Diese Regel wird ben\"{o}tigt, um anschlie\ss{}end eine der ersten beiden Regeln anwenden zu
      k\"{o}nnen.
\item Triviale syntaktische Gleichungen von Variablen k\"{o}nnen wir einfach weglassen:
      \[ \Big\langle E \cup \big\{ x \doteq x \big\}, \sigma \Big\rangle \quad\leadsto\quad
         \Big\langle E, \sigma \Big\rangle.
      \]   
\item Ist $f$ ein $n$-stelliges Funktions-Zeichen, so gilt 
      \[ \Big\langle E \cup \big\{ f(s_1,\cdots,s_n) \doteq f(t_1,\cdots,t_n) \big\}, \sigma \Big\rangle 
         \;\leadsto\; 
         \Big\langle E \cup \big\{ s_1 \doteq t_1, \cdots, s_n \doteq t_n\}, \sigma \Big\rangle.
      \]   
      Eine syntaktische Gleichung der Form $f(s_1,\cdots,s_n) \doteq f(t_1,\cdots,t_n)$
      wird also ersetzt durch die $n$ syntaktische Gleichungen $s_1 \doteq t_1$, $\cdots$, $s_n \doteq t_n$      .

      Diese Regel ist im \"{u}brigen der Grund daf\"{u}r, dass wir mit Mengen von syntaktischen Gleichungen
      arbeiten m\"{u}ssen, denn auch wenn wir mit nur einer syntaktischen Gleichung starten, kann 
      durch die Anwendung dieser Regel die Zahl der syntaktischen Gleichungen erh\"{o}ht werden.

      Ein Spezialfall dieser Regel ist 
      \[ \Big\langle E \cup \big\{ c \doteq c \big\}, \sigma \Big\rangle \;\leadsto\; 
         \Big\langle E, \sigma \Big\rangle.
      \]
      Hier steht $c$ f\"{u}r eine Konstante, also ein 0-stelliges Funktions-Zeichen. 
      Triviale Gleichungen \"{u}ber Konstanten k\"{o}nnen also einfach weggelassen werden.
\item Das Gleichungs-System $E \cup \big\{ f(s_1,\cdots,s_m) \doteq g(t_1,\cdots,t_n) \big\}$
      hat keine L\"{o}sung, falls die Funk\-tions-Zeichen $f$ und $g$ verschieden sind, wir schreiben
      \[ \Big\langle E \cup \big\{ f(s_1,\cdots,s_m) \doteq g(t_1,\cdots,t_n) \big\},
      \sigma \Big\rangle \;\leadsto\; \Omega \qquad \mbox{falls $f \not= g$}. \]
\end{enumerate}
Haben wir ein nicht-leeres Gleichungs-System $E$ gegeben und starten mit dem Paar 
$\langle E, []\rangle$  , so l\"{a}sst sich immer eine der
obigen Regeln anwenden.  Diese geht solange bis einer der folgenden F\"{a}lle eintritt:
\begin{enumerate}
\item Die 2. oder 6. Regel ist anwendbar.  Dann ist das Ergebnis $\Omega$ und das Gleichungs-System 
      $E$ hat keine L\"{o}sung.
\item Das Paar $\langle E, [] \rangle$ wird reduziert zu einem Paar $\langle \{\}, \sigma\rangle$.
      Dann ist $\sigma$ ein Unifikator von $E$.  In diesem Falls schreiben wir $\sigma = \textsl{mgu}(E)$.
      Falls $E = \{ s \doteq t \}$ ist, schreiben wir auch $\sigma = \textsl{mgu}(s, t)$.  Die Abk\"{u}rzung
      \textsl{mgu} steht hier f\"{u}r \colorbox{yellow}{``\emph{most general unifier}''}.
\end{enumerate}

\example
Wir wenden das oben dargestellte Verfahren an, um die syntaktische Gleichung \\[0.2cm]
\hspace*{1.3cm}  $p(x_1, f(x_4)) \doteq p( x_2, x_3)$  \\[0.2cm]
zu l\"{o}sen.  Wir haben die folgenden Reduktions-Schritte:
$$
\begin{array}{ll}
          &  \big\langle \big\{ p(x_1, f(x_4)) \doteq p( x_2, x_3) \big\}, \big[ \big] \big\rangle \\[0.2cm]
 \leadsto &  \big\langle \big\{ x_1 \doteq x_2, f(x_4) \doteq x_3 \big\}, \big[ \big] \big\rangle \\[0.2cm]
 \leadsto &  \big\langle \big\{ f(x_4) \doteq x_3 \big\}, \big[ x_1 \mapsto x_2 \big] \big\rangle \\[0.2cm]
 \leadsto &  \big\langle \big\{ x_3 \doteq f(x_4) \big\}, \big[ x_1 \mapsto x_2 \big] \big\rangle \\[0.2cm]
 \leadsto &  \big\langle \big\{\big\}, \big[ x_1 \mapsto x_2,\; x_3 \mapsto f(x_4) \big] \big\rangle \\[0.2cm]
\end{array}
$$
In diesem Fall ist das Verfahren also erfolgreich und wir erhalten die Substitution \\[0.2cm]
\hspace*{1.3cm} $\big[ x_1 \mapsto x_2,\; x_3 \mapsto f(x_4) \big]$ \\[0.2cm]
als L\"{o}sung der oben gegebenen syntaktischen Gleichung.  \eox

\example
Wir geben ein weiteres Beispiel und betrachten das Gleichungs-System 
\[ E = \big\{ p(h(x_1,c)) \doteq p(x_2),\; q(x_2, d) \doteq q(h(d,c),x_4) \big\} \]
Wir haben folgende Reduktions-Schritte:
$$
\begin{array}{ll}
          & \big\langle \big\{ p(h(x_1,c)) \doteq p(x_2),\; q(x_2, d) \doteq q(h(d,c),x_4) \big\}, \big[ \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ p(h(x_1,c)) \doteq p(x_2),\; x_2 \doteq h(d,c), \; d \doteq x_4 \big\}, \big[ \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ p(h(x_1,c)) \doteq p(x_2),\; x_2 \doteq h(d,c), \; x_4 \doteq d \big\}, \big[ \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ p(h(x_1,c)) \doteq p(x_2),\; x_2 \doteq h(d,c) \big\}, \big[ x_4 \mapsto d \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ p(h(x_1,c)) \doteq p(h(d,c)) \big\}, \big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c) \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ h(x_1,c) \doteq h(d,c) \big\}, \big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c) \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ x_1 \doteq d,\; c \doteq c \big\}, \big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c) \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{ x_1 \doteq d,\big\}, \big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c) \big] \big\rangle \\[0.2cm]
 \leadsto & \big\langle \big\{\big\}, \big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c),\; x_1 \mapsto d \big] \big\rangle \\[0.2cm]
\end{array}
$$
Damit haben wir die Substitution  $\big[ x_4 \mapsto d,\; x_2 \mapsto h(d,c),\; x_1 \mapsto d \big]$ als L\"{o}sung 
des anfangs gegebenen syntaktischen Gleichungs-Systems gefunden.  
\eox




\section{Ein Kalk\"{u}l f\"{u}r die Pr\"{a}dikatenlogik ohne Gleichheit}
In diesem Abschnitt setzen wir voraus, dass unsere Signatur $\Sigma$ das Gleichheits-Zeichen nicht
verwendet, denn durch diese Einschr\"{a}nkung wird es wesentlich leichter, einen vollst\"{a}ngen Kalk\"{u}l f\"{u}r
die Pr\"{a}dikatenlogik einzuf\"{u}hren.  Zwar gibt es auch f\"{u}r den Fall, dass die Signatur $\Sigma$ das
Gleichheits-Zeichen enth\"{a}lt, einen vollst\"{a}ndigen Kalk\"{u}l.  Dieser ist allerdings deutlich
aufwendiger als der Kalk\"{u}l, den wir jetzt einf\"{u}hren,  denn der Kalk\"{u}l f\"{u}r die Pr\"{a}dikatenlogik ohne
das Gleichheits-Zeichen besteht nur aus zwei Schluss-Regeln, die wir jetzt definieren.
\begin{Definition}[Resolution] 
    Es gelte:
    \begin{enumerate}
    \item $k_1$ und $k_2$ sind pr\"{a}dikatenlogische Klauseln,
    \item $p(s_1,\cdots,s_n)$ und $p(t_1,\cdots,t_n)$ sind atomare Formeln,
    \item die syntaktische Gleichung $p(s_1,\cdots,s_n)  \doteq p(t_1,\cdots,t_n)$ ist l\"{o}sbar mit 
          \[ \mu = \textsl{mgu}\bigl(p(s_1,\cdots,s_n), p(t_1,\cdots,t_n)\bigr). \]
    \end{enumerate}
     Dann ist 
     \[ \schluss{k_1 \cup\{ p(s_1,\cdots,s_n)\} \quad\quad \{\neg p(t_1,\cdots,t_n)\} \cup k_2}{
                 k_1\mu \cup k_2\mu} 
     \]
     eine Anwendung der {\emph{\color{blue}Resolutions-Regel}}.
     \eox
\end{Definition}
Die Resolutions-Regel ist eine Kombination aus der {\emph{\color{blue}Substitutions-Regel}} und der 
Schnitt-Regel.  Die Substitutions-Regel hat die Form
\\[0.2cm]
\hspace*{1.3cm}
$\schluss{k}{k\sigma}$. 
\\[0.2cm]
Hierbei ist $k$ eine pr\"{a}dikatenlogische Klausel und $\sigma$ ist eine Substitution.
Unter Umst\"{a}nden kann es sein, dass wir bei der Anwendung der Resolutions-Regel 
die Variablen in einer der beiden Klauseln erst umbenennen
m\"{u}ssen bevor wir die Regel anwenden k\"{o}nnen.  Betrachten wir dazu ein Beispiel.
Die Klausel-Menge 
\[ M = \Bigl\{ \bigl\{ p(x) \bigr\}, \bigl\{ \neg p(f(x)) \bigr\} \Bigr\} \]
ist widerspr\"{u}chlich.  Wir k\"{o}nnen die Resolutions-Regel aber nicht unmittelbar anwenden,
denn die syntaktische Gleichung 
\[ p(x) \doteq p(f(x)) \]
ist unl\"{o}sbar.  Das liegt daran, dass \textbf{zuf\"{a}llig} in beiden Klauseln dieselbe Variable
verwendet wird.  Wenn wir die Variable $x$ in der zweiten Klausel jedoch zu $y$ umbenennen, erhalten
wir die Klausel-Menge 
\[ \Bigl\{ \bigl\{ p(x) \bigr\}, \bigl\{ \neg p(f(y)) \bigr\} \Bigr\}. \]
Hier k\"{o}nnen wir die Resolutions-Regel anwenden, denn die syntaktische Gleichung 
\[ p(x) \doteq p(f(y)) \]
hat die L\"{o}sung $[x \mapsto f(y)]$.  Dann erhalten wir 
\[ \bigl\{ p(x) \bigr\}, \quad \bigl\{ \neg p(f(y)) \bigr\} \quad \vdash \quad \{\}. \]
und haben damit die Inkonsistenz der Klausel-Menge $M$ nachgewiesen.

\noindent
Die Resolutions-Regel alleine ist nicht ausreichend, um aus einer Klausel-Menge $M$, die
inkonsistent ist, in 
jedem Fall die leere Klausel ableiten zu k\"{o}nnen: Wir brauchen noch eine zweite Regel.
Um das einzusehen, betrachten wir die Klausel-Menge 
\[ M = \Bigl\{ \bigl\{p(f(x),y), p(u,g(v))\bigr\}, 
               \bigl\{\neg p(f(x),y), \neg p(u,g(v))\bigr\} \Bigr\} 
\]
Wir werden gleich zeigen, dass die Menge $M$ widerspr\"{u}chlich ist.  Man kann nachweisen,
dass mit der Resolutions-Regel alleine ein solcher Nachweis nicht gelingt.
Ein einfacher, aber f\"{u}r die Vorlesung zu aufwendiger Nachweis dieser Behauptung kann
gef\"{u}hrt werden, indem wir ausgehend von der Menge $M$ alle m\"{o}glichen Resolutions-Schritte
durchf\"{u}hren.  Dabei w\"{u}rden wir dann sehen, dass die leere Klausel nie berechnet wird.
Wir stellen daher jetzt die
{\emph{\color{blue}Faktorisierungs-Regel}} vor, mir der wir sp\"{a}ter zeigen werden, dass $M$ widerspr\"{u}chlich
ist.

\begin{Definition}[Faktorisierung] Es gelte 
  \begin{enumerate}
  \item $k$ ist  eine pr\"{a}dikatenlogische Klausel,
  \item $p(s_1,\cdots,s_n)$ und $p(t_1,\cdots,t_n)$ sind atomare Formeln,
  \item die syntaktische Gleichung $p(s_1,\cdots,s_n)  \doteq p(t_1,\cdots,t_n)$ ist l\"{o}sbar, 
  \item $\mu = \textsl{mgu}\bigl(p(s_1,\cdots,s_n), p(t_1,\cdots,t_n)\bigr)$.
  \end{enumerate}
  Dann sind \\[0.3cm]
  \hspace*{0.8cm}
  $\schluss{k \cup \bigl\{p(s_1,\cdots,s_n),\, p(t_1,\cdots,t_n)\bigl\}}{k\mu \cup \bigl\{p(s_1,\cdots,s_n)\mu\bigr\} }$ 
  \quad und \quad
  $\schluss{k \cup \bigl\{ \neg p(s_1,\cdots,s_n),\, \neg p(t_1,\cdots,t_n)\bigl\}}{k\mu \cup \bigl\{\neg p(s_1,\cdots,s_n)\mu\bigr\} }$ 
  \\[0.3cm]
  Anwendungen der \emph{Faktorisierungs-Regel}.
  \eox
\end{Definition}

\noindent
Wir zeigen, wie sich mit Resolutions- und Faktorisierungs-Regel die Widerspr\"{u}chlichkeit
der Menge $M$ beweisen l\"{a}sst.
\begin{enumerate}
\item Zun\"{a}chst wenden wir die Faktorisierungs-Regel auf die erste Klausel an. 
      Dazu berechnen wir den Unifikator 
      \[ \mu = \textsl{mgu}\bigl(p(f(x),y), p(u,g(v))\bigr) = [y \mapsto g(v), u \mapsto f(x)]. \]
      Damit k\"{o}nnen wir die Faktorisierungs-Regel anwenden: 
      \[ \bigl\{p(f(x),y), p(u,g(v))\bigr\} \quad \vdash \quad \bigl\{p(f(x),g(v))\bigr\}. \]
\item Jetzt wenden wir die Faktorisierungs-Regel auf die zweite Klausel an.
      Dazu berechnen wir  den Unifikator 
      \[ \mu = \textsl{mgu}\bigl(\neg p(f(x),y), \neg p(u,g(v))\bigr) = [y \mapsto g(v), u \mapsto f(x)]. 
      \]
      Damit k\"{o}nnen wir die Faktorisierungs-Regel anwenden: 
      \[ \bigl\{ \neg p(f(x),y), \neg p(u,g(v))\bigr\} \quad \vdash \quad \bigl\{\neg p(f(x),g(v))\bigr\}.
      \]
\item Wir schlie\ss{}en den Beweis mit einer Anwendung der Resolutions-Regel ab.
      Der dabei verwendete Unifikator ist die leere Substitution, es gilt also $\mu = []$.      
      \[ \bigl\{p(f(x),g(v))\bigr\}, \quad \bigl\{\neg p(f(x),g(v))\bigr\} \quad \vdash \quad \{\}. \]
\end{enumerate}
Ist $M$ eine Menge von pr\"{a}dikatenlogischen Klauseln und ist $k$ eine pr\"{a}dikatenlogische
Klausel, die durch Anwendung der Resolutions-Regel und der Faktorisierungs-Regel aus $M$
hergeleitet werden kann, so schreiben wir \\[0.2cm]
\hspace*{1.3cm} $M \vdash k$.
\\[0.2cm]
Dies wird als \emph{$M$ leitet $k$ her} gelesen.

\begin{Definition}[Allabschluss]
  Ist $k$ eine pr\"{a}dikatenlogische Klausel und ist $\{x_1,\cdots,x_n\}$
  die Menge aller Variablen, die in $k$ auftreten, so definieren wir
  den {\emph{\color{blue}Allabschluss}}  $\forall(k)$  der Klausel k als \\[0.2cm]
  \hspace*{1.3cm} $\forall(k) := \forall x_1\colon \cdots \forall x_n \colon k$. \eox
\end{Definition}

\noindent
Die f\"{u}r uns wesentlichen Eigenschaften des Beweis-Begriffs $M \vdash k$ werden in den folgenden
beiden S\"{a}tzen zusammengefasst.
\begin{Satz}[Korrektheits-Satz] \hspace*{\fill} \\
    Ist $M = \{k_1,\cdots,k_n\}$ eine Menge von Klauseln und gilt $M \vdash k$, so folgt \\[0.2cm]
    \hspace*{1.3cm} $\models \forall(k_1) \wedge \cdots \wedge \forall(k_n) \rightarrow \forall(k)$. \\[0.2cm]
    Falls also eine Klausel $k$ aus einer Menge $M$ hergeleitet werden kann,
    so ist $k$ tats\"{a}chlich eine Folgerung aus $M$. \qed
\end{Satz}

\noindent
Die Umkehrung des obigen Korrektheits-Satzes gilt nur f\"{u}r die leere Klausel.
\begin{Satz}[Widerlegungs-Vollst\"{a}ndigkeit] \hspace*{\fill} \\
  Ist $M = \{k_1,\cdots,k_n\}$ eine Menge von Klauseln und gilt 
  $\models \forall(k_1) \wedge \cdots \wedge \forall(k_n) \rightarrow \falsum$, so folgt \\[0.2cm]
  \hspace*{1.3cm} $M \vdash \{\}$.
    \qed
\end{Satz}
\noindent
Damit haben wir nun ein Verfahren in der Hand, um f\"{u}r eine gegebene 
pr\"{a}dikatenlogischer Formel $f$ die Frage, ob $\models f$ gilt, untersuchen zu k\"{o}nnen.
\begin{enumerate}
\item Wir berechnen zun\"{a}chst die Skolem-Normalform von $\neg f$ und erhalten dabei so etwas wie \\[0.2cm]
      \hspace*{1.3cm} $\neg f \approx_e \forall x_1, \cdots, x_m \colon g$.
\item Anschlie\ss{}end bringen wir die Matrix $g$ in konjunktive Normalform: 
      \[ g \leftrightarrow k_1 \wedge \cdots \wedge k_n. \]
      Daher haben wir nun 
      \[ \neg f \approx_e k_1 \wedge \cdots \wedge k_n \] 
      und es gilt: 
      \[  
          \models f                           \quad \mbox{g.d.w.} \quad
          \{\neg f\} \models \falsum          \quad \mbox{g.d.w.} \quad 
          \{k_1,\cdots,k_n\} \models \falsum.
      \]
\item Nach dem Korrektheits-Satz und dem Satz \"{u}ber die Widerlegungs-Vollst\"{a}ndigkeit gilt
      \\[0.2cm]
      \hspace*{1.3cm} 
      $\{k_1,\cdots,k_n\} \models \falsum$ \quad g.d.w. \quad 
      $\{k_1,\cdots,k_n\} \vdash \falsum$. \\[0.2cm]
      Wir versuchen also, nun die Widerspr\"{u}chlichkeit der Menge $M = \{ k_1, \cdots, k_n \}$  zu zeigen, indem wir
      aus $M$ die leere Klausel ableiten.
      Wenn diese gelingt, haben wir damit die Allgemeing\"{u}ltigkeit der urspr\"{u}nglich
      gegebenen Formel $f$ gezeigt.
\end{enumerate}

\example
Zum Abschluss demonstrieren wir das skizzierte Verfahren an einem Beispiel.
Wir gehen von folgenden Axiomen aus:
\begin{enumerate}
\item Jeder Drache ist gl\"{u}cklich, wenn alle seine Kinder fliegen k\"{o}nnen.
\item Rote Drachen k\"{o}nnen fliegen.
\item Die Kinder eines roten Drachens sind immer rot.
\end{enumerate}
Wie werden zeigen, dass aus diesen Axiomen folgt, dass alle roten Drachen gl\"{u}cklich sind.
Als erstes formalisieren wir die Axiome und die Behauptung in der Pr\"{a}dikatenlogik.
Wir w\"{a}hlen die folgende Signatur \\[0.2cm]
\hspace*{1.3cm}  $\Sigma_\textsl{Drache} := \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \textsl{arity} \rangle$ \quad mit
\begin{enumerate}
\item $\mathcal{V} := \{x,y,z\}$.
\item $\mathcal{F} = \{\}$.
\item $\mathcal{P} := \{ \textsl{rot}, \textsl{fliegt}, \textsl{gl\"{u}cklich}, \textsl{kind} \}$.
\item $\textsl{arity} := \bigl\{ \pair(\textsl{rot},1), \pair(\textsl{fliegt},1),
  \pair(\textsl{gl\"{u}cklich},1), \pair(\textsl{kind},2)\bigr\}$
\end{enumerate}
Das Pr\"{a}dikat  $\textsl{kind}(x,y)$ soll genau dann wahr sein, wenn $x$ ein Kind von $y$ ist.
Formalisieren wir die Axiome und die Behauptung, so erhalten wir die folgenden
Formeln $f_1, \cdots, f_4$:
\begin{enumerate}
\item $f_1 := \forall x: \Bigl(\forall y: \big(\textsl{kind}(y,x) \rightarrow \textsl{fliegt}(y)\big) \rightarrow \textsl{gl\"{u}cklich}(x)\Bigr)$
\item $f_2 := \forall x: \bigl(\textsl{rot}(x) \rightarrow \textsl{fliegt}(x)\bigr)$
\item $f_3 := \forall x: \bigl(\textsl{rot}(x) \rightarrow \forall y:\bigl( \textsl{kind}(y,x) \rightarrow \textsl{rot}(y)\bigr)\bigr)$
\item $f_4 := \forall x: \bigl(\textsl{rot}(x) \rightarrow \textsl{gl\"{u}cklich}(x)\bigr)$
\end{enumerate}
Wir wollen zeigen, dass die Formel \\[0.2cm]
\hspace*{1.3cm} $f := f_1 \wedge f_2 \wedge f_3 \rightarrow f_4$ \\[0.2cm]
allgemeing\"{u}ltig ist.  Wir betrachten also die Formel $\neg f$ und stellen fest \\[0.2cm]
\hspace*{1.3cm} $\neg f \leftrightarrow f_1 \wedge f_2 \wedge f_3 \wedge \neg f_4$. \\[0.2cm]
Als n\"{a}chstes m\"{u}ssen wir diese Formel in eine Menge von Klauseln umformen.
Da es sich hier um eine Konjunktion mehrerer Formeln handelt, k\"{o}nnen wir 
die einzelnen Formeln 
 $f_1$, $f_2$, $f_3$ und  $\neg f_4$  getrennt in Klauseln umwandeln.
\begin{enumerate}
\item Die Formel $f_1$ kann wie folgt umgeformt werden:
 $$ 
  \begin{array}{lcl}
    f_1 & =           & \forall x:\Bigl(\forall y: \big(\textsl{kind}(y,x)
    \rightarrow \textsl{fliegt}(y)\big) \rightarrow \textsl{gl\"{u}cklich}(x) \Bigr) \\[0.2cm]
    &\leftrightarrow & \forall x: \Bigl(\neg \forall y: \big( \textsl{kind}(y,x) \rightarrow \textsl{fliegt}(y)\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\[0.2cm]
    &\leftrightarrow & \forall x: \Bigl(\neg \forall y: \big( \neg \textsl{kind}(y,x) \vee \textsl{fliegt}(y)\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\[0.2cm]
    &\leftrightarrow & \forall x: \Bigl(\exists y: \neg \big( \neg \textsl{kind}(y,x) \vee \textsl{fliegt}(y)\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\[0.2cm]
    &\leftrightarrow & \forall x: \Bigl( \exists y: \big(\textsl{kind}(y,x) \wedge \neg  \textsl{fliegt}(y)\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\[0.2cm]
    &\leftrightarrow & \forall x:  \exists y: \Bigl(\big( \textsl{kind}(y,x) \wedge \neg  \textsl{fliegt}(y)\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\[0.2cm]
    &\approx_e & \forall x: \Bigl(\big( \textsl{kind}(s(x),x) \wedge \neg  \textsl{fliegt}(s(x))\big) \vee \textsl{gl\"{u}cklich}(x) \Bigr)\\
  \end{array}
     $$
      Im letzten Schritt haben wir dabei die Skolem-Funktion $s$ mit 
      $\textsl{arity}(s) = 1$ eingef\"{u}hrt.  Anschaulich berechnet diese Funktion f\"{u}r jeden
      Drachen $x$, der nicht gl\"{u}cklich ist, ein Kind $s(x)$, das nicht fliegen kann.
      Wenn wir in der Matrix dieser Formel das ``$\vee$'' noch ausmultiplizieren, so
      erhalten wir die beiden Klauseln 
      \\[0.2cm]
      \hspace*{1.3cm} $k_1 := \bigl\{ \textsl{kind}(s(x),x), \textsl{gl\"{u}cklich}(x) \bigl\}$,   \\[0.2cm]
      \hspace*{1.3cm} $k_2 := \bigl\{ \neg \textsl{fliegt}(s(x)), \textsl{gl\"{u}cklich}(x) \bigl\}$. 
\item Analog finden wir f\"{u}r $f_2$:
 $$
        \begin{array}{lcl}
            f_2 & =  & \forall x: \bigl(\textsl{rot}(x) \rightarrow \textsl{fliegt}(x) \bigr) \\[0.2cm]
            & \leftrightarrow  & \forall x: \bigl(\neg \textsl{rot}(x) \vee \textsl{fliegt}(x) \bigr)
        \end{array}
      $$ 
      Damit ist $f_2$ zu folgender Klauseln \"{a}quivalent: \\[0.2cm]
      \hspace*{1.3cm} $k_3 := \bigl\{ \neg \textsl{rot}(x), \textsl{fliegt}(x) \bigl\}$.
\item F\"{u}r $f_3$ sehen wir:
 $$
        \begin{array}{lcl}
          f_3 & =          & \forall x: \Bigl(\textsl{rot}(x) \rightarrow 
                             \forall y: \bigl(\textsl{kind}(y,x) \rightarrow \textsl{rot}(y)\bigr) \Bigr) 
          \\[0.2cm]
          &\leftrightarrow & \forall x: \Bigl(\neg \textsl{rot}(x) \vee 
                             \forall y: \bigl(\neg \textsl{kind}(y,x) \vee \textsl{rot}(y)\bigr)\Bigr) 
          \\[0.2cm]
          &\leftrightarrow & \forall x: \forall y: \bigl(\neg \textsl{rot}(x) \vee \neg \textsl{kind}(y,x) \vee \textsl{rot}(y)\bigr)
        \end{array}
      $$
     Das liefert die folgende Klausel: \\[0.2cm]
     \hspace*{1.3cm} $ k_4 := \bigl\{ \neg \textsl{rot}(x), \neg \textsl{kind}(y,x), \textsl{rot}(y)\bigl\}$.
\item Umformung der Negation von $f_4$ liefert:
 $$
        \begin{array}{lcl}
\neg f_4 & =      & \neg \forall x: \bigl(\textsl{rot}(x) \rightarrow \textsl{gl\"{u}cklich}(x)\bigr) 
         \\[0.2cm]
         & \leftrightarrow & \neg \forall x: \bigl(\neg \textsl{rot}(x) \vee \textsl{gl\"{u}cklich}(x) \bigr)
         \\[0.2cm]
         & \leftrightarrow & \exists x: \neg \bigl(\neg \textsl{rot}(x) \vee \textsl{gl\"{u}cklich}(x) \bigr)
         \\[0.2cm]
         & \leftrightarrow & \exists x: \bigl(\textsl{rot}(x) \wedge \neg \textsl{gl\"{u}cklich}(x) \bigr)
         \\[0.2cm]
         & \approx_e & \textsl{rot}(d) \wedge \neg \textsl{gl\"{u}cklich}(d) \\
        \end{array}
      $$
      Die hier eingef\"{u}hrte Skolem-Konstante $d$ steht f\"{u}r einen ungl\"{u}cklichen roten Drachen.
      Das f\"{u}hrt zu den Klauseln \\[0.2cm]
      \hspace*{1.3cm} $k_5 = \bigl\{ \textsl{rot}(d) \bigl\}$, \\[0.2cm]
      \hspace*{1.3cm} $k_6 = \bigl\{ \neg \textsl{gl\"{u}cklich}(d) \bigl\}$.
\end{enumerate}
Wir m\"{u}ssen also untersuchen, ob die Menge $M$, die aus den folgenden Klauseln besteht,
widerspr\"{u}chlich ist: 
\begin{enumerate}
\item $k_1 = \bigl\{ \textsl{kind}(s(x),x),\; \textsl{gl\"{u}cklich}(x) \bigl\}$  
\item $k_2 = \bigl\{ \neg \textsl{fliegt}(s(x)),\; \textsl{gl\"{u}cklich}(x) \bigl\}$
\item $k_3 = \bigl\{ \neg \textsl{rot}(x),\; \textsl{fliegt}(x) \bigl\}$
\item $k_4 = \bigl\{ \neg \textsl{rot}(x),\; \neg \textsl{kind}(y,x),\; \textsl{rot}(y) \bigl\}$
\item $k_5 = \bigl\{ \textsl{rot}(d) \bigl\}$ 
\item $k_6 = \bigl\{ \neg \textsl{gl\"{u}cklich}(d) \bigl\}$
\end{enumerate}
Sei also $M := \bigl\{k_1,k_2,k_3,k_4,k_5,k_6\bigl\}$.
Wir  zeigen, dass $M \vdash \falsum$ gilt:
\begin{enumerate}
\item Es gilt 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{mgu}\bigl(\textsl{rot}(d), \textsl{rot}(x)\bigr) = [x \mapsto d]$.
      \\[0.2cm]
      Daher k\"{o}nnen wir die Resolutions-Regel auf die Klauseln $k_5$ und $k_4$ wie folgt anwenden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{\textsl{rot}(d)\bigl\}$, \ $\bigl\{\neg \textsl{rot}(x), \neg \textsl{kind}(y,x),
       \textsl{rot}(y)\bigl\}$ \ $\vdash$ \ $\bigl\{\neg \textsl{kind}(y,d), \textsl{rot}(y)\bigl\}$.
\item Wir wenden nun auf die resultierende Klausel und auf die Klausel $k_1$ die
      Resolutions-Regel an.  Dazu berechnen wir zun\"{a}chst
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{mgu}\bigl(\textsl{kind}(y,d), \textsl{kind}(s(x),x)\bigr) = 
       [y \mapsto s(d), x \mapsto d]$.
      \\[0.2cm]
      Dann haben wir
      \\[0.2cm]
      \hspace*{1.3cm}
       $\bigl\{\neg \textsl{kind}(y,d), \textsl{rot}(y)\bigl\}$, \ 
       $\bigl\{\textsl{kind}(s(x),x), \textsl{gl\"{u}cklich}(x)\bigl\}$ \ $\vdash$ \ 
       $\bigl\{\textsl{gl\"{u}cklich}(d), \textsl{rot}(s(d))\bigl\}$.
\item Jetzt wenden wir auf die eben abgeleitete Klausel und die Klausel $k_6$ die
      Resolutions-Regel an.  Wir haben:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{mgu}\bigl(\textsl{gl\"{u}cklich}(d), \textsl{gl\"{u}cklich}(d)\bigr) = []$
      \\[0.2cm]
      Also erhalten wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{\textsl{gl\"{u}cklich}(d), \textsl{rot}(s(d))\bigl\}$, \ $\bigl\{\neg \textsl{gl\"{u}cklich}(d)\bigl\}$ \ $\vdash$ \ $\bigl\{\textsl{rot}(s(d))\bigl\}$.
\item Auf die Klausel $\bigl\{\textsl{rot}(s(d))\bigl\}$ und die Klausel $k_3$ wenden wir
      die Resolutions-Regel an.  Zun\"{a}chst haben wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{mgu}\bigl(\textsl{rot}(s(d)), \neg \textsl{rot}(x)\bigr) = [x \mapsto s(d)]$
      \\[0.2cm]
      Also liefert die Anwendung der Resolutions-Regel:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{\textsl{rot}(s(d))\bigl\}$, \ $\bigl\{\neg \textsl{rot}(x), \textsl{fliegt}(x)\bigl\}$ \ $\vdash$ \ $\bigl\{\textsl{fliegt}(s(d))\bigl\}$
\item Um die so erhaltenen Klausel $\bigl\{\textsl{fliegt}(s(d))\bigl\}$ mit der Klausel
      $k_3$ resolvieren zu k\"{o}nnen, berechnen wir
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{mgu}\bigl(\textsl{fliegt}(s(d)), \textsl{fliegt}(s(x))\bigr) = [x \mapsto d]$
      \\[0.2cm]
      Dann liefert die Resolutions-Regel
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{\textsl{fliegt}(s(d))\bigl\}$, \ $\bigl\{\neg \textsl{fliegt}(s(x)), \textsl{gl\"{u}cklich}(x)\bigl\}$ \ $\vdash$ \ $\bigl\{\textsl{gl\"{u}cklich}(d)\bigl\}$.
\item Auf das Ergebnis $\bigl\{\textsl{gl\"{u}cklich}(d)\bigl\}$ und die Klausel $k_6$ k\"{o}nnen
      wir nun die Resolutions-Regel anwenden:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigl\{\textsl{gl\"{u}cklich}(d)\bigl\}$, \  $\bigl\{\neg \textsl{gl\"{u}cklich}(d)\bigl\}$ \ $\vdash$ \ $\bigl\{\bigl\}$.
\end{enumerate}
Da wir im letzten Schritt die leere Klausel erhalten haben,  ist insgesamt $M \vdash
\falsum$ 
nachgewiesen worden und damit haben wir gezeigt, dass alle kommunistischen Drachen gl\"{u}cklich sind. 
\eox

\exercise
Die von Bertrant Russell definierte \emph{Russell-Menge} $R$ ist
definiert als die Menge aller der Mengen, die sich nicht selbst enthalten.   Damit gilt also
\\[0.2cm]
\hspace*{1.3cm}
$\forall x: \bigl( x \el R \leftrightarrow \neg x \el x)$.
\\[0.2cm]
Zeigen Sie mit Hilfe des in diesem Abschnitt definierten Kalk\"{u}ls, dass diese Formel
widerspr\"{u}chlich ist. 
\vspace{0.3cm}

\exercise
Gegeben seien folgende Axiome:
\begin{enumerate}
\item Jeder Barbier rasiert alle Personen, die sich\\ nicht selbst rasieren.
\item Kein Barbier rasiert jemanden, der sich selbst rasiert.
\end{enumerate}
Zeigen Sie, dass aus diesen Axiomen logisch die folgende Aussage folgt: \\[0.3cm]
\hspace*{1.3cm} Alle Barbiere sind blond.

\section{\textsl{Prover9} und \textsl{Mace4}}
Der im letzten Abschnitt beschriebene Kalk\"{u}l l\"{a}sst sich automatisieren und bildet die Grundlage moderner
automatischer Beweiser.  Gleichzeitig l\"{a}sst sich auch die Suche nach Gegenbeispielen automatisieren.
Wir stellen in diesem Abschnitt zwei Systeme vor, die diesen Zwecken dienen.
\begin{enumerate}
\item \textsl{Prover9} dient dazu, automatisch pr\"{a}dikatenlogische Formeln zu beweisen.
\item \textsl{Mace4} untersucht, ob eine gegebene Menge pr\"{a}dikatenlogischer Formeln in einer endlichen
  Struktur erf\"{u}llbar ist.  Gegebenenfalls wird diese Struktur berechnet.
\end{enumerate}
Die beiden Programme \textsl{Prover9} und \textsl{Mace4} wurden von William McCune \cite{mccune:2010} 
entwickelt, stehen unter der \href{http://www.gnu.org/licenses/gpl.html}{GPL} (\emph{Gnu General
  Public Licence}) und k\"{o}nnen unter der Adresse 
\\[0.2cm]
\hspace*{1.3cm}
\href{http://www.cs.unm.edu/~mccune/prover9/download/}{\texttt{http://www.cs.unm.edu/\symbol{126}mccune/prover9/download/}}
\\[0.2cm]
im Quelltext heruntergeladen werden.  Wir diskutieren zun\"{a}chst \textsl{Prover9} und schauen uns anschlie\ss{}end
\textsl{Mace4} an.

\subsection{Der automatische Beweiser \textsl{Prover9}}
\textsl{Prover9} ist ein Programm, das als Eingabe zwei Mengen von Formeln bekommt.  Die erste Menge von
Formeln wird als Menge von \emph{Axiomen} interpretiert, die zweite Menge von Formeln sind die zu
beweisenden \emph{Theoreme}, die aus den Axiomen gefolgert werden sollen.  Wollen wir beispielsweise zeigen,
dass in der Gruppen-Theorie aus der Existenz eines  links-inversen Elements auch die Existenz eines
rechts-inversen Elements folgt und dass au\ss{}erdem das links-neutrale Element auch rechts-neutral ist,
so k\"{o}nnen wir zun\"{a}chst die Gruppen-Theorie wie folgt axiomatisieren:
\begin{enumerate}
\item $\forall x: e \cdot x = x$,
\item $\forall x: \exists y: y \cdot x = e$,
\item $\forall x: \forall y: \forall z: (x \cdot y) \cdot z = x \cdot (y \cdot z)$.
\end{enumerate}
Wir m\"{u}ssen nun zeigen, dass aus diesen Axiomen die beiden Formeln
\\[0.2cm]
\hspace*{1.3cm}
$\forall x: x \cdot e = x$ \quad und \quad $\forall x: \exists y: y \cdot x = e$ 
\\[0.2cm]
logisch folgen.  Wir k\"{o}nnen diese Formeln wie in Abbildung \ref{fig:group2.in} auf Seite
\pageref{fig:group2.in} gezeigt f\"{u}r \textsl{Prover9} darstellen.
Der Anfang der Axiome wird in dieser Datei durch ``\texttt{formulas(sos)}'' eingeleitet und durch
das Schl\"{u}sselwort ``\texttt{end\_of\_list}'' beendet.  Zu beachten ist, dass sowohl die Schl\"{u}sselw\"{o}rter als
auch die einzelnen Formel jeweils durch einen Punkt ``\texttt{.}'' beendet werden.  Die Axiome in den Zeilen
2, 3, und 4 dr\"{u}cken aus, dass 
\begin{enumerate}
\item \texttt{e} ein links-neutrales Element ist,
\item zu jedem Element $x$ ein links-inverses Element $y$ existiert und
\item das Assoziativ-Gesetz gilt.
\end{enumerate}
Aus diesen Axiomen folgt, dass das \texttt{e} auch ein rechts-neutrales Element ist und dass au\ss{}erdem zu
jedem Element $x$ ein rechts-neutrales Element $y$ existiert.  Diese beiden  Formeln sind die zu beweisenden 
\emph{Ziele} und werden in der Datei durch ``\texttt{formulas}(goal)'' markiert.
Tr\"{a}gt die in Abbildung \ref{fig:group2.in} gezeigte Datei den Namen ``\texttt{group2.in}'', so k\"{o}nnen wir das
Programm \textsl{Prover9} mit dem Befehl 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{prover9 -f group2.in}
\\[0.2cm]
starten und erhalten als Ergebnis die Information, dass die beiden in Zeile 8 und 9 gezeigten Formeln
tats\"{a}chlich aus den vorher angegebenen Axiomen folgen.  Ist eine Formel nicht beweisbar, so gibt es zwei M\"{o}glichkeiten:
In bestimmten F\"{a}llen kann \textsl{Prover9} tats\"{a}chlich erkennen, dass ein Beweis unm\"{o}glich ist.  In
diesem Fall bricht das Programm die Suche nach einem Beweis mit einer entsprechenden Meldung ab.
Wenn die Dinge ung\"{u}nstig liegen, ist es auf Grund der Unentscheidbarkeit der Pr\"{a}dikatenlogik nicht
m\"{o}glich zu erkennen, dass die Suche nach einem Beweis scheitern muss.  In einem solchen Fall
l\"{a}uft das Programm solange weiter, bis kein freier Speicher mehr zur Verf\"{u}gung steht und
bricht dann mit einer Fehlermeldung ab.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    formulas(sos).
    all x (e * x = x).                              % left neutral 
    all x exists y (y * x = e).                     % left inverse
    all x all y all z ((x * y) * z = x * (y * z)).  % associativity
    end_of_list.
    
    formulas(goals).
    all x (x * e = x).                              % right neutral 
    all x exists y (x * y = e).                     % right inverse
    end_of_list.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Textuelle Darstellung der Axiome der Gruppentheorie.}
\label{fig:group2.in}
\end{figure}


\textsl{Prover9} versucht, einen indirekten Beweis zu f\"{u}hren.  Zun\"{a}chst werden die Axiome in
pr\"{a}dikatenlogische Klauseln 
\"{u}berf\"{u}hrt. Dann wird jedes zu beweisenden Theorem negiert und die negierte Formel wird ebenfalls in 
Klauseln \"{u}berf\"{u}hrt.  Anschlie\ss{}end versucht \textsl{Prover9} aus der Menge aller Axiome zusammen mit den
Klauseln, die sich aus der Negation eines der zu beweisenden Theoreme ergeben, die leere
Klausel herzuleiten.  Gelingt dies, so ist bewiesen, dass das jeweilige  Theorem tats\"{a}chlich aus den Axiomen
folgt.   Abbildung \ref{fig:group-commutative.in} zeigt eine
Eingabe-Datei f\"{u}r \textsl{Prover9}, bei der versucht wird, das Kommutativ-Gesetz aus den Axiomen der
Gruppentheorie zu folgern.  Der Beweis-Versuch mit \textsl{Prover9} schl\"{a}gt allerdings fehl.  In diesem Fall
wird die Beweissuche nicht endlos fortgesetzt.  Dies liegt daran, dass es \textsl{Prover9} gelingt, in
endlicher Zeit alle aus den gegebenen Voraussetzungen folgenden Formeln abzuleiten.
Leider ist ein solcher Fall eher die Ausnahme als die Regel.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    formulas(sos).
    all x (e * x = x).                              % left neutral 
    all x exists y (y * x = e).                     % left inverse
    all x all y all z ((x * y) * z = x * (y * z)).  % associativity
    end_of_list.
    
    formulas(goals).
    all x all y (x * y = y * x).                    % * is commutative
    end_of_list.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Gilt das Kommutativ-Gesetz in allen Gruppen?}
\label{fig:group-commutative.in}
\end{figure}


\subsection{\textsl{Mace4} }
Dauert ein Beweisversuch  mit \textsl{Prover9} endlos, so ist zun\"{a}chst nicht klar, ob das zu beweisende
Theorem gilt.  Um sicher zu sein, 
dass eine Formel nicht aus einer gegebenen Menge von Axiomen folgt, reicht es aus, eine Struktur zu
konstruieren, in der alle Axiome erf\"{u}llt sind, in der das zu beweisende Theorem aber falsch ist.
Das Programm \textsl{Mace4} dient genau dazu, solche Strukturen zu finden.  Das funktioniert nat\"{u}rlich nur,
solange die Strukturen endlich sind.  Abbildung \ref{fig:group.in} zeigt eine Eingabe-Datei, mit deren Hilfe
wir die Frage, ob es endliche nicht-kommutative Gruppen gibt, unter Verwendung von \textsl{Mace4} beantworten
k\"{o}nnen.  In den Zeilen 2, 3 und 4 stehen die Axiome der Gruppen-Theorie.  Die Formel in Zeile 5 postuliert,
dass f\"{u}r die beiden Elemente $a$ und $b$ das Kommutativ-Gesetz nicht gilt, dass also $a \cdot b \not= b \cdot
a$ ist.  Ist der in 
Abbildung \ref{fig:group.in} gezeigte Text in einer Datei mit dem Namen ``\textsl{group.in}'' gespeichert, so
k\"{o}nnen wir \textsl{Mace4} durch das Kommando
\\[0.2cm]
\hspace*{1.3cm}
\textsl{mace4 -f group.in}
\\[0.2cm]
starten.  \textsl{Mace4} sucht f\"{u}r alle positiven nat\"{u}rlichen  Zahlen $n=1,2,3,\cdots$, ob es eine Struktur 
$\mathcal{S} = \langle \mathcal{U}, \mathcal{J} \rangle$ mit $\textsl{card}(U) = n$ gibt, in der die
angegebenen Formeln gelten.  Bei $n=6$ wird \textsl{Mace4} f\"{u}ndig und berechnet tats\"{a}chlich eine Gruppe mit 6
Elementen, in der das Kommutativ-Gesetz verletzt ist.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    formulas(theory).
    all x (e * x = x).                              % left neutral
    all x exists y (y * x = e).                     % left inverse
    all x all y all z ((x * y) * z = x * (y * z)).  % associativity
    a * b != b * a.                                 % a and b do not commute
    end_of_list.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Gibt es eine Gruppe, in der das Kommutativ-Gesetz nicht gilt?}
\label{fig:group.in}
\end{figure}


Abbildung \ref{fig:group.out} zeigt einen Teil der von \textsl{Mace4} produzierten Ausgabe.
Die Elemente der Gruppe sind die Zahlen $0, \cdots, 5$, die Konstante $a$ ist das Element $0$,
$b$ ist das Element $1$, $e$ ist das Element $2$.  Weiter sehen wir, dass das Inverse von $0$ wieder $0$ ist,
das Inverse von $1$ ist $1$ das Inverse von $2$ ist $2$, das Inverse von $3$ ist $4$, das Inverse von $4$ ist
$3$ und das Inverse von $5$ ist $5$.  Die Multiplikation wird durch die folgende Gruppen-Tafel realisiert:
\\[0.2cm]
\hspace*{1.3cm}
\hspace*{1.3cm}
\begin{tabular}[t]{|l||l|l|l|l|l|l|}
\hline
$\circ$ & 0 & 1 & 2 & 3 & 4 & 5 \\
\hline
\hline
      0 & 2 & 3 & 0 & 1 & 5 & 4 \\
\hline
      1 & 4 & 2 & 1 & 5 & 0 & 3 \\
\hline
      2 & 0 & 1 & 2 & 3 & 4 & 5 \\
\hline
      3 & 5 & 0 & 3 & 4 & 2 & 1 \\
\hline
      4 & 1 & 5 & 4 & 2 & 3 & 0 \\
\hline
      5 & 3 & 4 & 5 & 0 & 1 & 2 \\
\hline
\end{tabular}
\\[0.2cm]
Diese Gruppen-Tafel zeigt, dass
\\[0.2cm]
\hspace*{1.3cm}
$a \circ b = 0 \circ 1 = 3$, \quad aber \quad
$b \circ a = 1 \circ 0 = 4$
\\[0.2cm]
gilt, mithin ist das Kommutativ-Gesetz tats\"{a}chlich verletzt.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.5cm,
                  xrightmargin  = 0.5cm,
                ]
    ============================== DOMAIN SIZE 6 =========================
    
    === Mace4 starting on domain size 6. ===
    
    ============================== MODEL =================================
    
    interpretation( 6, [number=1, seconds=0], [
    
            function(a, [ 0 ]),
    
            function(b, [ 1 ]),
    
            function(e, [ 2 ]),
    
            function(f1(_), [ 0, 1, 2, 4, 3, 5 ]),
    
            function(*(_,_), [
    			   2, 3, 0, 1, 5, 4,
    			   4, 2, 1, 5, 0, 3,
    			   0, 1, 2, 3, 4, 5,
    			   5, 0, 3, 4, 2, 1,
    			   1, 5, 4, 2, 3, 0,
    			   3, 4, 5, 0, 1, 2 ])
    ]).
    
    ============================== end of model ==========================
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ausgabe von \textsl{Mace4}.}
\label{fig:group.out}
\end{figure}

\remark
Der Theorem-Beweiser \textsl{Prover9} ist ein Nachfolger des Theorem-Beweisers \textsl{Otter}.  Mit Hilfe von
\textsl{Otter} ist es McCune 1996 gelungen, die Robbin'sche Vermutung zu beweisen \cite{mccune:1997}.
Dieser Beweis war damals sogar der \emph{New York Times} eine Schlagzeile wert,
nachzulesen unter
\\[0.2cm]
\hspace*{1.3cm}
\href{http://www.nytimes.com/library/cyber/week/1210math.html}{\texttt{http://www.nytimes.com/library/cyber/week/1210math.html}}.
\\[0.2cm]
Dies zeigt, dass automatische Theorem-Beweiser durchaus n\"{u}tzliche Werkzeuge sein
k\"{o}nnen.  Nichtdestoweniger  ist die Pr\"{a}dikatenlogik unentscheidbar und bisher sind 
nur wenige offene mathematische  Probleme mit Hilfe von automatischen Beweisern gel\"{o}st
worden.  Das wird sich vermutlich auch in der n\"{a}heren Zukunft nicht 
\"{a}ndern.  \qed


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logic"
%%% End: 
