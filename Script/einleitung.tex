\chapter{Introduction}
In this short Chapter, I would like to motivate why it is that you have to learn logic when you study computer
science.  After that, I will give a short overview of the lecture.

\section{Motivation}
Modern software systems are among the most complex systems developed by mankind.  You can get a
sense of the complexity of these systems if you look at the amount of work that is necessary to
build and maintain complex software systems.  For example, in the telecommunication industry it is 
quite common that software projects require more than a thousand developers to collaborate to
develop a new system.  Obviously, the failure of a project of this size is very costly.
The page
\\[0.2cm]
\hspace*{1.3cm}
\href{http://spectrum.ieee.org/static/the-staggering-impact-of-it-systems-gone-wrong}{Staggering Impact of IT Systems Gone Wrong}
\\[0.2cm]
presents a number of examples showing big software projects that have failed and have subsequently caused huge
financial losses.  These examples show that the development of complex software systems requires a high level
of precision and diligence.  Hence, the development of software needs a solid scientific
foundation.  Both mathematical logic and set theory are important parts of this foundation.
Furthermore, both set theory and logic have immediate applications in computer science.
\begin{enumerate}
\item Logic can be used to specify the interfaces of complex systems.  
\item The correctness of digital circuits can be verified using automatic theorem provers.
\item Set theory and the theory of relations is the foundation of the theory of relational databases.
\end{enumerate}
It is easy to extend this enumeration.  However, besides their immediate applications, 
there is another reason you have to study both logic and set theory: Without the proper use of
\colorbox{yellow}{abstractions}, complex software systems cannot be managed.  After all, nobody is able to keep
millions of lines of program code in his head.  The only way to control a software system of this
size is to introduce the right abstractions and to develop the system in layers.  Hence, the ability
to work with abstract concepts is one of the main virtues of a modern computer scientist.  As logic
and set theory are already abstract concepts, engaging students with logic and set theory trains
their abilities to work with abstract concepts.

% Schlie\3lich gibt es f\"{u}r Sie noch einen sehr gewichtigen Grund, sich intensiv mit Logik und
% Mengenlehre zu besch\"{a}ftigen, den ich Ihnen nicht verschweigen m\"{o}chte:  Es handelt sich
% dabei um die Klausur am Ende des ersten Semesters!  

From my past teaching experience I know that many students think that a good programmer already is a
good computer scientist.  However, a good programmer need not be a scientist, while a 
\colorbox{yellow}{computer \colorbox{red}{scientist}}, by its very name, is a
\colorbox{red}{scientist}.  There is no denying that mathematics in general and 
logic in particular is an important part of science, so you should master it.  Furthermore, this
part of your education is much more permanent than the knowledge of a particular programming
language.  Nobody knows which programming language will be en vogue in 10 years from now.  In three
years, when you start your professional career, quite a lot of you will have to learn a new
programming language.  What will count then will be much more your ability to quickly grasp new
concepts rather than your skills in a particular programming language.

\section{Overview} 
The first lecture in theoretical computer science creates the foundation that is needed for future lectures.
As set theory is already covered in the lecture on linear algebra, this lecture deals mostly with logic.
Hence, this lecture is structured as follows.
\begin{enumerate}
\item We begin with the programming language \textsc{SetlX}.

      \href{http://randoom.org/Software/SetlX}{\textsc{SetlX}} (\underline{set} \underline{l}anguage
      e\underline{x}tended) is a programming language that is based on set theory.  This language
      makes the tools of set theory available to the programmer as it supports the data structure of
      sets and most of the operations that are used in set theory.  As \textsc{SetlX} is set based,
      it is very easy to implement set theoretical algorithms in \textsc{SetlX}.  We will see in the
      coming lectures that many algorithms from theoretical computer science have a very concise
      and clear implementation in \textsc{SetlX}.  Hence, the second chapter introduces \textsc{SetlX}.
\item Next, we investigate the limits of computability.

      For certain problems there is no algorithm that can solve the problem algorithmically. 
      For example, the question whether a given program will terminate for a given input is not
      decidable.  This is known as the \colorbox{yellow}{\emph{halting problem}}.  We will prove the undecidability of
      the halting problem in the third chapter. 
\item The fourth chapter discusses \emph{propositional logic}.

      In logic, we distinguish between  \emph{propositional logic},
      \emph{first order logic}, and \emph{higher order logic}.  Propositional logic is only
      concerned with the \emph{logical connectives}
      \\[0.2cm]
      \hspace*{1.3cm}
      ``$\neg$'', ``$\wedge$'', ``$\vee$'', ``$\rightarrow$'' und ``$\leftrightarrow$'',
      \\[0.2cm]
      while first-order logic also investigates the quantifiers
      \\[0.2cm]
      \hspace*{1.3cm}
      ``$\forall$'' and ``$\exists$'',
      \\[0.2cm]
      where these quantifiers range over the objects of the \emph{domain of discourse}.
      Finally, in \emph{higher order logic} the quantifiers also range over functions and predicates.

      As propositional logic is easier to grasp than first-order logic, we start our investigation
      of logic with propositional logic.  Furthermore, propositional logic has the advantage of
      being decidable:  We will present an algorithm that can check whether a propositional formula
      is universally valid.  In contrast to propositional logic, first-order logic is not decidable.

      Next, we discuss applications of propositional logic:  We will show how the \emph{8 queens problem} 
      can be reduced to propositional logic and we will then solve this problem using propositional logic.
\item We continue to discuss first-order logic.

      The most important concept of the fifth chapter will be the notion of a \emph{formal proof} in
      first order logic.  To this end, we introduce a \emph{formal proof system} that is
      \colorbox{red}{complete} for first order logic.  \emph{Completeness} means that we will develop an
      algorithm that can \emph{prove} the correctness of every first-order formula that is
      universally valid.  This algorithm is the foundation of automated theorem proving.

      As an application of theorem proving we discuss the systems \textsl{Prover9} and
      \textsl{Mace4}.  \textsl{Prover9} is an automated theorem prover, while \textsl{Mace4} can be
      used to refute a mathematical conjecture.

\item The last chapter deals with program verification.

      The correctness of programs can be verified mathematically.  We will discuss two methods in
      this lecture: \emph{Computational induction} can be used to verify the correctness of
      recursive procedures, while \emph{symbolic execution} can be used to verify the correctness of
      iterative procedures. (An iterative procedure uses loops instead of recursion.)
\end{enumerate}


\remark
Zum Schluss m\"{o}chte ich hier noch ein Paar Worte zum Gebrauch von neuer und alter
Rechtschreibung und der Verwendung von Spell-Checkern in diesem Skript sagen.
Dieses Skript wurde unter Verwendung strengster wirtschaftlicher Kriterien
erstellt.  Im Klartext hei\3t das: Zeit ist Geld und als Dozent an der DHBW hat man
weder das eine noch das andere.  Daher ist es sehr wichtig zu wissen, wo eine
zus\"{a}tzliche Investition von Zeit noch einen f\"{u}r die Studenten n\"{u}tzlichen Effekt
bringt und wo dies nicht der Fall ist.  Ich habe mich an aktuellen
Forschungs-Ergebnissen zum Nutzen der Rechtschreibung orientiert. Diese zeigen,
dass es nicht wichtig ist, in welcher Reihenfolge die Bcushatebn in eniem Wrot
setehn, das eniizge was wihtcig ist, ist dass der esrte und der ltzete Bcusthabe
an der rcihitgen Psoiiton sthet. Der Rset knan ein ttolaer B\"{o}ldisnn sien,
trtodzem knan man ihn onhe Porbelme lseen. Das ist so, wiel wir nciht jdeen
Buhctsaben eniezln lseen, snoedrn das Wrot als gseatmes.  Wie sie sheen, ist das
tastc\"{a}hilch der Flal. $\displaystyle\smiley$

Nichtsdestotrotz m\"{o}chte ich Sie darum bitten, mir Tipp- und sonstige Fehler, die Ihnen in diesem
Skript auffallen, per Email an
\\[0.2cm]
\hspace*{1.3cm}
\texttt{karl.stroetmann@dhbw-mannheim.de}
\\[0.2cm]
zu melden.  Es bringt nichts, wenn Sie mir diese Fehler nach der
Vorlesung mitteilen, denn bis ich dazu komme, die Fehler zu korrigieren, habe ich l\"{a}ngst vergessen,
was das Problem war.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logik"
%%% End: 
