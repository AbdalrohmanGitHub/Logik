\section{Probleme der deklarativen Semantik}
Der der \textsl{Prolog-System} zugrunde liegende Algorithmus sucht systematisch alle
Antworten auf eine Anfrage.  Dass heißt aber nicht,
dass er auch alle Antworten  findet!   Das folgende Programm zeigt das Problem:
\begin{verbatim}
    loop :- loop.
    loop.
\end{verbatim}
Wird dieses Programm geladen und wird anschließend versucht, das Ziel \texttt{loop} zu
lösen, so liefert der Prolog-Interpreter die Meldung
\begin{verbatim}
    ERROR: Out of local stack
\end{verbatim}

In manchen Fällen kann  das Problem der Nicht-Terminierung 
 durch eine Umordnung der Programm-Klauseln umgangen werden.
Hätten wir das obige Programm in  der Form
\begin{verbatim}
  loop.
  loop :- loop.
\end{verbatim}
eingegeben, so wäre das Problem der Endlos-Schleife nicht aufgetreten.  Leider gibt es bei
komplexeren Programmen oft keine Anordnung der Klauseln, die das Problem der
Endlos-Schleifen löst.  

Die handelsüblichen Prolog-Interpreter haben noch ein weiteres Problem: Die Unifikation,
das heißt der Algorithmus zum Lösen syntaktischer Gleichungen, ist (aus Effizienzgründen)
nicht korrekt implementiert.  Wir erinnern noch einmal an die Regeln zur Reduktion
syntaktischer Gleichungen.  Die erste dieser Regeln lautete:
\begin{enumerate}
\item Falls $y\in\mathcal{V}$ eine Variable ist, {\em die nicht in dem Term $t$ auftritt}, so
      können wir die folgende Reduktion durchführen: \\[0.1cm]
      \hspace*{2.1cm} $\Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle \quad\leadsto\quad \Big\langle E[y \mapsto t], \sigma\big[ y \mapsto t \big] \Big\rangle$.
\end{enumerate}
In den handelsüblichen Prolog-Interpretern ist statt dieser Regel die folgende Regel
implementiert:
\begin{enumerate}
\item[$1'$.] Falls $y\in\mathcal{V}$ eine Variable ist, so
      können wir die folgende Reduktion durchführen: \\[0.1cm]
      \hspace*{2.1cm} $\Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle \quad\leadsto\quad \Big\langle E[y \mapsto t], \sigma\big[ y \mapsto t \big] \Big\rangle$.
\end{enumerate}
Was hier fehlt ist der Test {\em die nicht in dem Term $t$ auftritt}.  Dieser Test
wird als \emph{Occur-Check} bezeichnet.  Mit der modifizierten Regel können wir eine
Reduktion der Form
\\[0.1cm]
\hspace*{1.3cm} $\langle \{ x \doteq f(x) \}, [] \rangle \;\leadsto\; \langle \emptyset, [ x \mapsto f(x) ] \rangle$ \\[0.1cm]
durchführen.  Dies liefert aber ein falsches Ergebnis, denn offensichtlich ist die Substitution 
$[x \mapsto f(x)]$ keine Lösung der syntaktischen Gleichung $x \doteq f(x)$.  
Ein  Programm $\mathcal{P}$, wo dieser Fall tatsächlich auftritt, ist durch die beiden folgenden Klausel gegeben: 
\begin{verbatim}
      bug :- equal(X, s(X)).
      equal(X,X).
\end{verbatim}
Betrachten wir das Ziel \texttt{bug}, so liefert Prolog hier die Antwort ``\texttt{yes}'', obwohl \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \not\models \mathtt{bug}$ \\[0.1cm]
gilt.
Bei Prolog bleibt es dem Programmierer überlassen sicherzustellen, dass dergleichen nicht 
passiert.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "informatik-script.tex"
%%% End: 
