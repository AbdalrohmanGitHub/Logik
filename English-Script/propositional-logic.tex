\chapter{Propositional Logic}
\emph{Propositional logic}, which is also known as \emph{propositional calculus},
is the restriction of logic that is concerned with {formul\ae} build up from the following 
\emph{sentential connectives}:  
\begin{enumerate}
\item ``\emph{and}'' (denoted as $\wedge$),
\item ``\emph{or}''  (denoted as $\vee$),
\item ``\emph{not}'' (denoted as $\neg$),
\item ``\emph{if $\cdots$ then}'' (denoted as $\rightarrow$), and
\item ``\emph{if and only if}'' (denoted as $\leftrightarrow$). 
\end{enumerate}
In order to build {formul\ae} using these sentential connectives, we start with a set of
so called propositional variables $\mathcal{P}$.  These propositional variables denote atomic propositions
that are either true or false.  Given a set of propositional variables $\mathcal{P}$, the set of
propositional {formul\ae} $\mathcal{F}$ is defined inductively as follows:
\begin{enumerate}
\item $\verum$ is a propositional formula.  This formula is interpreted as always being true.
\item $\falsum$ is a propositional formula.  This formula is interpreted as always being false.
\item Every propositional variable $p \in \mathcal{P}$ is a propositional formula.
\item If $f$ is a propositional formula, then
      \\[0.2cm]
      \hspace*{1.3cm}
      $\neg f$
      \\[0.2cm]
      is a propositional formula, too.
\item If $f$ and $g$ are propositional {formul\ae}, then 
      \begin{enumerate}
      \item $(f \wedge g)$,
      \item $(f \vee g)$,
      \item $(f \rightarrow g)$, and
      \item $(f \leftrightarrow g)$
      \end{enumerate}
      are propositional {formul\ae}.
\end{enumerate}
The set of propositional {formul\ae} will be denoted as $\mathcal{F}$.

\example 
Assume the set of propositional variables is given as $\mathcal{P} = \{ p, q, r \}$.  Then the
following strings are propositional {formul\ae}:
\begin{enumerate}
\item $p$,
\item $(p \wedge q)$,
\item $((\neg p \rightarrow q) \vee (q \rightarrow \neg p))$.  \qed
\end{enumerate}

\noindent
In order to simplify the notation, we omit parenthesis in the following cases:
\begin{enumerate}
\item The outermost parenthesis are always omitted.  Therefore, we write \\[0.2cm]
      \hspace*{1.3cm} $p \wedge q$ \quad instead of \quad $(p \wedge q)$.
\item The connectives ``$\vee$'' and ``$\wedge$'' are left associative, therefore we write
      \\[0.2cm]
      \hspace*{1.3cm} $p \wedge q \wedge r$ \quad instead of \quad $(p \wedge q) \wedge r$.
\item The connective ``$\rightarrow$'' is right-associative, therefore we write \\[0.2cm]
      \hspace*{1.3cm} $p \rightarrow q \rightarrow r$ \quad instead of 
      \quad $p \rightarrow (q \rightarrow r)$.
\item The connectives  ``$\vee$'' and ``$\wedge$'' have a higher precedence than ``$\rightarrow$'', 
      therefore we write
      \\[0.2cm]
      \hspace*{1.3cm} $p \wedge q \rightarrow r$ \quad instead of \quad $(p \wedge q) \rightarrow r$.
\item The connective ``$\rightarrow$'' has a higher precedence than ``$\leftrightarrow$'', 
      therefore we write \\[0.2cm]
      \hspace*{1.3cm} 
      $p \rightarrow q \leftrightarrow r$ \quad instead of \quad 
      $(p \rightarrow q) \leftrightarrow r$.
\end{enumerate}
\textbf{Remark:}  Not that the connectives ``$\wedge$'' and ``$\vee$'' have the \underline{same}
precedence.  Therefore, the string
\\[0.2cm]
\hspace*{1.3cm}
$p \wedge q \vee r$
\\[0.2cm]
cannot be regarded as a propositional formula.  You will find some books that use a different
convention.  In some books, the connective ''$\vee$'' has a higher precedence than ``$\wedge$'',
while others use the opposite convention so that ``$\wedge$'' has a higher precedence than
``$vee$''.  In order to avoid any confusion, both operators have the same precedence in these
lecture notes.


\section{Applications of Propositional Logic}
Before diving deeper into the subject, let us motivate our investigations by 
listing some industrial applications of propositional logic.   The following list is by no means 
complete, I have just listed those applications of propositional logic that I have seen in my own
professional career.

\begin{enumerate}
\item Analysis and design of digital circuits.

      Today, complex digital circuits can easily consist of millions of logical gates
      \footnote{
        For example, the Pentium$^\mathrm{TM}$ \texttt{IV} processor that is equipped with
        the \textsl{Northwood} kernel consists of about  55 million logical gates.}.  
      A logical gate is a unit that implements one of the logical connectives
      ``\emph{and}'', ``\emph{or}'', or ``\emph{not}''.
  
      The complexity of modern circuits is unmanageable without the use of computer aided design
      tools.  These tools implement algorithms that are applications of propositional logic.

      On such tool that is often used in the verification of circuits is a tool for
      \emph{circuit comparison}.  In circuit comparison, two digital
      circuits are represented as propositional {formul\ae}.  The goal of circuit comparison is to
      prove the equivalence of these {formul\ae}.
\item Airline crew scheduling.

      When creating the time tables for crew personal, an international airline company
      has to comply with a number of compulsory restrictions regarding the idle time of a 
      crew.  In order to be competitive, these idle times have to be minimized in a way that the
      compulsory restrictions are satisfied.  This is an optimization problem that can be expressed
      as a propositional {formul\ae}.
\item Railway signaling control.

      In a big train station, hundreds of switch points and signals have to be controlled in order
      to guarantee that trains do not collide.  This control can be described using propositional
      {formul\ae}.
\item There are a lot of puzzles that can be mapped to propositional {formul\ae}.
      As an example, we will discuss the so called ``\emph{eight queens problem}''.
      This problem asks to put eight queens on a chess board in a way that no queen can attack
      another queen.
\end{enumerate}


\section{Semantics of Propositional {Formul\ae}}
We have defined the structure of propositional {formul\ae} in the introduction of this chapter, but we
haven't yet defined the \emph{truth} of a formula.  In general, without further provisions, we can
not speak of the truth of a formula.   For example, depending on the truth of $p$ and $q$, the formula
\\[0.2cm]
\hspace*{1.3cm}
$p \vee q$
\\[0.2cm]
might be either true or false.  In order to formally define the truth value of a formula, we define
the set $\mathbb{B}$ of truth values:  \\[0.2cm] 
\hspace*{1.3cm} $\mathbb{B} := \{ \mathtt{true}, \mathtt{false} \}$. \\[0.2cm]
Using $\mathbb{B}$, we define the notion of a \emph{valuation}.

\begin{Definition}[Propositional Valuation]
A  \emph{propositional valuation} is a function 
\\[0.2cm]
\hspace*{1.3cm} 
$\mathcal{I}:\mathcal{P} \rightarrow \mathbb{B}$ \\[0.2cm]
assigning a truth value  $\mathcal{I}(p) \in \mathbb{B}$ to every propositional variable
 $p\in \mathcal{P}$.
 \qed
\end{Definition}
A propositional variable is sometimes called an  \emph{interpretation} of the propositional variables.

In order to evaluate a propositional formula we need an interpretation of the propositional connectives
``$\neg$'', ``$\wedge$'', ``$\vee$'', ``$\rightarrow$'', and
``$\leftrightarrow$''.   To this end we define the functions
$\circneg$, $\circwedge$, $\circvee$, $\circright$, and $\circleftright$
on the set $\mathbb{B}$.  These functions have the following signatures:
\begin{enumerate}
\item $\circneg: \mathbb{B} \rightarrow \mathbb{B}$
\item $\circwedge: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$
\item $\circvee: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$
\item $\circright: \mathbb{B} \times \mathbb{B} \rightarrow: \mathbb{B}$
\item $\circleftright: \mathbb{B} \times \mathbb{B} \rightarrow: \mathbb{B}$
\end{enumerate}
In set theory, we have seen that functions can be regarded as binary relations.
The function $\circneg$ swaps the truth values and can therefore be defined as follows:
\[ \circneg = \bigl\{ \pair(\texttt{true},\texttt{false}), \pair(\texttt{false},\texttt{true}) \bigr\}. \]
However, defining the interpretation of the other logic connectives this way is not very intuitive.
It is easier to define these interpretations via a table.  This table is shown below. 

\begin{table}[!ht]
  \centering
\framebox{
  \begin{tabular}{|l|l|l|l|l|l|l|}
\hline
   $p$            & $q$            & $\circneg\;(p)$ & $\circvee\;(p, q)$ & $\circwedge\;(p, q)$ & $\circright\;(p, q)$ & $\circleftright\;(p, q)$
   \\
\hline
\hline
   \texttt{true}  & \texttt{true}  & \texttt{false} & \texttt{true}  & \texttt{true}  & \texttt{true}     & \texttt{true}  \\
\hline
   \texttt{true}  & \texttt{false} & \texttt{false} & \texttt{true}  & \texttt{false} & \texttt{false}    & \texttt{false}  \\
\hline
   \texttt{false} & \texttt{true}  & \texttt{true}  & \texttt{true}  & \texttt{false} & \texttt{true}     & \texttt{false} \\
\hline
   \texttt{false} & \texttt{false} & \texttt{true}  & \texttt{false} & \texttt{false} & \texttt{true}     & \texttt{true}  \\
\hline
  \end{tabular}}
  \caption{Interpretation of the logical connectives.}
  \label{tab:aussagen-logik}
\end{table}
With the help of this table we are now able to define the truth value of a propositional formula
with respect to a propositional valuation $\mathcal{I}$.  Let us denote this value as 
$\widehat{\mathcal{I}}(f)$.  The definition of $\widehat{\mathcal{I}}(f)$ is given by induction on $f$.
\begin{enumerate}
\item $\widehat{\mathcal{I}}(\falsum) := \mathtt{false}$.
\item $\widehat{\mathcal{I}}(\verum) := \mathtt{true}$.
\item $\widehat{\mathcal{I}}(p) := \mathcal{I}(p)$ for all $p \in \mathcal{P}$.
\item $\widehat{\mathcal{I}}(\neg f) := \circneg\;\bigl(\widehat{\mathcal{I}}(f)\bigr)$ for all $f \in \mathcal{F}$.
\item $\widehat{\mathcal{I}}(f \wedge g) := \circwedge\;\bigl(\widehat{\mathcal{I}}(f), \widehat{\mathcal{I}}(g)\bigr)$ 
      for all $f, g \in \mathcal{F}$.
\item $\widehat{\mathcal{I}}(f \vee g) := \circvee\;\bigl(\widehat{\mathcal{I}}(f), \widehat{\mathcal{I}}(g)\bigr)$ 
      for all $f, g \in \mathcal{F}$.
\item $\widehat{\mathcal{I}}(f \rightarrow g) := \circright\;\bigl(\widehat{\mathcal{I}}(f), \widehat{\mathcal{I}}(g)\bigr)$ 
      for all $f, g \in \mathcal{F}$.
\item $\widehat{\mathcal{I}}(f \leftrightarrow g) := \circleftright\;\bigl(\widehat{\mathcal{I}}(f), \widehat{\mathcal{I}}(g)\bigr)$ 
      for all $f, g \in \mathcal{F}$.
\end{enumerate}
In order to avoid unnecessary clutter in our notation we will not distinguish between
$\widehat{\mathcal{I}}$ and $\mathcal{I}$, that is we will just write $\mathcal{I}(f)$ instead of
the more formal $\widehat{\mathcal{I}}(f)$.

\noindent
\textbf{Example}: Let us demonstrate how the truth value of the formula
$$  (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q $$
can be calculated for the propositional valuation $\mathcal{I}$ that is defined as
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{I} = \bigl\{ \pair(p, \mathtt{true}), \pair(q,\mathtt{false}) \bigr\}$.
\\[0.2cm]
We have: 
\[
  \begin{array}{lcl}
   \mathcal{I}\Bigl( (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q  \Bigr) 
   & = &  \circright\Bigl( \mathcal{I}\bigl( (p \rightarrow q) \bigr),\, \mathcal{I}\bigl((\neg p \rightarrow q) \rightarrow q\bigr) \Bigr) \\[0.2cm]
   & = & \circright\Bigl( \circright\bigl( \mathcal{I}(p), \mathcal{I}(q) \bigr),\, \mathcal{I}\bigl((\neg p \rightarrow q) \rightarrow q\bigr) \Bigr) \\[0.2cm]
   & = & \circright\Bigl( \circright\bigl( \mathtt{true}, \mathtt{false} \bigr),\, \mathcal{I}\bigl((\neg p \rightarrow q) \rightarrow q\bigr) \Bigr) \\[0.2cm]
   & = & \circright\Bigl( \mathtt{false}, \, \mathcal{I}\bigl((\neg p \rightarrow q) \rightarrow q\bigr) \Bigr) \\[0.2cm]
   & = & \mathtt{true} \\
 \end{array}
\]
Note that in the calculation above I did only evaluate those parts of the formula that needed to be
evaluated.  Nevertheless, the approach sketched above is to tedious.  The easiest way to evaluate
a propositional formula is using the table \ref{tab:aussagen-logik} on page
\pageref{tab:aussagen-logik}.  We show how the formula
$$  (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q $$
can be evaluated for arbitrary valuations $\mathcal{I}$ using this table.  In order to do this,
we construct a table that has a column for every sub-formula occurring in our formula.
Table \ref{tab:tautologie} on page \pageref{tab:tautologie} shows the resulting table.
\begin{table}[!ht]
  \centering
\framebox{
  \begin{tabular}{|l|l|l|l|l|l|l|}
\hline
   $p$ & $q$ & $\neg p$ & $p \rightarrow q$ & $\neg p \rightarrow q$ & $(\neg p \rightarrow q) \rightarrow q$ & $ (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q$
   \\
\hline
\hline
   \texttt{true}  & \texttt{true}  & \texttt{false} & \texttt{true}  & \texttt{true}  & \texttt{true}     & \texttt{true}  \\
\hline
   \texttt{true}  & \texttt{false} & \texttt{false} & \texttt{false}  & \texttt{true} & \texttt{false}    & \texttt{true}  \\
\hline
   \texttt{false} & \texttt{true}  & \texttt{true}  & \texttt{true}  & \texttt{true} & \texttt{true}     & \texttt{true} \\
\hline
   \texttt{false} & \texttt{false} & \texttt{true}  & \texttt{true} & \texttt{false} & \texttt{true}     & \texttt{true}  \\
\hline
  \end{tabular}}
  \caption{Evaluation of $(p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q$.}
  \label{tab:tautologie}
\end{table}

Looking at the last column of table \ref{tab:tautologie} we see that it always contains the value
\texttt{true}.  Therefore, we see that the evaluation of
$(p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q$
yields \texttt{true} for every propositional valuation $\mathcal{I}$.  
A propositional formula that evaluates as \texttt{true} for any evaluation is called a
\emph{tautology}. 

For complex {formul\ae} the evaluation has to be automated.  We will show how to do this later.

\subsection{Extensional Interpretation of Implication}
The interpretation of the propositional connective ``$\rightarrow$'' is purely  \emph{extensional}:
In order to compute the truth value of the formula
\\[0.2cm]
\hspace*{1.3cm}
$f \rightarrow g$ 
\\[0.2cm]
we only have to know the truth values  $\mathcal{I}(f)$ and  $\mathcal{I}(g)$
 of the sub-formula  $f$ and $g$, we do not need to know anything
about the structure of the formula $f$ and $g$.  This leads to an interpretation of the connective
``$\rightarrow$'' that is different from the colloquial use of the connective
``\emph{if $\cdots$ then}''.  The reason is, that in colloquial use, the connective
``\emph{if $\cdots$ then}'' often denotes \emph{causation}.
Using the mathematical definition of ``$\rightarrow$'', the statement
\\[0.2cm]
\hspace*{1.3cm}
$3 \cdot 3 = 8 \rightarrow \mathrm{``it\ is\ raining''}$
\\[0.2cm]
is true because the precondition ``$3 \cdot 3 = 8$ is obviously false.  In colloquial use, the sentence
\\[0.2cm]
\hspace*{1.3cm}
``If $3 \cdot 3 = 8$, then it is raining.''
\\[0.2cm]
is regarded as meaningless.  Therefore, you have to keep in mind that the connective
``$\rightarrow$'' is not exactly the same as ``\emph{if $\cdots$, then}''.  Rather, the connective
``$\rightarrow$'' has to be regarded as the extensional abstraction of the colloquial  
``\emph{if $\cdots$, then}''.


\subsection{Implementation in \textsc{Setl2}} 
In order to improve our understanding of the notions discussed so far we will develop
a \textsc{Setl} program that can be used to evaluate a propositional formula.
Every time we develop a program we have to decide how to represent the arguments and results.
Therefore, we have to decide how to represent a propositional formula in \textsc{Setl2}.
In \textsc{Setl}, compound data structures are best represented as lists.  Formally, we define
the representation of a propositional formula using the function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{rep}: \mathcal{F} \rightarrow \textsc{Setl}$.
\\[0.2cm]
The formal definition is by induction on $f$.
\begin{enumerate}
\item $\verum$ will be represented a the number 1:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{rep}(\verum) := 1$.
\item $\falsum$   will be represented a the number 0:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{rep}(\falsum) := 0$.
\item A propositional variable $p \in \mathcal{P}$ is represented as a string giving the name
      of a variable.  As the propositional variables are strings to begin with, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{rep}(p) := p$ \quad for all $p \in \mathcal{P}$.
\item If $f$ is a propositional formula, then  $\neg f$ is represented as a list of length 2.
      The first element of this list is the string ``\texttt{-}'', the second element
      is the representation of $f$: \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{rep}(\neg f) := \texttt{[ \symbol{34}-\symbol{34}, $\textsl{rep}(f)$ ]}$.
\item If  $f_1$ and $f_2$ are propositional {formul\ae}, then we represent $f_1 \vee f_2$ 
      as a list of three elements.  The second element of this list will be the string 
      ``\texttt{+}'', while the first element is the representation of $f$ and the last element is
      the representation of $g$: \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{rep}(f \vee g) :=\texttt{[ $\textsl{rep}(f)$, \symbol{34}+\symbol{34}, $\textsl{rep}(g)$ ]}$.
\item If  $f_1$ and $f_2$ are propositional {formul\ae} we represent  $f_1 \wedge f_2$ as
      a list of three elements where the second element is the string  ``\texttt{*}'': \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{rep}(f \wedge g) := \texttt{[ $\textsl{rep}(f)$, \symbol{34}*\symbol{34}, $\textsl{rep}(g)$ ]}$.
\item In order to represent  $f_1 \rightarrow f_2$ we define: \\[0.2cm]
      \hspace*{1.3cm} 
      $\textsl{rep}(f \rightarrow g) := \texttt{[ $\textsl{rep}(f)$, \symbol{34}->\symbol{34}, $\textsl{rep}(g)$ ]}$.
\item In order to represent $f_1 \leftrightarrow f_2$ we define: \\[0.2cm] 
      \hspace*{1.3cm} 
      $\textsl{rep}(f \leftrightarrow g) := 
      \texttt{[ $\textsl{rep}(f)$, \symbol{34}<->\symbol{34}, $\textsl{rep}(g)$ ]}$.
\end{enumerate}
The representation given above is by no means unique and we could have used any other 
representation. In order for a representation to be considered appropriate
it should be as intuitive as possible and, furthermore, should provide easy access to the components
of a formula.

Next, we discuss how a propositional valuation can be represented in \textsc{Setl2}.
Now a propositional valuation is a function  \\[0.2cm]
\hspace*{1.3cm} ${\cal I}: {\cal P} \rightarrow \mathbb{B}$ \\[0.2cm]
mapping the set of propositional variables  ${\cal P}$ to the set of truth values $\mathbb{B}$.  
Therefore, we will represent a propositional interpretation ${\cal I}$ as a binary
relation that is left-total and right-unique:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{rep}(\mathcal{I}) := \bigl\{ \langle p, \mathcal{I}(p)\rangle: p \in \mathcal{P} \bigl\}$.
\\[0.2cm]
Using this representation we can implement a simple procedure that evaluates
a given propositional formula $f$ using a given propositional valuation ${\cal I}$.  The
procedure is shown in  figure \ref{fig:eval} on page \pageref{fig:eval}.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm
                ]
    procedure eval(f, I);
        case
            when f  = 1       =>  return TRUE;
            when f  = 0       =>  return FALSE;
            when is_string(f) =>  return I(f);
            when f(1) = "-"   =>  return not eval(f(2), I);
            when f(2) = "*"   =>  return eval(f(1), I) and  eval(f(3), I);
            when f(2) = "+"   =>  return eval(f(1), I) or   eval(f(3), I);
            when f(2) = "->"  =>  return not eval(f(1), I) or eval(f(3), I);
            when f(2) = "<->" =>  return eval(f(1), I) = eval(f(3), I);
            otherwise => print("eval: syntax error: ", f);
        end case;
    end eval;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Evaluating a propositional formula.}
  \label{fig:eval}
\end{figure} 

\noindent
Let us discuss the details of this implementation:
\begin{enumerate}
\item If the argument  $f$ is 1, then  $f$ represents  the formula $\verum$.
      Therefore, the evaluation of $f$ is always  \texttt{true}. 
\item If the argument  $f$ is 0, then  $f$ represents  the formula $\falsum$.
      Therefore, the evaluation of $f$ is always  \texttt{false}. 
\item Line 5 deals with the case that the argument  $f$ represents a propositional
      variable.   This is the case if $f$ is a string.  This can be checked with the help
      of the library function \texttt{is\_string()}.  In this case, we can apply the
      propositional valuation  $\mathcal{I}$ on the variable $f$.  This works, because
      $\mathcal{I}$ is represented as a binary relation and in \textsl{Setl} a binary
      relation can be used as a function.
\item Line 6 deals with the case that $f$ has the form
      \texttt{[ \symbol{34}-\symbol{34}, $g$ ]} and therefore represents the formula $\neg g$.
      in this case, we first evaluate $g$ using $\mathcal{I}$ and then negate the result.
\item Line 7 deals with the case that  $f$ has the form
      \texttt{[ $g_1$, \symbol{34}*\symbol{34}, $g_2$ ]} and therefore represents
      the formula $g_1 \wedge g_2$.  In this case,
      we first evaluate  $g_1$ and $g_2$ recursively.  Next, the results are combined
      with the \texttt{and}-operator provided by \textsc{Setl}.
\item Line 8 deals with the case that $f$ has the form
      \texttt{[ $g_1$, \symbol{34}+\symbol{34}, $g_2$ ]} and represents the formula
      $g_1 \vee g_2$.  This case is reduced to an application of the \texttt{or}-operator
      of \textsc{Setl}.
\item Line 9 deals with the case that  $f$ has the form
      \texttt{[ $g_1$, \symbol{34}->\symbol{34}, $g_2$ ]} and represents the formula
      $g_1 \rightarrow g_2$.   In this case we make use of the following equivalence: \\[0.2cm]
      \hspace*{1.3cm} 
      $(p \rightarrow q) \;\leftrightarrow\; \neg p \vee q$.
\item In order to understand line 10 we note that the logical connective ``$\leftrightarrow$''
      denotes the equality of truth values.  Therefore, the evaluation of 
      $g_1 \leftrightarrow g_2$  can be reduced to a comparison of the truth values of
      $g_1$ and $g_2$.
\item Finally, if we reach line 11 there must be a syntax error.
\end{enumerate}


\subsection{An Application}
We take a look at a hands-on application of the theory discussed so far.
 Inspector Watson is called to a jewelry that has been robbed.  Three suspects,
Austin, Brian, and Colin have been arrested.
After all facts are evaluated, the following is known:
\begin{enumerate}
\item At least one of the three suspects is guilty:
      \\[0.2cm]
      \hspace*{1.3cm} 
      $f_1 := a \vee b \vee c$.
\item If  Austin is guilty, then he has exactly one accomplice.

      In order to represent this fact, we break this statement up into two statements:
      \begin{enumerate}
      \item If Austin has done it, then he has at least one accomplice: \\[0.2cm]
            \hspace*{1.3cm} $f_2 := a \rightarrow b \vee c$ 
      \item If Austin has done it, then he has at most one accomplice: \\[0.2cm]
           \hspace*{1.3cm} $f_3 := a \rightarrow \neg (b \wedge c)$
      \end{enumerate}
\item If  Brian is not guilty, then Colin is not guilty either: \\[0.2cm]
      \hspace*{1.3cm} $f_4 :=  \neg b \rightarrow \neg c$ 
\item If exactly two of the suspects are guilty, then Colin is one of them.

      It is not easy to see how this statement can be translated into a propositional
      formula.  Let us therefore consider the negation of this formula.
      Now the statement above is wrong if  Colin is not guilty  and at the same time 
       Austin and Brian are guilty.  Therefore, the statement above can be formalized as
       follows: 
       \\[0.2cm]
      \hspace*{1.3cm} $f_5 := \neg ( \neg c  \wedge a \wedge b )$ 
\item If  Colin is not guilty, then  Austin is guilty. \\[0.2cm]
      \hspace*{1.3cm} $f_6 := \neg c \rightarrow a$
\end{enumerate}
We now have a set $F = \{ f_1, f_2, f_3, f_4, f_5, f_6 \}$ of {formul\ae}.
We are looking for a propositional valuation $\mathcal{I}$ such that all furthermore from
$f$ are true when evaluated with $\mathcal{I}$.  If there is exactly one such
propositional valuation, then this valuation uniquely determines the culprits.
For example, if we had
 \\[0.2cm]
\hspace*{1.3cm} 
$\mathcal{I} = \bigl\{ \pair(a,\mathtt{false}), \pair(b,\mathtt{false}), \pair(c,\mathtt{true}) \bigr\}$,
\\[0.2cm]
then Colin would be the sole culprit.  This propositional valuation doesn't solve the
problem because it violates the third fact:  As Brian would be
innocent, Colin would have to be innocent too.
As it would be too time consuming to try all possible evaluations manually we will
implement a short program that does the necessary computations.
Figure \ref{fig:watson} shows this program.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    program main;
        -- \( f1 := a\;\vee\;b\;\vee\;c \)
        f1 := [ [ "a", "+", "b" ], "+", "c" ];
        -- \( f2 := a\;\rightarrow\;b\;\vee\;c \)
        f2 := [ "a", "->", [ "b", "+", "c" ] ];          
        -- \( f3 := a\;\rightarrow\;\neg\,(b\;\wedge\;c) \)
        f3 := [ "a", "->", [ "-", [ "b", "*", "c" ] ] ]; 
        -- \( f4 := \neg\,b\;\rightarrow\;\neg\,c \)
        f4 := [ [ "-", "b" ], "->", [ "-", "c" ] ]; 
        -- \( f5 := \neg\,(\neg\,c\;\wedge\;a\;\wedge\;b) \)
        f5 := [ "-", [ [ "a", "*", "b" ], "*", [ "-", "c" ] ] ]; 
        -- \( f6 := \neg\,c\;\rightarrow\;a \)
        f6 := [ [ "-", "c" ], "->", "a"  ];
    
        FS := \{ f1, f2, f3, f4, f5, f6 \};
    
        A  := \{ "a", "b", "c" \};
        P  := pow A;
        print("P = ", P);
        -- B is the set of all propositional valuations.
        B  := \{ createValuation(M, A) : M in P \};
        S  := \{ I in B | forall f in FS | eval(f, I) \};
        print("Set of all valuations satisfying all facts:", S);
        if #S = 1 then
            I := arb S;
            Culprits := \{ x in A | I(x) \};
            print("Set of culprits: ", Culprits);
        end if;
    
        -- This procedure turns a subset M of A into a propositional 
        -- valuation I, such that I(x) is true iff x is an element of M.
        procedure createValuation(M, A);
            return \{ [ x, x in M ] : x in A \};
        end createValuation;
    
        procedure eval(f, I);
            \(\vdots\)
        end eval;
    end main;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Who has done it?}
  \label{fig:watson}
\end{figure}

\noindent
Let us discuss the details of this program.
\begin{enumerate}
\item Lines  2 -- 13 define the {formul\ae}  $f_1$, $\cdots$, $f_6$.
      We have to put these formula into their  \textsc{Setl2} representation.
\item Next, we have to decide how we can enumerate all possible propositional valuations.
      We have already noticed that the propositional valuations correspond to the possible
      sets of culprits.  However, these sets are subsets of the set
      \\[0.2cm]
      \hspace*{1.3cm} $\{ \mathtt{a}, \mathtt{b}, \mathtt{c} \}$. \\[0.2cm]
      Therefore, in line 18 we compute the set of all these subsets.
\item Now we need a way to transform a subset of propositional variables into a
      propositional valuation. In lines 32 -- 34 we have implemented a procedure
      that takes a subset and converts it into a valuation.
      In order to understand how this procedure works we examine an example and assume
      that the subset to be converted is given as \\[0.2cm]
      \hspace*{1.3cm} $M = \{\mathtt{a}, \mathtt{c} \}$. \\[0.2cm]
      The result is \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathcal{I} = \{ \pair(a,\mathtt{true}), \pair(b,\mathtt{false}),\pair(c,\mathtt{true}) \bigr\}$. 
      \\[0.2cm]
      The idea is, that for a propositional variable
      $x$ the pair $\pair(x,\mathtt{true})$ is a member of the valuation $\mathcal{I}$
      if $x \el M$, otherwise we have $\pair(x,\mathtt{false})$ in $\mathcal{I}$.  
      Therefore, the valuation that yields true for an element $x$ iff $x$ is a member of $M$ 
      is given as follows:
      \\[0.2cm]
      \hspace*{1.3cm}      
      \texttt{\{ [ x, true ] : x in M \} + \{ [ x, false ] : x in A | not x in M \}}
      \\[0.2cm]
      We can unify these two cases by requiring that the pair $\pair(x, x \el M)$ is an
      element of the valuation $\mathcal{I}$.  This is what line 33 is about.

      Observe that we had to supply the set $A$ of all propositional variables as a second
      argument, for otherwise this variable would have been unknown in the procedure.
\item Line 21 collects the set $B$ of all possible valuations.
\item Line 22 collects the set $S$ those valuations that evaluate every formula from $F$ as true.
\item If there is exactly one valuation that evaluates every formula from $f$ as true,
      then our problem is solved.  In this case, we select an arbitrary valuation 
      (well, its not really arbitrary as there is only one) and transform this valuation
      into a set.
\end{enumerate}
When we run the program, we get the following result:
\begin{verbatim}
    Set of culprits: {"b", "c"}
\end{verbatim}
Therefore Brian and Colin are guilty.
\pagebreak

\hspace*{\fill}
\pagebreak

\section{Tautologies}
Table  \ref{tab:tautologie} shows that the formula
$$  (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q $$
is true for every propositional valuation.  This example motivates the following definition.

\begin{Definition}
If $f$ is a propositional formula and we have  \\[0.2cm]
\hspace*{1.3cm} 
$\mathcal{I}(f) = \mathtt{true}$ \quad for every propositional valuation $\mathcal{I}$, 
\\[0.2cm]
then $f$ is called a \emph{tautology}.  In this case we write \\[0.2cm]
\hspace*{1.3cm} $\models f$.
\qed
\end{Definition}


\noindent
\textbf{Examples}:
\begin{enumerate}
\item $\models p \vee \neg p$
\item $\models p \rightarrow p$
\item $\models p \wedge q \rightarrow p$
\item $\models p \rightarrow p \vee q$
\item $\models (p \rightarrow \falsum) \;\leftrightarrow\; \neg p$
\item $\models p \wedge q \;\leftrightarrow\; q \wedge p$
\end{enumerate}
The fact, that these {formul\ae} are tautologies can be proved by building tables in the same
way as done in table \ref{tab:tautologie} on page \pageref{tab:tautologie}.  Although this
approach is conceptually straightforward, it is inefficient if the number of propositional
variables is big.  The reason is that the table necessary to establish a formula $f$ containing $n$
variables as a tautology has $2^n$ rows.  One aim of this chapter is to develop an
algorithm that does much better in many cases.

The last two examples give rise to the following definition.
\begin{Definition}[Equivalent]
{\em
  Two {formul\ae}  $f$ and $g$ are \emph{equivalent} iff \\[0.2cm]
\hspace*{1.3cm} $\models f \leftrightarrow g$ 
} \qed
\end{Definition}

\noindent
\textbf{Examples}:  \\[0.3cm]
\hspace*{0.3cm} 
$\begin{array}{lll}
\models \neg \falsum \leftrightarrow \verum & \models \neg \verum \leftrightarrow \falsum &  \\[0.2cm]
 \models p \vee   \neg p \leftrightarrow \verum & \models p \wedge \neg p \leftrightarrow
 \falsum & \mbox{tertium non datur} \\[0.2cm]
 \models p \vee   \falsum \leftrightarrow p & \models p \wedge \verum  \leftrightarrow p & \mbox{neutral element}\\[0.2cm]
 \models p \vee   \verum  \leftrightarrow \verum & \models p \wedge \falsum \leftrightarrow \falsum &  \\[0.2cm]
 \models p \wedge p \leftrightarrow p  & \models p \vee p \leftrightarrow p &  \mbox{idempotency} \\[0.2cm]
 \models p \wedge q \leftrightarrow q \wedge p & \models p \vee   q \leftrightarrow q \vee p & \mbox{commutativity} \\[0.2cm]
 \models (p \wedge q) \wedge r \leftrightarrow p \wedge (q \wedge r) & \models (p \vee   q) \vee r \leftrightarrow p \vee   (q \vee r)  &
 \mbox{associativity} \\[0.2cm]
 \models \neg \neg p \leftrightarrow p & & \mbox{elimination of $\neg \neg$} \\[0.2cm]
 \models p \wedge (p \vee q)   \leftrightarrow p & \models p \vee   (p \wedge q) \leftrightarrow p &  \mbox{absorption} \\[0.2cm]
 \models p \wedge (q \vee r)   \leftrightarrow (p \wedge q) \vee   (p \wedge r) & 
 \models p \vee   (q \wedge r) \leftrightarrow (p \vee q)   \wedge (p \vee   r) & \mbox{distributivity} \\[0.2cm]
 \models \neg (p \wedge q) \leftrightarrow  \neg p \vee   \neg q &  \models \neg (p \vee   q) \leftrightarrow  \neg p \wedge \neg q &
 \mbox{DeMorgan rules}  \\[0.2cm]
 \models (p \rightarrow q) \leftrightarrow \neg p \vee q & &  \mbox{elimination of $\rightarrow$} \\[0.2cm]
 \models (p \leftrightarrow q) \leftrightarrow (\neg p \vee q) \wedge (\neg q \vee p) & &
 \mbox{elimination of $\leftrightarrow$}
\end{array}$ \\[0.3cm]
We can establish these equivalences by constructing tables that test every possible
valuation.  We demonstrate this approach for the first of the DeMorgan rules.

\begin{table}[!ht]
  \centering
\framebox{
  \begin{tabular}{|l|l|l|l|l|l|l|}
\hline
   $p$            & $q$            &  $\neg p$      &  $\neg q$    & $p \wedge q$   & $\neg (p \wedge q)$ & $\neg p \vee \neg q$ \\
\hline
\hline
   \texttt{true}  & \texttt{true}  & \texttt{false} & \texttt{false}  & \texttt{true}  & \texttt{false}  & \texttt{false}  \\
\hline
   \texttt{true}  & \texttt{false} & \texttt{false} & \texttt{true}  & \texttt{false} & \texttt{true}    & \texttt{true}  \\
\hline
   \texttt{false} & \texttt{true}  & \texttt{true}  & \texttt{false}  & \texttt{false} & \texttt{true}     & \texttt{true} \\
\hline
   \texttt{false} & \texttt{false} & \texttt{true}  & \texttt{true} & \texttt{false} & \texttt{true}     & \texttt{true}  \\
\hline
  \end{tabular}}
  \caption{Proof of the first DeMorgan law.}
  \label{tab:deMorgan}
\end{table}
Obviously, the last two columns of table \ref{tab:deMorgan} have identical entries.  Therefore the
{formul\ae} corresponding to these columns are equivalent.

\subsection{Checking Tautologies with \textsc{Setl}}
\noindent
In this section we develop a  \textsc{Setl2} program that is able to check whether a given formula
is a tautology.  The idea is to evaluate a given formula using all possible propositional valuations.
In order to do so, we first have to compute the set of all possible propositional valuations.  We
have already seen that the propositional valuations correspond to sets of propositional {formul\ae}:
If $M$ is a set of propositional variables, then we can define the propositional valuation
$\mathcal{I}(M)$ as the valuation that evaluates a propositional variable $p$ as \texttt{true}
iff $p$ is an element of $M$, that is we define
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{I}(M)(p) := \left\{
\begin{array}[c]{ll}
  \mathtt{true}  & \mbox{if $p \in M$;} \\
  \mathtt{false} & \mbox{if $p \notin M$.}
\end{array}
\right.
$
\\[0.2cm]
On the other hand, given a propositional valuation $\mathcal{I}$, we can define a set
$\mathcal{M}(\mathcal{I})$ of propositional variables as
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{M}(\mathcal{I}) := \bigl\{ p \in \mathcal{P} \mid \mathcal{I}(p) = \mathtt{true} \bigr\}$.
\\[0.2cm]
The two mappings  $M \mapsto \mathcal{I}(M)$ and 
$\mathcal{I} \mapsto \mathcal{M}(\mathcal{I})$ are inverses of each other, we have 
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{I}(\mathcal{M}(\mathcal{I})) = \mathcal{I}$ \quad for every propositional valuation $\mathcal{I}$
\\[0.2cm]
and also
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{M}(\mathcal{I}(M)) = M$ \quad for all $M \subseteq \mathcal{P}$.
\\[0.2cm]
Therefore, we can compute the set of all propositional valuations of a formula $f$ by computing the
power set of all propositional variables occurring in $f$ and then transforming the elements of this
set into propositional valuations.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure tautology(f);
        P := collectVars(f);
        -- A is the set of all propositional valuations.
        A := { { [x, x in M] : x in P } : M in pow P };
        if forall I in A | eval(f, I) then
            return true;
        else
            return arb { I in A | not eval(f, I) };
        end if;
    end tautology;

    procedure collectVars(f);
        case
            when f = 1        =>  return {};
            when f = 0        =>  return {};
            when is_string(f) =>  return { f };
            when f(1) = "-"   =>  return collectVars( f(2) );
            when f(2) in { "*", "+", "->", "<->" } 
                 => return collectVars( f(1) ) + collectVars( f(3) );
            otherwise => print("malformed formula: ", f);
        end case;
    end collectVars;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Testing whether a formula is a tautology.}
  \label{fig:tautology}
\end{figure} 

\noindent
The procedure shown in figure \ref{fig:tautology} on page \pageref{fig:tautology} makes use of these
considerations and is able to check whether a given formula  $f$ is a tautology.
This procedure uses the procedure $\texttt{eval}()$ that has been shown in figure
\ref{fig:eval} on page \pageref{fig:eval}.
\begin{enumerate}
\item Line 2 collects all propositional variables occurring in the formula f.
      This is done with the help of the procedure $\texttt{collectVars}(f)$, which is shown
      in lines 12 -- 21.  This procedure is defined by induction on the propositional formula $f$.      
\item Line 4 computes the set of all propositional valuations.
      We have seen a similar computation already in the program shown in figure \ref{fig:watson} on
      page \pageref{fig:watson}.
\item Line 5 checks whether the given formula does indeed evaluate as \texttt{true} for all
      of the possible valuations.  If this is the case, the procedure returns \texttt{true}.
      Otherwise, a counterexample is returned.  This enables us to understand why the formula isn't
      a tautology.
\end{enumerate}

\subsection{Conjunctive Normal Form}
Instead of using a table to check that a formula is a tautology we can also try to simplify the
formula using algebraic manipulations.  If we are able to show that a formula $f$ is equivalent to
the formula $\verum$, then we have shown that $f$ is a tautology.  We demonstrate the idea with the formula
\\[0.2cm]
\hspace*{1.3cm}
$(p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q$ \\[0.2cm]
by using a chain of equivalences:
\\[0.2cm]
\hspace*{1.3cm} 
$ 
\begin{array}[c]{lcr}
                 & (p \rightarrow q) \rightarrow (\neg p \rightarrow q) \rightarrow q  &
                 \quad(\mbox{elimination of $\rightarrow$}) \\    
 \leftrightarrow & (\neg p \vee q) \rightarrow (\neg p \rightarrow q) \rightarrow q    & \quad(\mbox{elimination of $\rightarrow$})\\     
 \leftrightarrow & (\neg p \vee q) \rightarrow (\neg \neg p \vee q) \rightarrow q      &
 \quad(\mbox{elimination of double negation})\\    
 \leftrightarrow & (\neg p \vee q) \rightarrow (p \vee q) \rightarrow q                & \quad(\mbox{elimination of $\rightarrow$})\\     
 \leftrightarrow & \neg(\neg p \vee q) \vee ((p \vee q) \rightarrow q)                 & \quad(\mbox{DeMorgan})\\                          
 \leftrightarrow & (\neg\neg p \wedge \neg q) \vee ((p \vee q) \rightarrow q)          &
 \quad(\mbox{elimination of double negation})\\    
 \leftrightarrow & (p \wedge \neg q) \vee ((p \vee q) \rightarrow q)                   & \quad(\mbox{elimination of $\rightarrow$})\\     
 \leftrightarrow & (p \wedge \neg q) \vee (\neg(p \vee q) \vee q)                      & \quad(\mbox{DeMorgan})\\                          
 \leftrightarrow & (p \wedge \neg q) \vee ((\neg p \wedge \neg q) \vee q)              & \quad(\mbox{distributivity}) \\
 \leftrightarrow & (p \wedge \neg q) \vee ((\neg p \vee q) \wedge (\neg q \vee q))     & \quad(\mbox{Tertium-non-Datur})\\               
 \leftrightarrow & (p \wedge \neg q) \vee ((\neg p \vee q) \wedge \verum)                & \quad(\mbox{neutral element})\\                 
 \leftrightarrow & (p \wedge \neg q) \vee (\neg p \vee q)                              & \quad(\mbox{distributivity})\\                   
 \leftrightarrow & (p \vee (\neg p \vee q)) \wedge (\neg q \vee (\neg p \vee q))       & \quad(\mbox{associativity}) \\                   
 \leftrightarrow & ((p \vee \neg p) \vee q) \wedge (\neg q \vee (\neg p \vee q))       & \quad(\mbox{Tertium-non-Datur})\\               
 \leftrightarrow & (\verum \vee q) \wedge (\neg q \vee (\neg p \vee q))                  & \quad(\mbox{neutral element}) \\                
 \leftrightarrow & \verum \wedge (\neg q \vee (\neg p \vee q))                           & \quad(\mbox{neutral element}) \\                
 \leftrightarrow & \neg q \vee (\neg p \vee q)                                         & \quad(\mbox{associativity})\\                    
 \leftrightarrow & (\neg q \vee \neg p) \vee q                                         & \quad(\mbox{commutativity})\\                    
 \leftrightarrow & (\neg p \vee \neg q) \vee q                                         & \quad(\mbox{associativity})\\                    
 \leftrightarrow & \neg p \vee (\neg q  \vee q)                                        & \quad(\mbox{Tertium-non-Datur})\\               
 \leftrightarrow & \neg p \vee \verum                                                    & \quad(\mbox{neutral element}) \\                
 \leftrightarrow & \verum \\
\end{array}
$

\noindent
The algebraic manipulations  shown above have a system.  In order to explain this system, we need
some definitions.

\begin{Definition}[Literal]
{\em
  A propositional formula  $f$ is called a  \emph{literal} iff we have either of the following cases:
  \begin{enumerate}
  \item $f = \verum$ or $f = \falsum$.
  \item $f = p$, where $p$ is a propositional variable.

        In this case, $f$ is called a  \emph{positive} literal.
  \item $f = \neg p$, where $p$ is a propositional variable.

        In this case, $f$ is called a  \emph{negative} literal.
  \end{enumerate}
  The set of all literals will be denoted as $\mathcal{L}$.
  \qed
} 
\end{Definition}

Later we need the notion of the \emph{complement} of a literal.
If $l$ is a literal, the complement of  $l$ is denoted as $\komplement{\,l\,}$.
It is defined via a case distinction:
\begin{enumerate}
\item $\komplement{\verum} = \falsum$ \quad and \quad $\komplement{\falsum} = \verum$. 
\item $\komplement{p} := \neg p$ \quad if $p \in \mathcal{P}$.
\item $\komplement{\neg p} := p$ \quad if $p \in \mathcal{P}$.
\end{enumerate}


\begin{Definition}[Clause]
   A propositional formula $k$ is a \emph{clause} iff $k$ has the form \\[0.2cm]
\hspace*{1.3cm} $k = l_1 \vee \cdots \vee l_r$ \\[0.2cm]
where $l_i$ is a literal for all $i=1,\cdots,r$.  Therefore, a clause is a disjunction of literals.
The set of all clauses is denoted as $\mathcal{C}$.
\qed
\end{Definition}

We will regard clauses as sets of literals.  When regarding clauses as sets we abstract
from the order of the literals.  This is possible because of the associativity, commutativity, and
idempotency of the connective  ``$\vee$''.  Therefore, the clause $l_1 \vee \cdots \vee l_r$ will be
written as 
\\[0.2cm]
\hspace*{1.3cm} $\{ l_1, \cdots, l_r \}$.
\\[0.2cm]
The following example illustrates the utility of the set notation of clauses.
Consider the clauses
\\[0.2cm]
\hspace*{1.3cm}
$p \vee q \vee \neg r \vee p$ \quad and \quad $\neg r \vee q \vee \neg r \vee p$. 
\\[0.2cm]
Both clauses are equivalent, but the respective {formul\ae} are different.
If we use the set notation instead, we write these {formul\ae} as
\\[0.2cm]
\hspace*{1.3cm}
$\{p, q, \neg r \}$ \quad and \quad $\{ \neg r, q, \neg r, p \}$. 
\\[0.2cm]
However, these sets are identical!  
If we transform the equivalence
\\[0.2cm]
\hspace*{1.3cm}
$l_1 \vee \cdots \vee l_r \vee \falsum \leftrightarrow l_1 \vee \cdots \vee l_r$
\\[0.2cm]
into set notation we arrive at
\\[0.2cm]
\hspace*{1.3cm}
$\{ l_1, \cdots, l_r, \falsum \} \leftrightarrow \{ l_1, \cdots, l_r \}$.
\\[0.2cm]
This shows that the element $\falsum$ can be safely dropped from a clause.
If we set $r=0$ in the last equivalence, we arrive at the identity
\\[0.2cm]
\hspace*{1.3cm}
$\{\falsum \} \leftrightarrow \{\}$.
\\[0.2cm]
This shows that the empty set of literals has to be interpreted as $\falsum$.

\begin{Definition}
{\em 
A clause $c$ is \emph{trivial} iff we have one of the following cases:
\begin{enumerate}
\item $\verum \in c$.
\item There exists a $p \in \mathcal{P}$ such that both $p \in c$ and $\neg p \in c$.

      In this case,  $p$ and $\neg p$ are called \emph{complementary literals}.
 \qed
\end{enumerate}
} 
\end{Definition}

\begin{Proposition} \label{satz:trivial}
{\em
A clause $c$ is a tautology iff $c$ is trivial.}
\end{Proposition}
\textbf{Proof}:  Let us first assume that  $c$ is trivial.
If  $\verum \el c$, then, because of the tautology
\\[0.2cm]
\hspace*{1.3cm}
$f \vee \verum \leftrightarrow \verum$,
\\[0.2cm]
we know that $c \leftrightarrow \verum$.   If $p$ is a propositional variable such that we have both
$p \in c$ and $\neg p \in c$, then the tautology 
\\[0.2cm]
\hspace*{1.3cm}
 $p \vee \neg p \leftrightarrow \verum$ .
\\[0.2cm]
shows  $c \leftrightarrow \verum$.

Let us now assume that  $c$ is a tautology.  In order to show that $c$ is trivial we assume
that $c$ is not trivial and we will derive a contradiction from this assumption.
If $c$ is not trivial, we have $\verum \notin c$ and
$c$ can not contain any complementary literals.
Therefore, $c$ has the form
\\[0.2cm]
\hspace*{1.3cm} 
$c = \{ \neg p_1, \cdots, \neg p_m, q_1, \cdots, q_n \}$ \quad with $p_i
\not= q_j$ for all $i \in \{ 1,\cdots,m\}$ and $j \in \{1, \cdots, n\}$.
\\[0.2cm]
Let us define a propositional valuation $\mathcal{I}$ as follows:
\begin{enumerate}
\item $\mathcal{I}(p_i) = \mathtt{true}$ for all $i = 1, \cdots, m$ and
\item $\mathcal{I}(q_j) = \mathtt{false}$ for all $j = 1, \cdots, n$,
\end{enumerate}
Using this valuation we obviously have $\mathcal{I}(c) = \mathtt{false}$.  But then $c$ is not a
tautology.  This contradiction shows that, in order to be a tautology, $c$ has to be trivial.
\hspace*{\fill}  $_\Box$

\begin{Definition}[conjunctive normal form]  
A formula $f$ is  in \emph{conjunctive normal form} (abbreviated as cnf)
iff $f$ is a conjunction of clauses, that is if $f$ has the form \\[0.2cm]
\hspace*{1.3cm} $f = c_1 \wedge \cdots \wedge c_n$, \\[0.2cm]
where  $c_i$ is a clause for all $i=1,\cdots,n$. \qed
\end{Definition}

\noindent
\begin{Corollary} \label{korollar:knf}
{\em
If $f = k_1 \wedge \cdots \wedge k_n$ is in conjunctive normal form, then we have \\[0.2cm]
\hspace*{1.3cm} $\models f$ \quad iff \quad $\models k_i$ \quad for all $i=1,\cdots,n$. \qed
}
\end{Corollary}

\noindent
As the connective $\wedge$ is associative, commutative, and idempotent it is
advantageous to use a set notation for clauses.  Therefore, if a formula
\\[0.2cm]
\hspace*{1.3cm} $f = k_1 \wedge \cdots \wedge k_n$
\\[0.2cm]
is in connective normal form, we will write \\[0.2cm]
\hspace*{1.3cm} $f = \{ k_1, \cdots, k_n \}$. 
\\[0.2cm]
We provide an example:  If $p$, $q$, and $r$ are propositional variables, the formula
\\[0.2cm]
\hspace*{1.3cm}
$(p \vee q \vee \neg r) \wedge (q \vee \neg r \vee p \vee q)\wedge (\neg r \vee p \vee \neg q)$
\\[0.2cm]
is in conjunctive normal form.  In set notation this is written as
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ \{p, q, \neg r \},\, \{ p, \neg q, \neg r \} \bigr\}$.
\vspace*{0.2cm}

If  $f = c_1 \wedge \cdots \wedge c_n$ is a formula in cnf then, according to proposition
 \ref{satz:trivial} and corollary \ref{korollar:knf} $f$ is a tautology iff all clauses $c_i$  
are trivial.  We present an algorithm capable of transforming any formula $F$ into cnf.
According to the argument given above, this algorithm can then be used to check if a formula is a
tautology. 

\begin{enumerate}
\item Eliminate all occurrences of the connective ``$\leftrightarrow$'' using the equivalence \\[0.2cm]
      \hspace*{1.3cm} $\models (f \leftrightarrow g) \leftrightarrow (f \rightarrow g) \wedge (g \rightarrow f)$
\item Eliminate all occurrences of the connective ``$\rightarrow$'' using the equivalence \\[0.2cm]
      \hspace*{1.3cm} $\models (f \rightarrow g) \leftrightarrow \neg f \vee g$
\item Simplify the formula using the following equivalences:
      \begin{enumerate}
      \item $\models \neg \falsum \leftrightarrow \verum$
      \item $\models \neg \verum \leftrightarrow \falsum$
      \item $\models \neg \neg f \leftrightarrow f$
      \item $\models \neg (f \wedge g) \leftrightarrow  \neg f \vee   \neg g$ 
      \item $\models \neg (f \vee   g) \leftrightarrow  \neg f \wedge \neg g$ 
      \end{enumerate}
      After this step, the negation symbol ``$\neg$'' will only appear in front of a propositional
      variable.  A formula with the property that the negation symbol is only applied to a
      propositional variable is said to be in \emph{negation normal form}.
\item Next, the formula is expanded using the following laws of distributivity: \\[0.2cm]
      \hspace*{1.3cm} 
      $\models f \vee (g \wedge h) \leftrightarrow (f \vee g) \wedge (f \vee h)$ \quad and \quad
      $\models (f \wedge g) \vee h \leftrightarrow (f \vee h) \wedge (g \vee h)$. 
      \\[0.2cm]
      This will push the connective ``$\vee$'' inside the formula so that it no longer appears on top
      of the connective ``$\wedge$''.
\item In the last step we transform the formula into set notation by first writing the clauses
      as sets and then collecting the sets of clauses.
\end{enumerate}
It should be noted that the size of the formula can  grow in the expansion step.
This is due to the fact that in the equivalence
\\[0.2cm]
\hspace*{1.3cm}
$f \vee (g \wedge h) \leftrightarrow (f \vee g) \wedge (f \vee h)$
\\[0.2cm]
the formula $f$ occurs twice on the right hand side but only once on the left hand side.
 

We illustrate the algorithm using the formula \\[0.2cm]
\hspace*{1.3cm} $(p \rightarrow q) \rightarrow (\neg p \rightarrow \neg q)$.
\begin{enumerate}
\item As the formula does not contain the connective ``$\leftrightarrow$'',
      the first step can be skipped.
\item Eliminating the connective ``$\rightarrow$'' results in the formula \\[0.2cm]
      \hspace*{1.3cm} $\neg (\neg p \vee q) \vee (\neg \neg p \vee \neg q)$.
\item Transforming this into negation normal form we arrive at
      \\[0.2cm]
      \hspace*{1.3cm} $(p \wedge \neg q) \vee (p \vee \neg q)$.
\item Expanding this we arrive at \\[0.2cm]
      \hspace*{1.3cm} $(p \vee (p \vee \neg q)) \wedge (\neg q \vee (p \vee \neg q))$.
\item In order to transform this into set notation we first transform the clauses 
       $p \vee (p \vee \neg q)$ and $\neg q \vee (p \vee \neg q)$ into the sets
      \\[0.2cm]
      \hspace*{1.3cm} $\{p, p, \neg q\}$ \quad and \quad $\{\neg q,  p,  \neg q\}$. \\[0.2cm]
      Now these sets are equal and therefore the conjunctive normal form is
      \\[0.2cm]
      \hspace*{1.3cm} $\bigl\{ \{p, \neg q\} \bigr\}$. \\[0.2cm]
      You should note that the conversion to set notation has simplified the 
      formula considerably.
\end{enumerate}

\subsection{Implementing the Algorithm}
In this section, we develop a number of functions that can be used to transform a propositional
formula $f$ into conjunctive normal form.  We start with the function
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{elimIff}: \mathcal{F} \rightarrow \mathcal{F}$
\\[0.2cm]
that takes a propositional formula  $f$ and eliminates the connective ``$\leftrightarrow$''.  The expression
$\texttt{elimIff}(f)$ is defined by induction on the formula $f$ as follows:
\begin{enumerate}
\item If $f = \verum$, or $f = \falsum$, or if $f$ is a propositional variable $p$, then there is
      nothing to do:
      \begin{enumerate}
      \item $\mathtt{elimIff}(\verum) = \verum.$
      \item $\mathtt{elimIff}(\falsum) = \falsum$.
      \item $\mathtt{elimIff}(p) = p$ \quad for all $p \in \mathcal{P}$.
      \end{enumerate}
\item If  $f$ has the form $f = \neg g$, then we have to eliminate the connective
      ``$\leftrightarrow$'' from $g$ recursively: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{elimIff}(\neg g) = \neg \mathtt{elimIff}(g)$.
\item If $f$ has the form $f = g_1 \wedge g_2$, then we have to eliminate the connective
      ``$\leftrightarrow$'' from  $g_1$ and $g_2$: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{elimIff}(g_1 \wedge g_2) = \mathtt{elimIff}(g_1) \wedge \mathtt{elimIff}(g_2)$.
\item If $f$ has the form $f = g_1 \vee g_2$, then we have to eliminate the connective
      ``$\leftrightarrow$'' from  $g_1$ and $g_2$: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{elimIff}(g_1 \vee g_2) = \mathtt{elimIff}(g_1) \vee \mathtt{elimIff}(g_2)$.
\item If $f$ has the form $f = g_1 \rightarrow g_2$, then we have to eliminate the connective
      ``$\leftrightarrow$'' from $g_1$ and $g_2$: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{elimIff}(g_1 \rightarrow g_2) = \mathtt{elimIff}(g_1) \rightarrow
      \mathtt{elimIff}(g_2)$.

      observe that the last three cases are very similar.  We will make use of this fact in the
      implementation. 
\item If  $f$ has the form $f = g_1 \leftrightarrow g_2$, then we will use the equivalence
      \\[0.2cm]
      \hspace*{1.3cm} 
      $(g_1 \leftrightarrow g_2) \leftrightarrow \bigl( (g_1 \rightarrow g_2) \wedge (g_2 \rightarrow g_1)\bigr)$.
      \\[0.2cm]
      However, we have to be aware that the connective ``$\leftrightarrow$'' might still
      occur in $g_1$ or $g_2$.  Therefore, we have
      \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{elimIff}(g_1 \leftrightarrow g_2) = 
       \mathtt{elimIff}\bigl( (g_1 \rightarrow g_2) \wedge (g_2 \rightarrow g_1)\bigr)$. 
\end{enumerate}
Figure
\ref{fig:eliminate-gdw} on page \pageref{fig:eliminate-gdw} shows the procedure \texttt{elimIff}.
We were able to  combine the cases $f = g_1 \wedge g_2$, $f = g_1 \vee g_2$, and $f = g_1
\rightarrow g_2$, as in all these cases we just have to apply the function recursively to the
components $g_1$ and $g_2$.


\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure elimIff(f);
        case
            when f = 1        => return 1;
            when f = 0        => return 0;
            when is_string(f) => return f;
            when f(1) = "-"   => return [ "-", elimIff( f(2) ) ];
            when f(2) in { "*", "+", "->" } 
                              => return [ elimIff( f(1) ), f(2), elimIff( f(3) ) ];
            when f(2) = "<->" => return 
                 elimIff( [ [ f(1), "->", f(3) ], "*", [ f(3), "->", f(1) ] ] );
            otherwise         => print("error in elimIff( ", f, ")" );
        end case;
    end elimIff;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Elimination of ``$\leftrightarrow$''.}
  \label{fig:eliminate-gdw}
\end{figure} 

Next, we study the elimination of the connective  ``$\rightarrow$''. 
Figure \ref{fig:eliminate-folgt} on page \pageref{fig:eliminate-folgt} provides the implementation.
The idea is the same as when eliminating the connective ``$\leftrightarrow$''.  
The only difference is  that we use the equivalence
 \\[0.2cm]
\hspace*{1.3cm} $(g_1 \rightarrow g_2) \leftrightarrow (\neg g_1 \vee g_2)$. \\[0.2cm]
Furthermore, we can make use of the fact that we have already eliminated the connective  ``$\leftrightarrow$''.


\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure elimImp(f);
        case
            when f = 1        =>  return 1;
            when f = 0        =>  return 0;
            when is_string(f) =>  return f;
            when f(1) = "-"   =>  return [ "-", elimImp(f(2)) ];
            when f(2) in { "*", "+" } 
                              =>  return [ elimImp(f(1)), f(2), elimImp(f(3)) ];
            when f(2) = "->"  =>  return elimImp( [ [ "-", f(1) ], "+", f(3) ] );
            otherwise         =>  print("error in elimImp( ", f, ")" );
        end case;
    end elimImp;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Elimination of ``$\rightarrow$''.}
  \label{fig:eliminate-folgt}
\end{figure}
 
Next, we show how to transform a formula into negation normal form.
Figure \ref{fig:nnf} on page \pageref{fig:nnf} shows the implementation.
We have defined two mutually recursive functions  \texttt{nnf} and
\texttt{neg}.  The function \texttt{neg($f$)}
computes the negation normal form of  $\neg f$, while  \texttt{nnf($f$)} computes the negation
normal form of $f$, we have
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{neg}(f) = \mathtt{nnf}(\neg f)$.
\\[0.2cm]
Most of the work is done in the function \texttt{neg}, as this function implements the DeMorgan laws 
\\[0.2cm]
\hspace*{1.3cm} $\neg (f \wedge g) \leftrightarrow (\neg f \vee \neg g)$ \quad and \quad $\neg (f
\vee g) \leftrightarrow (\neg f \wedge \neg g)$.
 \\[0.2cm]
Conceptually, the transformation into negation normal form is described by the following equations:
\begin{enumerate}
\item $\texttt{nnf}(\verum) = \verum$,
\item $\texttt{nnf}(\falsum) = \falsum$,
\item $\texttt{nnf}(\neg f) = \mathtt{neg}(f)$,
\item $\texttt{nnf}(f_1 \wedge f_2) = \mathtt{nnf}(f_1) \wedge \mathtt{nnf}(f_2)$,
\item $\texttt{nnf}(f_1 \vee f_2) = \mathtt{nnf}(f_1) \vee \mathtt{nnf}(f_2)$.
\end{enumerate}
The auxiliary function \texttt{neg} is specified as follows:
\begin{enumerate}
\item $\texttt{neg}(\verum) = \mathtt{nnf}(\neg \verum) = \falsum$,
\item $\texttt{neg}(\falsum) = \mathtt{nnf}(\neg \falsum) = \verum$,
\item $\texttt{neg}(p) = \mathtt{nnf}(\neg p) = \neg p$ for all propositional variables $p$,
\item $\texttt{neg}(\neg f) = \mathtt{nnf}(\neg \neg f) = \mathtt{nnf}(f)$,
\item $\begin{array}[t]{cl}
         & \texttt{neg}\bigl(f_1 \wedge f_2 \bigr) \\[0.1cm]
       = & \mathtt{nnf}\bigl(\neg(f_1 \wedge f_2)\bigr) \\[0.1cm]
       = & \mathtt{nnf}\bigl(\neg f_1 \vee \neg f_2\bigr) \\[0.1cm]
       = & \mathtt{nnf}\bigl(\neg f_1\bigr) \vee \mathtt{nnf}\bigl(\neg f_2\bigr) \\[0.1cm]
       = & \mathtt{neg}(f_1) \vee \mathtt{neg}(f_2),
       \end{array}
      $
\item $\begin{array}[t]{cl}
         & \texttt{neg}\bigl(f_1 \vee f_2 \bigr)        \\[0.1cm]
       = & \texttt{nnf}\bigl(\neg(f_1 \vee f_2) \bigr)  \\[0.1cm]
       = & \texttt{nnf}\bigl(\neg f_1 \wedge \neg f_2 \bigr)  \\[0.1cm]
       = & \texttt{nnf}\bigl(\neg f_1\bigr) \wedge \mathtt{nnf}\bigl(\neg f_2 \bigr)  \\[0.1cm]
       = & \mathtt{neg}(f_1) \wedge \mathtt{neg}(f_2). 
       \end{array}
      $
\end{enumerate}

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                  numbers       = left,
                  numbersep     = -0.2cm,
                ]
    procedure nnf(f);
        case
            when f = 1        =>  return 1;
            when f = 0        =>  return 0;
            when is_string(f) =>  return f;
            when f(1) = "-"   =>  return neg( f(2) );
            when f(2) = "*"   =>  return [ nnf( f(1) ), "*", nnf( f(3) ) ];
            when f(2) = "+"   =>  return [ nnf( f(1) ), "+", nnf( f(3) ) ];
            otherwise         => print("error in nnf( ", f, ")" );
        end case;
    end nnf;

    procedure neg(f);
        case
            when f = 1        => return 0;
            when f = 0        => return 1;
            when is_string(f) => return [ "-", f ];
            when f(1) = "-"   => return nnf( f(2) );
            when f(2) = "*"   => return [ neg( f(1) ), "+", neg( f(3) ) ];
            when f(2) = "+"   => return [ neg( f(1) ), "*", neg( f(3) ) ];
            otherwise         => print("error in neg( ", f, ")" );
        end case;
    end neg;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Computing the negation normal form.}
  \label{fig:nnf}
\end{figure}


As the last step we implement the procedure to expand a formula using the equivalence
\\[0.2cm]
\hspace*{1.3cm}
$f \vee (g \wedge h) \leftrightarrow (f \vee g) \wedge (f \vee h)$
\\[0.2cm]
This procedure will also transform the formula into set notation, so that a formula will be 
represented as set of sets of literals.  The procedure is given in figure \ref{fig:cnf}
on page \ref{fig:cnf}.  We explain the details of this implementation below:
\begin{enumerate}
\item To begin with, we reflect how we can represent  $\verum$ in set notation.
      As  $\verum$ is the neutral element of the connective ``$\wedge$'' we have
      \\[0.2cm]
      \hspace*{1.3cm} 
      $k_1 \wedge \cdots \wedge k_n \wedge \verum \leftrightarrow  k_1 \wedge \cdots \wedge k_n$.
      \\[0.2cm]
      If  $k_1$, $\cdots$, $k_n$ are clauses, the equivalence given above can be transformed into
      set notation as follows: \\[0.2cm]
      \hspace*{1.3cm} 
      $\{ k_1, \cdots, k_n, \verum \} \leftrightarrow \{ k_1, \cdots, k_n \}$
      \\[0.2cm]
      We agree that this equivalence also holds for  $n = 0$.  Then we have
      \\[0.2cm]
      \hspace*{1.3cm} $\{\verum \} \leftrightarrow \{\}$ \\[0.2cm]
      and therefore we interpret the empty set of clauses as $\verum$.

      These considerations explain line 3 of the procedure \texttt{cnf}.
\item Next, we have to think how to represent  $\falsum$ in set notation.
      As $\falsum$ is the neutral element of the connective ``$\vee$'', we have the following
      equivalence: \\[0.2cm]
      \hspace*{1.3cm} 
      $L_1 \vee \cdots \vee L_n \vee \falsum \leftrightarrow  L_1 \vee \cdots \vee L_n$.
      \\[0.2cm]
      If  $L_1$, $\cdots$, $L_n$ are literals, this equivalence takes the following form in set
      notation: 
      \\[0.2cm]
      \hspace*{1.3cm} 
      $\{ L_1, \cdots, L_n, \falsum \} \leftrightarrow \{ L_1, \cdots, L_n \}$
      \\[0.2cm]
      We agree that this equivalence is also true for $n = 0$.  Therefore we have
      \\[0.2cm]
      \hspace*{1.3cm} $\{\falsum \} \leftrightarrow \{\}$. \\[0.2cm]
      Hence, an empty set of literals is interpreted as $\falsum$.  This empty set is to be regarded
      as a single clause.  Therefore, In order to represent the formula  $\falsum$ in cnf in set
      notation, we have to use the set $\bigl\{ \{\} \bigr\}$ since a formula is a set of clauses.

      This explains line 4 of the procedure \texttt{cnf}.
\item If the formula that is to be transformed in cnf is a propositional variable $p$,
      we have to first transform the propositional variable into a clause in set notation.
      That yields the set $\{p\}$.  As a formula in cnf is a set of clauses, the transformation
      to cnf yields then the set  $\bigl\{\{f\}\bigr\}$.
      This result is returned in line  5.
\item If the formula  $f$ that is to be turned into cnf set notation has the form \\[0.2cm]
      \hspace*{1.3cm} $f = \neg g$, \\[0.2cm]
      then $g$ has to be a propositional variable, as we always start with a formula in negation
      normal form.   Therefore, $f$ is a literal and the cnf of $F$ in set notation is given as  
      $\bigl\{\{f\}\bigr\}$.  This result is returned in line 6.
\item If $f= f_1 \wedge f_2$, then we first transform  $f_1$ and $f_2$ in cnf in set notation.
      This way we get something like the following: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{cnf}(f_1) = \{ h_1, \cdots, h_m \}$ \quad and \quad
      $\mathtt{cnf}(f_2) = \{ k_1, \cdots, k_n \}$. \\[0.2cm]
      Here,  $h_i$ and $k_j$ are clauses represented as sets.  In oder to build the  cnf of $f_1 \wedge f_2$ 
      it is sufficient to build the union of these two sets.  After all, in set notation a set of
      clauses is interpreted as the conjunction of clauses.
      \\[0.2cm]
      \hspace*{1.3cm} $\mathtt{cnf}(f_1 \wedge f_2) = \mathtt{cnf}(f_1) \cup  \mathtt{cnf}(f_2)$.
      \\[0.2cm]
      This explain line  7 of our implementation.
\item If $F$ has the form 
      \\[0.2cm]
      \hspace*{1.3cm}
      $f= f_1 \vee f_2$ 
      \\[0.2cm]
      we begin our computation by transforming  $f_1$ and $f_2$ into  cnf in set notation.
      Doing this we obtain results of the following form: \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{cnf}(f_1) = \{ h_1, \cdots, h_m \}$ \quad and \quad
      $\mathtt{cnf}(f_2) = \{ k_1, \cdots, k_n \}$. \\[0.2cm]
      Here the  $h_i$ and $k_j$ are clauses represented in set notation.  In order to compute the
      cnf of $f_1 \vee f_2$ we calculate as follows: 
      $$
      \begin{array}[c]{ll}
        & f_1 \vee f_2  \\[0.2cm]
      \leftrightarrow & (h_1 \wedge \cdots \wedge h_m) \vee (k_1 \wedge \cdots \wedge k_n) \\[0.2cm]
      \leftrightarrow & (h_1 \vee k_1) \quad \wedge \quad \cdots \quad \wedge \quad (h_m \vee k_1) \quad \wedge \\ 
                      & \qquad \vdots     \hspace*{4cm} \vdots                \\
                      & (h_1 \vee k_n) \quad \wedge \quad \cdots \quad \wedge \quad (h_m \vee k_n) \\[0.2cm] 
      \leftrightarrow & \bigl\{ h_i \vee k_j : i \in \{ 1, \cdots, m\}, j \in \{ 1, \cdots, n \} \bigr\} \\ 
      \end{array}
      $$
      If we bear in mind that a clause in set notation is regarded as a disjunction of its literals,
      then we can rewrite $h_i \vee k_j$ into $h_i \cup k_j$.  Then we have \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{cnf}(f_1 \vee f_2) = \bigl\{ h \cup k \mid h \in \mathtt{cnf}(f_1) \;\wedge\; k \in \mathtt{cnf}(f_2) \bigr\}$.
      \\[0.2cm]
      This explain line 8 of the procedure \texttt{cnf}.
\end{enumerate}

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure cnf(f);
        case
            when f = 1        =>  return { };
            when f = 0        =>  return { {} };
            when is_string(f) =>  return { { f } };
            when f(1) = "-"   =>  return { { f } };
            when f(2) = "*"   =>  return cnf( f(1) ) + cnf( f(3) );
            when f(2) = "+"   =>  return { k1 + k2 : k1 in cnf(f(1)), k2 in cnf(f(3)) };
            otherwise  => print("error in cnf( ", f, ")" );
        end case;
    end cnf;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Computing the conjunctive normal form.}
  \label{fig:cnf}
\end{figure}

Finally, figure   \ref{fig:normalize} on page \pageref{fig:normalize} shows how all the procedures
discussed so far can be combined into a single procedures that takes an arbitrary propositional
formula $f$ and transforms this formula into cnf in set notation.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure normalize(f);
        n1 := elimIff(f);
        n2 := elimFolgt(n1);
        n3 := nnf(n2);
        n4 := cnf(n3);
        return n4;
    end normalize;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Normalizing a formula.}
  \label{fig:normalize}
\end{figure}
\vspace*{\fill}


%\input{compact-barwise}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logic"
%%% End: 
