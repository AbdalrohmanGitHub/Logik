
\section{Formal Proofs}
The main subject of logic is the notion of a \emph{proof}.  The aim of this section is to 
formalize this notion.
If $\{f_1,\cdots,f_n\}$ is a set of \formulae and $g$ is another formula,  then 
we can ask whether the formula $g$ can be \emph{inferred} from the formula $f_1$, $\cdots$,
$f_n$, that is we can ask whether 
\[ \models f_1 \wedge \cdots \wedge f_n \rightarrow g \]
holds.  There are different options to answer this question.
One option would be to transform the formula $f_1 \wedge \cdots \wedge f_n \rightarrow g$ into
conjunctive normal form.  This would result in a set 
$\{c_1,\cdots,c_n\}$ of clauses, which is equivalent to the formula
\\[0.2cm]
\hspace*{1.3cm} $f_1 \wedge \cdots \wedge f_n \rightarrow g$.
\\[0.2cm] 
Now this formula is a tautology iff each of the clauses  $c_1$, $\cdots$, $c_n$ is trivial.  
Unfortunately,  this approach is quite inefficient.  Let us investigate an example and
check, whether the formula  $p \rightarrow r$ can be inferred from the \formulae $p \rightarrow q$ and
$q \rightarrow r$.   Following the approach sketched above, we have to transform the formula
\[ h := (p \rightarrow q) \wedge (q \rightarrow r) \rightarrow p \rightarrow r
\]
into conjunctive normal form.  After a lengthy calculation, the conjunctive normal form of
the formula above is found to be
\[
   (p \vee \neg p \vee r \vee \neg r) \wedge (\neg q \vee \neg p \vee r \vee \neg r) \wedge
   (\neg q \vee \neg p \vee q \vee r) \wedge (p \vee \neg p \vee q \vee r). 
\]
and indeed all of the clauses are trivial.  

In the chapter on predicate logic we will see, that the approach used above does no longer
work when we deal with quantifiers.  The reason is, that in general there is no algorithm
to decide whether a formula involving quantifiers is a tautology.
  Therefore, we now present a second approach  to check whether a given formula is a logical consequence 
of a given set of formul\ae.  The idea is, to use so called
 \emph{inference rules} to infer a formula from other formul\ae.
The notion of an \emph{inference rule} is formalized in the following definition.
  
\begin{Definition}[Inference Rule]
An  \emph{inference rule} is a pair  $\langle \{f_1, \cdots, f_n\}, c \rangle$ where
$\{f_1, \cdots, f_n\}$ is a set of \formulae and $c$ is a formul\ae. 
The \formulae $f_1$, $\cdots$, $f_n$ are the
\emph{premises}, the formula $c$ is the \emph{conclusion} of the inference rule.

\noindent
\textbf{Notation}:
If the pair 
$\langle \{f_1, \cdots, f_n\}, c \rangle$ is an inference rule, then we write this as
\\[0.3cm]
\hspace*{1.3cm}      
$\schluss{f_1 \quad \cdots \quad f_n}{c}$.
\\[0.3cm]
This is read as follows: 
``\emph{From $f_1$, $\cdots$, $f_n$ we can infer $c$.}''
\qed
\end{Definition}
\vspace*{0.3cm}

\noindent
\textbf{Examples} of inference rules: 
\\[0.2cm]
\hspace*{1.3cm}            
\begin{tabular}[t]{|l|l|l|}
\hline
\rule{0pt}{15pt} \emph{Modus Ponens}: & \emph{Modus Tollens}: & \emph{Modus Tollendo Tollens}: \\[0.3cm]
\hline
$
\rule[-15pt]{0pt}{40pt}\schluss{p \quad\quad p \rightarrow q}{q}$ &
$\schluss{\neg q \quad\quad p \rightarrow q}{\neg p}$ &
$\schluss{\neg p \quad\quad p \rightarrow q}{\neg q}$ \\[0.3cm]
\hline
\end{tabular}
\\[0.3cm]

\noindent

The definition of inference rules given above does not restrict the \formulae 
that are used as premises and conclusion in any way.  However, not all inference rules
make sense.  If we want to use an inference rule in a proof, then we should only those
rules that are \emph{correct} in the sense that the premises imply the conclusion.  
Therefore, the notion of \emph{correctness} is defined as follows.

\begin{Definition}[Correct]
The inference rule
\\[0.2cm]
\hspace*{1.3cm}
$\schluss{f_1 \quad \cdots \quad f_n}{c}$
\\[0.2cm]
is \emph{correct} if and only if we have
     $\models f_1 \wedge \cdots \wedge f_n \rightarrow c$. 
\qed
\end{Definition}

Turning back to our examples, we see that the rules denoted as
``\emph{modus ponens}'' and ``\emph{modus ponendo tollens}'' are correct.  However, the rule
``\emph{modus tollendo tollens}'' is not correct.

In the following, we will only work with clauses.  This is no real restriction, as we have
already seen that all \formulae can be transformed into a conjunction of clauses.
Furthermore, in many applications of propositional logic, the \formulae are already given 
as clauses.  We next present an inference rule for clauses.

\begin{Definition}[Cut Rule]
If $p$ is a propositional variable and $c_1$ and $c_2$ are sets of literals, then the
following inference rule will be denoted as the \emph{cut rule}: 
\[ \schluss{ c_1 \cup \{p\} \quad \{\neg p\} \cup c_2 }{c_1 \cup c_2}. 
   \hspace*{9.4cm} _\Box 
\]
\end{Definition}

\noindent
The cut rule is a very general rule.  If we put $c_1 =
\{\}$ and  $c_2 = \{q\}$ in the definition given above,
then the following rule is a special case of the cut rule: 
\\[0.2cm]
\hspace*{1.3cm} 
$\schluss{\{\} \cup \{p\} \quad\quad \{\neg p\} \cup \{ q \} }{ \{\} \cup \{q\} }$ 
\\[0.2cm]
If we interpret these sets as disjunctions, then we arrive at the following rule: 
\\[0.2cm]
\hspace*{1.3cm} 
$\schluss{p \quad\quad \neg p \vee q }{ q }$
\\[0.2cm]
As the formula $\neg p \vee q$ is equivalent to  $p \rightarrow q$, we see that the rule
\emph{modus ponens} is a special case of the cut rule.  
In the same way, the rule \emph{modus tollens} can be shown to be a special case of the
cut rule.  If we take the definition of the cut rule and put $c_1 = \{ \neg q \}$ and $c_2 = \{\}$, 
then we arrive at the rule \emph{modus tollens}. 

\begin{Proposition}
{\em
  The cut rule is correct.
}
\end{Proposition}

\noindent
\textbf{Proof}:  We have to show the following \\[0.2cm]
\hspace*{1.3cm} $\models (c_1 \vee p) \wedge (\neg p \vee c_2) \rightarrow c_1 \vee c_2$ \\[0.2cm]
can be proved.  In order to do so we transform the formula given above into conjunctive normal form:
$$
\begin{array}{ll}
  & (c_1 \vee p) \wedge (\neg p \vee c_2) \rightarrow c_1 \vee c_2  \\[0.2cm]
\leftrightarrow  & 
    \neg \bigl( (c_1 \vee p) \wedge (\neg p \vee c_2) \bigr) \vee c_1 \vee c_2 \\[0.2cm]
\leftrightarrow  & 
    \neg (c_1 \vee p) \vee \neg (\neg p \vee c_2) \vee c_1 \vee c_2 \\[0.2cm]
\leftrightarrow  & 
     (\neg c_1 \wedge \neg p) \vee  (p \wedge \neg c_2) \vee c_1 \vee c_2 \\[0.2cm]
\leftrightarrow  & 
     (\neg c_1 \vee p \vee c_1 \vee c_2)  \wedge 
     (\neg c_1 \vee \neg c_2 \vee c_1 \vee c_2)  \wedge 
     (\neg p \vee p \vee c_1 \vee c_2)  \wedge 
     (\neg p \vee \neg c_2 \vee c_1 \vee c_2) 
      \\[0.2cm]
\leftrightarrow  & 
     \verum  \wedge 
     \verum  \wedge 
     \verum  \wedge 
     \verum 
      \\[0.2cm]
\leftrightarrow  & 
     \verum    
\end{array}
$$
Since the conjunctive normal form is just $\top$, we have established the correctness of the cut rule.
\qed

Next, we formalize the notion of a proof.

\begin{Definition}[Provability, $\vdash$]
Assume $M$ is a set of clauses and $f$ is a single clause.  
The \formulae from $M$ are called the \emph{assumptions}.  The goal is to prove a formula $f$ using
these assumptions.
In order to do so we will define inductively a relation
\\[0.2cm]
\hspace*{1.3cm} 
$M \vdash f$. 
\\[0.2cm]
We will read the expression ``$M \vdash f$'' as ``$f$ is provable from $M$''.  The inductive
definition of this notion is as follows:
\begin{enumerate}
\item A set $M$ of assumptions proves all of its assumptions: \\[0.2cm]
      \hspace*{1.3cm} 
      If $f \el M$, then  $M \vdash f$.
\item If the clauses $c_1 \cup \{p\}$ and $\{ \neg p \} \cup c_2$ are provable from $M$,  then we
      can use the cut rule to prove the clause $c_1 \cup c_2$: \\[0.2cm]
      \hspace*{1.3cm} 
      If $M \vdash c_1 \cup \{p\}$ and $M \vdash \{ \neg p \} \cup c_2$, then $M \vdash c_1 \cup c_2$.
\qed
\end{enumerate}
\end{Definition}



\noindent
\textbf{Example}:  To illustrate the notion of provability, we show the following: 
\[ \bigl\{\; \{\neg p, q\},\; \{ \neg q, \neg p \},\; \{ \neg q, p \},\; \{ q, p \}\; \bigr\} \vdash \falsum.
\]
This example will also establish our way to denote proofs.
\begin{enumerate}
\item From $\{\neg p, q \}$ and $\{ \neg q, \neg p \}$, using the cut rule, we can conclude
      $\{ \neg p, \neg p \}$.   As we have $\{ \neg p, \neg p \} = \{ \neg p \}$, this step is denoted as 
      \[ \{\neg p, q \}, \{ \neg q, \neg p \} \;\vdash\; \{ \neg p \}. \]
      This example shows that the clause  $c_1 \cup c_2$ may contain less elements than the sum
      $\symbol{35}c_1 + \symbol{35}c_2$.  This happens if there are literals occurring in both  $c_1$
      and in $c_2$.
\item $\{\neg q, \neg p \},\; \{ p, \neg q \} \;\vdash\; \{ \neg q \}$. 
\item $\{ p, q \},\; \{ \neg q \} \;\vdash\; \{ p \}$. 
\item $\{ \neg p \},\; \{ p \} \;\vdash\; \{\}$. 
\end{enumerate}
As another example, we show the provability of  $p \rightarrow r$ from $p \rightarrow q$ and $q
\rightarrow r$.
In order to do so, we first transform these formula into clauses in set notation: 
\[ \mathtt{cnf}(p \rightarrow q) = \bigl\{ \{ \neg p, q \} \bigr\}, \quad
   \mathtt{cnf}(q \rightarrow r) = \bigl\{ \{ \neg q, r \} \bigr\}, \quad 
   \mathtt{cnf}(p \rightarrow r) = \bigl\{ \{ \neg p, r \} \bigr\}.
\]
Therefore, we have $M = \bigl\{\, \{ \neg p, q \},\; \{ \neg q, r \}\,\bigr\}$ and have to show
\[ M \vdash  \{ \neg p, r \}. \]
The proof is a single application of the cut rule:
\[ \{ \neg p, q \},\; \{ \neg q, r \} \;\vdash\; \{ \neg p, r \}. \]

\subsection{Properties of the Notion of Provability}
There are two very important properties of the relation $\vdash$ that will be formulated next.

\begin{Theorem}[Correctness]
If  $\{c_1, \cdots, c_n \}$ is a set of clauses and $c$ is a single clause,
then we have: \\[0.2cm]
\hspace*{3.3cm} If $\{c_1, \cdots, c_n \} \vdash c$, \quad then $\models c_1 \wedge \cdots \wedge c_n \rightarrow c$.  \qed
\end{Theorem}


\noindent
It would be nice if we were able to invert this theorem.  However,
the converse of the correctness theorem is only true in a special case: It is only true if
$c$ is the empty clause, that is if $c = \falsum$.

\begin{Proposition}[Refutation Completeness] \label{widerlegungs-vollstaendig}
If  $\{c_1, \cdots, c_n \}$ is a set of clauses, then we have the following: 
\\[0.2cm]
\hspace*{1.3cm} 
If $\models c_1 \wedge \cdots \wedge c_n \rightarrow \falsum$, \quad then $\{c_1, \cdots, c_n \}
\vdash \{\}$. \qed
\end{Proposition}

\noindent
Unfortunately, we do not have the time to present proofs of these theorems.


\section{The Algorithm of  Davis and Putnam}
In practical applications, it is often necessary to find a propositional valuation $\mathcal{I}$
such that, for a given set of clauses  $C$, the following holds true:
\\[0.2cm]
\hspace*{1.3cm} 
$\mathtt{eval}(c,\I) = \mathtt{true}$ \quad for all $c\in C$. 
\\[0.2cm]
In this case, the set of clauses is called \emph{satisfiable} and the propositional valuation
$\I$ is called a  \emph{solution} of $C$.  The notion of satisfiability is strongly connected with
the notion of tautology-hood.  For a given set of clauses $\{ c_1, \cdots, c_n \}$ we have
\\[0.2cm]
\hspace*{1.3cm}
$\{ c_1, \cdots, c_n \}$ is not satisfiable \quad iff \quad
$\models c_1 \wedge \cdots \wedge c_n \rightarrow \falsum$.
\\[0.2cm]
In this section, we present an algorithm that can be used to check whether a set of clauses is
satisfiable.  This algorithm is due to  Davis and Putnam \cite{davis62}.  
Refinements of this algorithm are, for example, used to prove the correctness of digital circuits.

In order to motivate this algorithm, let us first consider those sets of clauses where the
satisfiability is obvious.  Consider the following example:
\\[0.2cm]
\hspace*{1.3cm} 
$C_1 = \bigl\{\; \{p\},\; \{\neg q\},\; \{r\},\; \{\neg s\}, \; \{\neg t\} \;\bigr\}$ 
\\[0.2cm]
The set $C_1$ represents the propositional formula
\\[0.2cm]
\hspace*{1.3cm}
$p \wedge \neg q \wedge r \wedge \neg s \wedge \neg t$.
\\[0.2cm]
Obviously,  $C_1$ is satisfiable: The propositional valuation  \\[0.2cm]
\hspace*{1.3cm} 
$\I = \bigl\{\; \pair(p, \mathtt{true}),\; \pair(q, \mathtt{false}),\;\pair(r, \mathtt{true}),\; \pair(s, \mathtt{false}),\; \pair(t, \mathtt{false})\;\}$
\\[0.2cm]
is a solution of $C_1$.  Consider another example: \\[0.2cm]
\hspace*{1.3cm} 
$C_2 = \bigl\{\; \{\}, \{p\},\; \{\neg q\},\; \{r\}\; \bigr\}$ 
\\[0.2cm]
This set of clauses represents the formula
\\[0.2cm]
\hspace*{1.3cm}
$\falsum \wedge p \wedge \neg q \wedge r$
\\[0.2cm]
which is obviously not satisfiable.  As a final example, consider
\\[0.2cm]
\hspace*{1.3cm} $C_3 = \bigl\{ \{p\}, \{\neg q\}, \{\neg p\} \bigr\}$.
\\[0.2cm]
This set of clauses represents the formula
\\[0.2cm]
\hspace*{1.3cm}
$p \wedge \neg q \wedge \neg p $
\\[0.2cm]
and, again, is is obvious that $C_3$ is not satisfiable, since a solution $\I$ would have
to evaluate $p$ both as \texttt{true} and \texttt{false}.
These examples motivate the following definitions.


\begin{Definition}[Unit Clause]
{\em
  A clause $c$ is called a  \emph{unit clause} iff  $c$ contains just one literal,
  that is, if we have \\[0.2cm]
  \hspace*{1.3cm} $c = \{p\}$ \quad or \quad $c = \{\neg p\}$ \\[0.2cm]
  for a propositional variable $p$        .
}
\end{Definition}
\pagebreak

\begin{Definition}[Trivial Set of Clauses]
{\em
  A set of clauses $C$ is called \emph{trivial} iff we have one of the following cases:
  \begin{enumerate}
  \item The empty clause is a member of $C$:
        \\[0.2cm]
        \hspace*{1.3cm}
        $\{\} \in C$.

        In this case,  $C$ is obviously unsatisfiable.
  \item The set $C$ only contains unit clauses with different propositional variables.
        If the set of all propositional variables is denoted as  $\mathcal{P}$,
        then this requirement can be formalized as follows:
        \\[0.3cm]
        \hspace*{1.3cm}
        $\forall c \el C: \textsl{card}(c) = 1$ \quad and \quad
        $\forall p \el \mathcal{P}: \neg\bigl( \{p\} \in C \wedge \{\neg p\} \in C\bigr)$.
        \\[0.3cm]
        Then the propositional valuation 
        \[ \I := \bigl\{ \pair(p, \mathtt{true}) \mid \{p\} \in C \bigr\} \,\cup\, \bigl\{
             \pair(p, \mathtt{false}) \mid \{\neg p\} \in C \bigr\} 
        \]
        is a solution of  $C$. \qed
  \end{enumerate}
}
\end{Definition}

The main idea of the algorithm of Davis and Putnam is to try to simplify a given set of
clauses until all clauses are unit clauses.  There are three methods to simplify a given set
of clauses:
\begin{enumerate}
\item Use of the cut rule,
\item Use of the subsumption rule,
\item Case distinction.
\end{enumerate}
We discuss these methods in detail in the following.

\subsection{Simplifications via the Cut Rule}
A typical application of the cut rule takes the following form: \\[0.2cm]
\hspace*{1.3cm} $\schluss{ c_1 \cup \{p\} \quad \{\neg p\} \cup c_2}{c_1 \cup c_2}$
\\[0.2cm]
In general, the clause $c_1 \cup c_2$ will contain more literals than the premises
$c_1 \cup \{p\}$ and $\bigl\{\neg p\} \cup c_2$.  If the clause
$c_1 \cup \{p\}$ has $m+1$ literals and the clause $\bigl\{\neg p\} \cup c_2$ has $n+1$
literals, then the conclusion $c_1 \cup c_2$ contains up to $m + n$ literals.  
Of course, this number could be less than $m + n$:  This is the case if there are
literals that are members of both  $c_1$ and $c_2$.  In most cases,
$m + n$ is bigger than both  $m + 1$ and $n + 1$.  Only if either  $n = 0$ or $m = 0$ we
can be sure that $m + n$ is less than either $m +1$ or $n + 1$.
We have $n = 0$ or $m = 0$ if either of the two clauses $c_1 \cup \{p\}$ 
and $\bigl\{\neg p\} \cup c_2$ consists of a single literal and
therefore is a unit clause.  As we want to simplify our clauses, we will only use the cut
rule if one of its premises is a unit clause.  These restrictions of the cut rule are
called \emph{unit cuts}.  In order to conduct all possible unit cuts with a given literal $l$,
we define the function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{unitCut}: 2^\mathcal{C} \times \mathcal{L} \rightarrow 2^\mathcal{C}$
\\[0.2cm]
in a way that, for a given set of clauses $C$ and a literal $l$ the function
$\textsl{unitCut}(C,l)$ performs all cut rules that are possible with the unit clause 
$\{l\}$:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{unitCut}(C,l) = 
  \Bigl\{ c \backslash \bigl\{ \komplement{\,l\,} \bigr\} \;\Big|\; 
          c \in C \wedge \komplement{\,l\,} \in c
  \Bigr\}.
$

\subsection{Simplification via Subsumption}
We demonstrate the subsumption principle with the help of an example.  Consider
the set
 \\[0.2cm]
\hspace*{1.3cm} 
$C := \bigl\{ \{p, q, \neg r\}, \{p\} \bigr\} \cup M$. 
\\[0.2cm]
Apparently, the clause  $\{p\}$ implies the clause $\{p, q, \neg r\}$ since we have \\[0.2cm]
\hspace*{1.3cm} 
$\models p \rightarrow q \vee p \vee \neg r$. 
\\[0.2cm]
Therefore, the clause $\{p, q, \neg r\}$ can be dropped from $C$ and $C$ can be simplified into
\\[0.2cm]
\hspace*{1.3cm}
$C' := \bigl\{ \{p\} \bigr\} \cup M$. 
\\[0.2cm]
In general, we define that a clause $c$
is \emph{subsumed} by a unit clause  $u$ iff
\\[0.2cm]
\hspace*{1.3cm}
$u \subseteq c$.
\\[0.2cm]
Therefore, if  $C$ is a set of clauses such that  $c \in C$ and $u \in C$ and if, furthermore,
$c$ is subsumed by $u$, then  $C$ can be simplified to  $C - \{c\}$.
To facilitate the implementation of this we define a function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{subsume}: 2^\mathcal{C} \times \mathcal{L} \rightarrow 2^\mathcal{C}$
\\[0.2cm]
that takes a set of clauses $C$ and a unit clause $\{l\} \in C$.  The function simplifies $C$ by
elimination all clauses from $C$ that are subsumed by  $\{l\}$.  Of course, the unit clause
$\{l\}$ itself is retained.  Hence we define
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{subsume}(C, l) := 
\bigl(C \backslash \bigl\{ c \in C \mid l \in c \bigr\}\bigr) \cup \bigl\{\{l\}\bigr\} = 
\bigl\{ c \in C \mid l \not\in c \bigr\} \cup \bigl\{\{l\}\bigr\}$.
\\[0.2cm]
Observe that we have to add $\{l\}$ into the result, as the set 
$\bigl\{ c \in C \mid l \not\in c \bigr\}$ does not contain the unit clause $\{l\}$.


\subsection{Simplification via Case Distinction}
If we would only use unit cuts and unit subsumption, then our set of inference rules would be
incomplete.  We need another method to simplify sets of clauses.
Therefore, we add the \emph{principle of case distinction}.
This principle is based on the following proposition.

\begin{Proposition}
{\em
  If $C$ is a set of clauses and $p$ is a propositional variable, then $C$ is satisfiable
  if and only if either  $C \cup \bigl\{\{p\}\bigr\}$ or $C \cup \bigl\{\{\neg p\}\bigr\}$
  is satisfiable.  
}  
\end{Proposition}

\noindent
\textbf{Proof}:
\begin{description}
    \item[``$\Rightarrow$'':]
          If  $C$ is satisfied via the propositional valuation
          $\I$, then there are two cases for  $\I(p)$:
          \begin{enumerate}
          \item If $\I(p) = \mathtt{true}$, then  $C \cup \bigl\{\{p\}\bigr\}$ is satisfiable.
          \item If $\I(\neg p) = \mathtt{true}$, then $C \cup \bigl\{\{\neg p\}\bigr\}$ is
                satisfiable. 
          \end{enumerate}
    \item[``$\Leftarrow$'':]
          As $C$ is both a subset of  $C \cup \bigl\{\{p\}\bigr\}$ and also a subset of
          $C \cup \bigl\{\{\neg p\}\bigr\}$, it is obvious
          that $C$ is satisfiable if either of these sets is satisfiable.
\qed
\end{description}

Therefore, in order to check whether a given set of clauses $C$ is satisfiable, we 
choose a propositional variable $p$ that occurs in $C$.  Subsequent, we form the sets
\\[0.2cm]
\hspace*{1.3cm} $C_1 := C \cup \bigl\{\{p\}\bigr\}$ \quad and \quad $C_2 := C \cup
\bigl\{\{\neg p\}\bigr\}$
\\[0.2cm]
and recursively investigate whether  $C_1$ is satisfiable.  If we find a solution
for $C_1$,  then this solution is also a solution of the set  $C$.  Otherwise, we check whether
$C_2$ is satisfiable.  Again, if we find a solution for $C_2$, then this is also a solution
for  $C$.  On the other hand, if we neither find a solution for $C_1$ nor for  $C_2$, then
$C$ has to be unsolvable, too.
The recursive investigation of  $C_1$ and $C_2$ is simpler than the investigation of $C$
as we now have the additional  unit clauses $\{p\}$ or $\{\neg p\}$ that can be used to
simplify the corresponding sets via unit cuts and unit subsumptions.
This leads to the following algorithm:

\begin{description}
\item[Given:]  A set $C$ of clauses.
\item[Wanted:] A propositional valuation $\mathcal{I}$ that solves $C$, that is: 
     \\[0.2cm]
     \hspace*{1.3cm}
     $\I(c) = \mathtt{true}$ \quad for all $c \in C$.
\item[Algorithm:] Perform the following steps.
     \begin{enumerate}
     \item Conduct all possible unit cuts and all possible unit subsumptions.

           Note that as a result of unit cuts, new unit clauses might be added
           to the set $C$.  We repeatedly perform all unit cuts and unit subsumptions
           until we don't find any new unit clauses.
     \item If $C$ is trivial, report the result.
     \item Otherwise: Choose a propositional variable $p$ occurring in $C$ but that
           does not occur in any of its unit clauses.
      \begin{enumerate}
      \item Recursively solve \\[0.2cm]
            \hspace*{1.3cm}  $C \cup \bigl\{\{p\}\bigr\}$.
             \\[0.2cm]
            If this succeeds, we have a solution of $C$.
      \item Otherwise, recursively solve \\[0.2cm]
            \hspace*{1.3cm} $C \cup \bigl\{\{\neg p\}\bigr\}$. \\[0.2cm]
            If this succeeds, we have a solution of $C$. 
      \item Otherwise,  $C$ is not satisfiable.
      \end{enumerate}
\end{enumerate}
\end{description}

In order to implement this algorithm, it is beneficial to combine the functions
 $\textsl{unitCut}()$ and $\textsl{subsume}()$.  We therefore define the function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{reduce}: 2^\mathcal{C} \times \mathcal{L} \rightarrow 2^\mathcal{C}$
\\[0.2cm]
as follows 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{reduce}(C,l)  = 
 \bigl\{\, c \backslash \{\komplement{l}\} \;|\; c \in C \wedge \komplement{l} \in c \,\bigr\} 
       \,\cup\, \bigl\{\, c \in C \mid \komplement{l} \not\in c \wedge l \not\in c \} \cup \bigl\{\{l\}\bigr\}.
$
\\[0.2cm]
According to this definition, the set $\textsl{reduce}(C,l)$
contains the results of all cuts with the unit clause  $\{l\}$ and, furthermore, those
clauses of $C$ are retained, that are not connected with the literal $l$ as neither $l$ nor
$\komplement{l}$ occurs in $c$.  Finally the unit clause $\{l\}$ is added.
Therefore, the sets  $C \cup \{l\}$  and $\textsl{reduce}(C,l)$ are equivalent:  If either
of these sets is solvable, so is the other one.



\subsection{An Example}
Define the set  $C$ as follows: \\[0.2cm]
\hspace*{1.3cm} $C := \Big\{ \{p, q, s\},\; \{\neg p, r, \neg t\},\;  \{r, s\},\; \{\neg r, q, \neg p\},$ \\
\hspace*{2.5cm} $\{\neg s, p\},\; \{\neg p, \neg q, s, \neg r\},\; \{p, \neg q, s\},\;
\{\neg r, \neg s\},\; \{\neg p, \neg s\} \Big\}  $. 
\\[0.2cm]
Using the algorithm of  Davis and Putnam we show that  $C$             is not satisfiable.
\begin{enumerate}
\item As $C$ does not contain any unit clauses, the first step doesn't change the set of clauses.
\item Next, we check whether $C$ is trivial.
      Apparently,  $C$ is not trivial, so we have to proceed.
\item We have to choose a propositional variable occurring in $C$.  It is best to choose a variable that
      does occur in many clauses of $C$.  Therefore, let us take the propositional
      variable $p$.  Note that if we choose a different variable, our computation might get
      longer. Of course, in the end we would get the same result.
      \begin{enumerate}
      \item Recursively, we have to check whether the set 
            \\[0.2cm]
            \hspace*{1.3cm}
            $C_0 := C \cup \bigl\{ \{p\} \bigr\}$       
            \\[0.2cm]
            is satisfiable.  Therefore, we compute \\[0.2cm]
            \hspace*{0.3cm} 
            $C_1 := \textsl{reduce}\bigl(C_0,p\bigr) = 
                    \Big\{ \{r, \neg t\},\; \{r, s\},\; \{\neg r, q\},\; \{\neg q, s, \neg r\},\; 
                    \{\neg r, \neg s\},\; \{ \neg s\},\;\{p\}\, 
                    \Big\}$.
            \\[0.2cm]
            Now the set  $C_1$ contains the unit clause $\{\neg s\}$
            that can be used to reduce this set: \\[0.2cm]
            \hspace*{1.3cm} 
            $C_2 := \textsl{reduce}\bigl(C_1,\;\neg s\bigr) = 
                    \Big\{ \{r, \neg t\},\; \{r\},\; \{\neg r, q\},\; 
                           \{\neg q, \neg r\},\; \{ \neg s\},\; \{p\} 
                    \Big\}$.
            \\[0.2cm]
            This set contains the new unit clause $\{r\}$:
            \\[0.2cm]
            \hspace*{1.3cm} 
            $C_3 := \textsl{reduce}\bigl(C_2,\; r\bigr) = 
                    \Big\{ \{r\},\; \{q\},\; \{\neg q\},\; \{ \neg s\},\; \{p\} \Big\}$
            \\[0.2cm]
            As $C_3$ contains the unit clause $\{q\}$       
            we define: \\[0.2cm]
            \hspace*{1.3cm} 
            $C_4 := \textsl{reduce}\bigl(C_2,\;q\bigr) = 
              \Big\{ \{r\},\; \{q\},\; \{\},\; \{ \neg s\},\; \{p\} \Big\}$.
            \\[0.2cm]
            Now $C_4$ contains the empty clause and therefore is not satisfiable.    
      \item According to the algorithm, we now define \\[0.2cm]
            \hspace*{1.3cm} 
            $C_5 := C \cup \bigl\{ \{\neg p\} \bigr\}$ \\[0.2cm]
            and check whether this set is satisfiable.  To this end we define
            \\[0.2cm]
            \hspace*{1.3cm} 
            $C_6 = \textsl{reduce}\bigl(C,\; \neg p\bigr) =
            \Big\{ \{q, s\},\; \{r, s\},\;\{\neg s\},\; 
                \{\neg q, s\},\; \{\neg r, \neg s\},\;\{\neg p\}\, \Big\}$.
            \\[0.2cm]
            The set $C_6$ contains the unit clause  $\{\neg s\}$.  Therefore, we define
            \\[0.2cm]
            \hspace*{1.3cm} 
            $C_7 = \textsl{reduce}\bigl(C_6,\; \neg s\bigr) =
                   \Big\{ \{q\},\; \{r\},\;\{\neg s\},\; \{\neg q\},\;\{\neg p\}\, 
             \Big\}$.
            \\[0.2cm]
            The set  $C_7$ contains the unit clause $\{q\}$. Hence we define:\\[0.2cm]
            \hspace*{1.3cm} 
            $C_8 = \textsl{reduce}\bigl(C_7,\; q \bigr) =
             \Big\{ \{q\},\; \{r\},\;\{\neg s\},\; \{\},\;\{\neg p\}\, \Big\}$.
            \\[0.2cm]
            As $C_8$ contains the empty clause, both  $C_8$ and the given set $C$ are
            unsatisfiable.
            \qed
      \end{enumerate}
\end{enumerate}
In the example above, we only had to apply one case distinction.  In general, any
recursive invocation of the method could itself give rise to further case distinctions.
\pagebreak

\subsection{Implementing the  Algorithm of Davis and Putnam}
Next, we implement the algorithm.
Figure \ref{fig:solve} on page \pageref{fig:solve} shows the implementation of the
procedure \texttt{DavisPutnam}.  This procedure is called with two arguments: 
\texttt{Clauses} and \texttt{Literals}.
\begin{enumerate}
\item \texttt{Clauses} is a set of clauses.
\item \texttt{Literals} is a set of literals.
\end{enumerate}
If the literals from \texttt{Literals} are turned into unit clauses and added to the set \texttt{Clauses},
then the procedure call \texttt{DavisPutnam(Clauses, Literals)} checks whether the
resulting set of clauses is satisfiable.  If a solution $\mathcal{I}$ is
found, it is returned as the result.  If, on the other hand, the set is not
satisfiable, then, instead, the result \texttt{false} is returned.
We need the second argument \texttt{Literals} in the procedure \texttt{DavisPutnam} in
order to remember the literals that have already been used for unit cuts and subsumptions.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.2cm,
                  xrightmargin  = 0.2cm
                ]
    procedure DavisPutnam( Clauses, Literals );
        Clauses := saturate(Clauses);
        if {} in Clauses then
            return false;
        end if;
        if forall c in Clauses | #c = 1 then
            return Clauses;
        end if;
        literal := selectLiteral(Clauses, Literals);
        Result := DavisPutnam(Clauses + {{literal}}, Literals + { literal });
        if Result /= false then
            return Result;
        end if;        
        notLiteral := negateLiteral(literal);
        return DavisPutnam(Clauses + {{notLiteral}}, Literals + { notliteral } );
    end DavisPutnam;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{DavisPutnam}.}
  \label{fig:solve}
\end{figure} 

The implementation that is shown in figure \ref{fig:solve} works as follows:
\begin{enumerate}
\item Line 2 performs all possible unit cuts and unit subsumptions that are possible
      with the set  \texttt{Clauses}.
\item Next, we test in line 3 whether the resulting set of clauses contains the empty set 
      and is therefore not satisfiable.
\item Line 6 tests whether all clauses $c$ from the set
      \texttt{Clauses} are unit clauses.  In this case, the set \texttt{Clauses} is 
      trivial and we return this set as a result.
\item Otherwise, line 9 selects a literal $l$ from the set \texttt{Clauses}
      that has not been used already.
\item Line 10 checks recursively whether the set \\[0.2cm]
      \hspace*{1.3cm} 
      $\mathtt{Clauses} \cup \bigl\{\{\mathtt{literal}\}\bigr\}$ 
      \\[0.2cm]
      is solvable.
      \begin{enumerate}
      \item If this set is solvable, we return the solution as result.
      \item Otherwise, we recursively check, whether the set \\[0.2cm]
            \hspace*{1.3cm} $\mathtt{Clauses} \cup \bigl\{ \{ \neg \mathtt{literal}\} \bigr\}$ \\[0.2cm]
            is solvable.  
      \end{enumerate}
\end{enumerate}

Next, we discuss the auxiliary procedures. We start with the  function
\texttt{saturate}. 
This procedure takes a set $S$ of clauses and performs all possible unit cuts and unit
subsumptions.  The implementation is shown in figure \ref{fig:saturate} on page \pageref{fig:saturate}.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure saturate(S);
        Units := \{ c in S | #c = 1 \};
        Used := \{\};
        while Units /= \{\} loop
            unit := arb Units;
            Used := Used + \{ unit \};
            literal := arb unit;
            S := reduce(S, literal);
            Units := \{ c in S | #c = 1 \} - Used;        
        end loop;
        return S;
    end saturate;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{saturate}.}
  \label{fig:saturate}
\end{figure} 
The implementation of  \texttt{saturate} works as follows: 
\begin{enumerate}
\item Line 2 computes the set \texttt{Units} of all unit clauses occurring in $S$.  
\item Line 3 initializes the set \texttt{Used}.  This set is used for remembering
      those unit clauses that have already been used.
\item As long as the set  \texttt{Units} is not empty we choose an arbitrary 
      unit clause in line 5.
\item Line 6 adds this clause to the set of used clauses so that we don't use it again.
\item Line 7 extracts the literal from the unit clause.
\item Line 8 performs all unit cuts and unit subsumptions that can be done
      with the help of the literal from the chosen unit clause.
\item As the reduction in line 8 can produce new unit clauses we have to collect these new
      unit clauses in line 9.
\item The loop in line  4 -- 10 runs as long as we find new unit clauses.
      Therefore, when the procedure returns the set of clauses $S$ in line 11, 
      we can be sure the this set can not be reduced further by either unit cuts or unit subsumptions.
\end{enumerate}
The procedure \texttt{reduce} is shown in figure \ref{fig:reduce}.
It is an implementation of the following formula:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{reduce}(C,l)  = 
 \bigl\{\, c \backslash \{\komplement{l}\} \;|\; c \in C \wedge \komplement{l} \in c \,\bigr\} 
       \,\cup\, \bigl\{\, c \in C \mid \komplement{l} \not\in c \wedge l \not\in c \} \cup \bigl\{\{l\}\bigr\}.
$
\\

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure reduce( S, l );
        notL := negateLiteral(l);
        return   { c - { notL } : c in S | notL in c } 
               + { c in S | not notL in c and not l in c } 
               + { {l} };
    end reduce;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{reduce}.}
  \label{fig:reduce}
\end{figure} 

\noindent
Furthermore, the auxiliary procedures \textsl{selectLiteral} and \textsl{negateLiteral}
are shown in figure  \ref{fig:solve-aux} on page \pageref{fig:solve-aux}.
\begin{enumerate}
\item The procedure $\texttt{selectLiteral}(S, F)$ returns an arbitrary literal from the
      set $S$ of clauses that is not contained in the set \texttt{F}.  In order to to
      this, the expression ``\texttt{+/ S}'' computes the union of all clauses.  This is a
      set of all literal occurring in clauses from $S$.  From this set, the set of
      literals $F$ is subtracted.  Finally, we return an arbitrary element form the
      resulting set of literals.
\item The procedure \texttt{negateLiteral} computes the complement $\komplement{l}$ 
      of a given literal  $l$.  There are two cases:  
      \begin{enumerate}
      \item The literal is a negated variable $\neg p$.  In this case,
            $l$ has the form $l = \texttt{[ ",", $p$ ]}$ and the variable $p$ is returned.
      \item The literal is a propositional variable.  In this case, the variable has to be
            negated.
      \end{enumerate}
\end{enumerate}
\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure selectLiteral( S, F );
        return arb (+/ S - F);
    end selectLiteral;

    procedure negateLiteral(l);
        if l(1) = "-" then
            return l(2);
        else
            return [ "-", l ];
        end if;
    end negateLiteral;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedures \texttt{select} and \texttt{negateLiteral}.}
  \label{fig:solve-aux}
\end{figure}

The algorithm of Davis and Putnam can be refined in a number of ways.  Unfortunately, we
don't have the time to discuss these refinements.  The article of Moskewicz
\cite{moskewicz01} describes a number of possible refinements.   
\\[0.2cm]
\hspace*{1.3cm} \textsl{Chaff: Engineering an Efficient SAT Solver} \\
\hspace*{1.3cm} written by \emph{M. Moskewicz, C. Madigan, Y. Zhao, L. Zhang, S. Malik} \\
\pagebreak


\section{The Eight Queens Puzzle}
Next, we show how certain combinatorial problems can be transformed into problems of
propositional logic.  These problems can then be solved using the algorithm of
 Davis and Putnam.  To provide an example we will discuss the 8 queens puzzle.
The task is to position 8 queens on a chess board in a way that no queen can attack any of
the other queens.  In chess, a queen can attack another piece if either of the following
is true:
\begin{itemize}
\item the piece is in the same row as the queen,
\item the piece is in the same column as the queen, or
\item the piece is in the same diagonal as the queen.
\end{itemize}
Figure \ref{fig:queens-problem} on page \pageref{fig:queens-problem} presents a chess board
with a queen on it.  The queen can attack all of the marked positions.

\begin{figure}[!ht]
  \centering
\setlength{\unitlength}{1.0cm}
\begin{picture}(10,9)
\thicklines
\put(1,1){\line(1,0){8}}
\put(1,1){\line(0,1){8}}
\put(1,9){\line(1,0){8}}
\put(9,1){\line(0,1){8}}
\put(0.9,0.9){\line(1,0){8.2}}
\put(0.9,9.1){\line(1,0){8.2}}
\put(0.9,0.9){\line(0,1){8.2}}
\put(9.1,0.9){\line(0,1){8.2}}
\thinlines
\multiput(1,2)(0,1){7}{\line(1,0){8}}
\multiput(2,1)(1,0){7}{\line(0,1){8}}
\put(4.15,6.15){{\chess Q}}
\multiput(5.25,6.5)(1,0){4}{\vector(1,0){0.5}}
\multiput(3.75,6.5)(-1,0){3}{\vector(-1,0){0.5}}
\multiput(5.25,7.25)(1,1){2}{\vector(1,1){0.5}}
\multiput(5.25,5.75)(1,-1){4}{\vector(1,-1){0.5}}
\multiput(3.75,5.75)(-1,-1){3}{\vector(-1,-1){0.5}}
\multiput(3.75,7.25)(-1,1){2}{\vector(-1,1){0.5}}
\multiput(4.5,7.25)(0,1){2}{\vector(0,1){0.5}}
\multiput(4.5,5.75)(0,-1){5}{\vector(0,-1){0.5}}
\end{picture}
\vspace*{-1.0cm}
  \caption{The 8 queens puzzle.}
  \label{fig:queens-problem}
\end{figure}

As a first step, we have to decide how to represent a chess board and the queens that are
positioned on it.  The idea is to have a propositional variable for every possible
position.  If this variable is true, then  a queen is put into this position, else the
position stays empty.  In order to name the positions consistently, we take 
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{p}ij$
\\[0.2cm]
to represent the position in row number $i$ and column number $j$.  Here, both $i$ and $j$
are elements of the set $\{1, \cdots, 8\}$.  The rows are enumerated from top to bottom,
while the columns are enumerated from left to right.
Figure \ref{fig:queens-assign} on page \pageref{fig:queens-assign} shows the assignment of
variables to the positions on the chess board.

\begin{figure}[!ht]
  \centering
\setlength{\unitlength}{1.0cm}
\begin{picture}(10,9)
\thicklines
\put(0.9,0.9){\line(1,0){8.2}}
\put(0.9,9.1){\line(1,0){8.2}}
\put(0.9,0.9){\line(0,1){8.2}}
\put(9.1,0.9){\line(0,1){8.2}}
\put(1,1){\line(1,0){8}}
\put(1,1){\line(0,1){8}}
\put(1,9){\line(1,0){8}}
\put(9,1){\line(0,1){8}}
\thinlines
\multiput(1,2)(0,1){7}{\line(1,0){8}}
\multiput(2,1)(1,0){7}{\line(0,1){8}}

%%  for (i = 1; i <= 8; i = i + 1) {
%%for (j = 1; j <= 8; j = j + 1) \{
%%   \put(\$j.15,<9-$i>.35){{\Large p<$i>\$j}}
%%\}
%%  }

\put(1.15,8.40){{ p11}}
\put(2.15,8.40){{ p12}}
\put(3.15,8.40){{ p13}}
\put(4.15,8.40){{ p14}}
\put(5.15,8.40){{ p15}}
\put(6.15,8.40){{ p16}}
\put(7.15,8.40){{ p17}}
\put(8.15,8.40){{ p18}}
\put(1.15,7.40){{ p21}}
\put(2.15,7.40){{ p22}}
\put(3.15,7.40){{ p23}}
\put(4.15,7.40){{ p24}}
\put(5.15,7.40){{ p25}}
\put(6.15,7.40){{ p26}}
\put(7.15,7.40){{ p27}}
\put(8.15,7.40){{ p28}}
\put(1.15,6.40){{ p31}}
\put(2.15,6.40){{ p32}}
\put(3.15,6.40){{ p33}}
\put(4.15,6.40){{ p34}}
\put(5.15,6.40){{ p35}}
\put(6.15,6.40){{ p36}}
\put(7.15,6.40){{ p37}}
\put(8.15,6.40){{ p38}}
\put(1.15,5.40){{ p41}}
\put(2.15,5.40){{ p42}}
\put(3.15,5.40){{ p43}}
\put(4.15,5.40){{ p44}}
\put(5.15,5.40){{ p45}}
\put(6.15,5.40){{ p46}}
\put(7.15,5.40){{ p47}}
\put(8.15,5.40){{ p48}}
\put(1.15,4.40){{ p51}}
\put(2.15,4.40){{ p52}}
\put(3.15,4.40){{ p53}}
\put(4.15,4.40){{ p54}}
\put(5.15,4.40){{ p55}}
\put(6.15,4.40){{ p56}}
\put(7.15,4.40){{ p57}}
\put(8.15,4.40){{ p58}}
\put(1.15,3.40){{ p61}}
\put(2.15,3.40){{ p62}}
\put(3.15,3.40){{ p63}}
\put(4.15,3.40){{ p64}}
\put(5.15,3.40){{ p65}}
\put(6.15,3.40){{ p66}}
\put(7.15,3.40){{ p67}}
\put(8.15,3.40){{ p68}}
\put(1.15,2.40){{ p71}}
\put(2.15,2.40){{ p72}}
\put(3.15,2.40){{ p73}}
\put(4.15,2.40){{ p74}}
\put(5.15,2.40){{ p75}}
\put(6.15,2.40){{ p76}}
\put(7.15,2.40){{ p77}}
\put(8.15,2.40){{ p78}}
\put(1.15,1.40){{ p81}}
\put(2.15,1.40){{ p82}}
\put(3.15,1.40){{ p83}}
\put(4.15,1.40){{ p84}}
\put(5.15,1.40){{ p85}}
\put(6.15,1.40){{ p86}}
\put(7.15,1.40){{ p87}}
\put(8.15,1.40){{ p88}}

\end{picture}
\vspace*{-1.0cm}
  \caption{Assignments of the variables.}
  \label{fig:queens-assign}
\end{figure}

In order to translate this idea into \textsc{Setl},  we implement the procedure
$\texttt{createBoard}()$.  This procedure returns a list of lists of variables that
represent the chess board shown in Figure \ref{fig:queens-assign}.  The implementation of
this procedure is shown in Figure  \ref{fig:createBoard} on page
\pageref{fig:createBoard}.  Each of the lists contained in the result represents a single
column of the board.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure createBoard(n);
        return [ [ "p" + i + j : j in [1..n] ] : i in [1..n] ];
    end createBoard;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedures \texttt{createBoard} and \texttt{createRow}.}
  \label{fig:createBoard}
\end{figure}

In order to understand how this procedure works, we call the procedure with the argument 8,
which gives the size of the board.  The result is shown in Figure
\ref{fig:createBoard-output} on the next page.
The board is represented as a list containing 8 elements.  These elements are itself lists
and represent the columns of the board.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
   [ ["p11", "p12", "p13", "p14", "p15", "p16", "p17", "p18"], 
     ["p21", "p22", "p23", "p24", "p25", "p26", "p27", "p28"], 
     ["p31", "p32", "p33", "p34", "p35", "p36", "p37", "p38"], 
     ["p41", "p42", "p43", "p44", "p45", "p46", "p47", "p48"], 
     ["p51", "p52", "p53", "p54", "p55", "p56", "p57", "p58"], 
     ["p61", "p62", "p63", "p64", "p65", "p66", "p67", "p68"], 
     ["p71", "p72", "p73", "p74", "p75", "p76", "p77", "p78"], 
     ["p81", "p82", "p83", "p84", "p85", "p86", "p87", "p88"] ]
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Output of \texttt{createBoard(8)}.}
\label{fig:createBoard-output}
\end{figure}

Next, we have to translate the constraints of the eight queens puzzle
into propositional logic.
We have the following constraints:
\begin{itemize}
\item Every row has at most one queen.
\item Every column has at most one queen.
\item Every diagonal has at most one queen.
\item There are eight queens on the board.
\end{itemize}
The first three statements can all be reduced to the same structure.  
We have a set of propositional variables \\[0.2cm]
\hspace*{1.3cm} $V = \{ x_1, \cdots, x_n \}$ \\[0.2cm]
and we need to find a formula that expresses that at most one of the variables from $V$ is
\texttt{true}.  However, this means that for all
$x_i, x_j \in V$ such that $x_i \not= x_j$ we must have \\[0.2cm]
\hspace*{1.3cm} $\neg (x_i \wedge x_j)$, \\[0.2cm]
because then two different variables cannot be \texttt{true} at the same time.
According to the laws of DeMorgan we have
\\[0.2cm]
\hspace*{1.3cm}
$\neg (x_i \wedge x_j) \leftrightarrow \neg x_i \vee \neg x_j$
\\[0.2cm]
and in set notation this can be expressed as the following clause:
\\[0.2cm]
\hspace*{1.3cm}  $\{\neg x_i, \neg x_j \}$. \\[0.2cm]
Therefore, the formula that expresses that no two different variables from a given set of variables
$V$ are true simultaneously, is given as the following set of clauses:
\\[0.2cm]
\hspace*{1.3cm} $\bigl\{\, \{ \neg p, \neg q \} \;|\; p \in V \,\wedge\, q \in V
\,\wedge\, p \not= q \bigr\}$.
\\[0.2cm]
We translate these considerations into a \textsc{Setl} procedure.  Figure \ref{fig:atMostOne}
shows the procedure \texttt{atMostOne} that
takes a set $V$ of propositional variables as argument.  The
procedure invocation  $\texttt{atMostOne}(V)$ computes a set of clauses.  These clauses are
\texttt{true} if and only if at most one of the variables from $V$ is true.


\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  commandchars  = \\\{\},
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure atMostOne(V);
        return \{ \{ [ "-", p ], [ "-", q ] \} : p in V, q in V | p /= q \};
    end atMostOne;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{atMostOne}.}
  \label{fig:atMostOne}
\end{figure}

Using the procedure \texttt{atMostOne} we can implement the procedure 
\texttt{atMostOneInRow}.  The procedure call \\[0.2cm]
\hspace*{1.3cm} \texttt{atMostOneInRow}(\textsl{board}, \textsl{row}) \\[0.2cm]
takes a board and a row number and computes a propositional formula that is \texttt{true}
if that row contains at most one queen.  The assumption is, of course, that the argument
\texttt{board} is the output from the procedure $\mathtt{createBoard}(n)$.
Figure \ref{fig:atMostOneInRow} shows the implementation of  $\texttt{atMostOneInRow}()$: 
We collect the set of all those variables that denote positions in the given row:
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ \mathtt{board}(\mathtt{row})(j) \mid j \in \{1, \cdots, 8 \} \bigr\}$.
\\[0.2cm]
This set is then used as argument of the auxiliary procedure $\texttt{atMostOne}()$.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure atMostOneInRow(board, row);
        return atMostOne({ board(row)(j) : j in {1 .. 8} });
    end atMostOneInRow;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{atMostOneInRow}.}
  \label{fig:atMostOneInRow}
\end{figure}

Next, we ensure that we have indeed positioned eight queens on the board.
Now if we put a queen in every column, we know that there will be at least eight queens on
the board.  As we already know that no column can contain more than one queen, we can be
sure that every column must indeed contain exactly one queen, for otherwise we cannot have
eight queens on the board.  Now the formula that there is a queens in the first column
is given as
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{p}11 \vee \mathtt{p}21 \vee \mathtt{p}31 \vee \mathtt{p}41 \vee \mathtt{p}51 \vee
\mathtt{p}61 \vee \mathtt{p}71 \vee \mathtt{p}81$.
\\[0.2cm]
In general, if we want to express that there is a queen in column  $c$ where 
 $c \in \{1,\cdots,8\}$, then we can use the formula
\\[0.2cm]
\hspace*{1.3cm}
$\mathtt{p}1c \vee \mathtt{p}2c \vee \mathtt{p}3c \vee \mathtt{p}4c \vee \mathtt{p}5c \vee
\mathtt{p}6c \vee \mathtt{p}7c \vee \mathtt{p}8c$.
\\[0.2cm]
Using set notation, we arrive at the following set of clauses:
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ \{\mathtt{p}1c , \mathtt{p}2c , \mathtt{p}3c , \mathtt{p}4c , \mathtt{p}5c ,
\mathtt{p}6c , \mathtt{p}7c , \mathtt{p}8c \}\bigr\}$.
\\[0.2cm]
Figure \ref{fig:oneInColumn} shows a  \textsc{Setl} procedure that computes this formula
for a given \texttt{column}.  We have to return a set of clauses here, since the algorithm
of Davis and Putnam is designed to work on sets of clauses.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure oneInColumn(board, column);
        return { { board(row)(column) : row in { 1 .. 8 } } };
    end oneInColumn;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{oneInColumn}.}
  \label{fig:oneInColumn}
\end{figure}

You might expect that we develop \formulae expressing that every column contains at most
one queen and \formulae expressing that every row contains at least one queen.
However, these \formulae are redundant:  If every column contains at least one queen and,
furthermore, every row contains at most one queen, then we can conclude that 
there are exactly eight queens on the board.  However, then there must be exactly one
queen per row, for if one row would miss a queen, another row would have to contain two
queens, which we have excluded already.  Similarly, if one column would contain more than
one queen, another column would have to be empty.


Next, we tackle the diagonals.
As a first step we think how to characterize the positions of one diagonal.
There are two different kinds of diagonals: Lower diagonals and upper diagonals.
We start with upper diagonals.  The longest upper diagonal contains the propositional variables
\\[0.2cm]
\hspace*{1.3cm} 
$\texttt{p}81,\; \texttt{p}72,\; \texttt{p}63,\; \texttt{p}54,\; \texttt{p}45,\; \texttt{p}36,\; 
 \texttt{p}27,\; \texttt{p}18$. 
\\[0.2cm]
Now the indices $i$ and $j$ of the variables $\mathrm{p}ij$ satisfy the following linear equation: \\[0.2cm]
\hspace*{1.3cm} 
$i + j = 9$. 
\\[0.2cm]
In general, the indices of an upper diagonal satisfy the linear equation 
\\[0.2cm]
\hspace*{1.3cm} 
$i + j = k$, \\[0.2cm]
where $k$ is an elements of the set $\{3, \cdots, 15 \}$.  This value  $k$ is the argument
of the procedure   \texttt{atMostOneInUpperDiagonal}. This procedure is shown in Figure
\ref{fig:atMostOneInUpperDiagonal}.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure atMostOneInUpperDiagonal(board, k);
        S := { board(r)(c) : r in [1..8], c in [1..8] | r + c = k };
        return atMostOne(S);
    end atMostOneInUpperDiagonal;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{atMostOneInUpperDiagonal}.}
  \label{fig:atMostOneInUpperDiagonal}
\end{figure}

In order to characterize the variables representing a lower diagonal, we inspect the lower
main diagonal.  This diagonal contains the following variables
\\[0.2cm]
\hspace*{1.3cm} 
$\texttt{p}11,\; \texttt{p}22,\; \texttt{p}33,\; \texttt{p}44,\; \texttt{p}55,\; 
 \texttt{p}66,\; \texttt{p}77,\; \texttt{p}88$. 
\\[0.2cm]
The indices $i$ and $j$ of the variable $\mathrm{p}ij$ satisfy the linear equation 
\\[0.2cm]
\hspace*{1.3cm} 
$i - j = 0$. 
\\[0.2cm]
In general, the indices of a lower diagonal satisfy the linear equation
\\[0.2cm]
\hspace*{1.3cm} 
$i - j = k$, \\[0.2cm]
where $k$ is an element from the set $\{-6, \cdots, 6 \}$.  This value $k$ is the argument
of the procedure  \texttt{atMostOneInLowerDiagonal}, which is shown in Figure
 \ref{fig:atMostOneInLowerDiagonal}.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    procedure atMostOneInLowerDiagonal(board, k);
        S := { board(r)(c) : r in [1..8], c in [1..8] | r - c = k };
        return atMostOne(S);
    end atMostOneInLowerDiagonal;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{atMostOneInLowerDiagonal}.}
  \label{fig:atMostOneInLowerDiagonal}
\end{figure}

Now we are able to compute a set of clauses that contains all constraints of the eight
queen puzzle.
Figure \ref{fig:allClauses} shows the procedure \texttt{allClauses}.
The procedure is called as  \\[0.2cm]
\hspace*{1.3cm} $\mathtt{allClauses}(\textsl{board})$. \\[0.2cm]
Here \textsl{board} represents a chess board.  The argument \textsl{board} is computed by
the procedure \textsl{createBoard}.  The procedure \texttt{allClauses} 
then computes a set of clauses that are
satisfied if and only if the following conditions are true:
\begin{enumerate}
\item Every row contains at most one queen,
\item every lower diagonal contains at most one queen,
\item every upper diagonal contains at most one queen,
\item every column contains at least one queen.
\end{enumerate}
The expressions in the procedure \texttt{allClauses}
yield sets and the elements of these sets are sets of clauses.
As the result needs to be one set of clauses and not a set of set of clauses
we use the operator ``\texttt{+/}'' to combine these sets of sets of clauses into sets of clauses.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm
                ]
    procedure allClauses(board);
        return   +/ { atMostOneInRow(board, row)         : row in {1..8}    }
               + +/ { atMostOneInLowerDiagonal(board, c) : c in {-6..6}     }
               + +/ { atMostOneInUpperDiagonal(board, c) : c in {3..15}     }
               + +/ { oneInColumn(board, column)         : column in {1..8} };
    end allClauses;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{The procedure \texttt{allClauses}.}
  \label{fig:allClauses}
\end{figure}

Now we are ready to solve the eight queens puzzle:  The following commands compute the solution:
\begin{verbatim}
    board   := createBoard(8);
    Clauses := allClauses(board);
    I       := DavisPutnam(Clauses,{});
    printBoard(I);
\end{verbatim}
Here,  $\texttt{printBoard}()$ is a procedure that presents the solution in a readable form.
However, this only works if we use a fixed width font.  For completeness, the
implementation of this procedure is shown in
Figure  \ref{fig:printBoard}, but we won't discuss this implementation.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    procedure printBoard(I, board);
        if I = om then
            return;
        end if;
        n := #board;
        print( "        " + ((8*n+1) * "-") );
        for row in [1..n] loop
            line := "        |";
            for col in [1..n] loop
                line +:= "       |";
            end loop;
            print(line);
            line := "        |";
            for col in [1..n] loop
                if { board(row)(col) } in I then
                    line +:= "   Q   |";
                else
                    line +:= "       |";
                end if;
            end loop;
            print(line);
            line := "        |";
            for col in [1..n] loop
                line +:= "       |";
            end loop;
            print(line);
            print( "        " + ((8*n+1) * "-") );
        end loop;
    end printBoard;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The procedure $\texttt{printBoard}()$.}
\label{fig:printBoard}
\end{figure}

The set $I$ that is computed by the call  $\mathtt{DavisPutnam}(Clauses, \{\})$ 
is a set of literals.  For any of the propositional variables $\mathrm{p}ij$, either the unit clause 
 $\{\mathrm{p}ij\}$ or the unit clause   $\{ \neg \mathrm{p}ij\}$ is contained in $I$.
If there is a queen in column $i$ and row $j$, the set $I$ will contain the clause
 $\{\mathrm{p}ij\}$, otherwise, $I$ will contain the clause  $\{ \neg \mathrm{p}ij\}$.
A graphical representation of the solution that is computed 
is shown in Figure \ref{fig:queens-solution}. 

\begin{figure}[!ht]
  \centering
\hspace*{0.0cm}
\vbox{\offinterlineskip
   \hrule height1pt
   \hbox{\vrule width1pt\bigchess
         \vbox{\hbox{0Z0L0Z0Z}
               \hbox{Z0Z0Z0ZQ}
               \hbox{QZ0Z0Z0Z}
               \hbox{Z0L0Z0Z0}
               \hbox{0Z0Z0L0Z}
               \hbox{ZQZ0Z0Z0}
               \hbox{0Z0Z0ZQZ}
               \hbox{Z0Z0L0Z0}}%
         \vrule width1pt}
   \hrule height1pt}

  \caption{A solution of the eight queens puzzle.}
  \label{fig:queens-solution}
\end{figure}

The eight queens puzzle is only a toy application of propositional logic.
Nevertheless, it shows the power of the algorithm of Davis and Putnam.
The set of clauses produced by the procedure \texttt{allClauses} has a size of more than two  screens.
These clauses contain 64 different variables and the solution is computed in less than a
second on computer running Mac OS X that was equipped with an Intel Core 2 Duo processor
running at 2.15 GHz.

There are a number of practical problems that can be reduced to propositional formula in a
similar way.  For example, the creation of a time table satisfying a number of constraints
can easily be reduced to a formula of propositional logic.  In general, these problems are
known as sheduling problems and have important practical applications.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logic"
%%% End
: 
