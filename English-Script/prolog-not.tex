\section{Negation in \textsl{Prolog}}
In diesem Abschnitt besprechen wir die Implementierung des Negations-Operators in
\textsl{Prolog}.  Wir zeigen zunächst an Hand eines einfachen Beispiels die Verwendung
dieses Operators, besprechen dann seine Semantik und zeigen abschließend, in welchen
Fällen die Verwendung des Negations-Operators problematisch ist.

\subsection{Berechnung der Differenz zweier Listen}
In \textsl{Prolog} wird der Negations-Operator als ``\texttt{\symbol{92}+}'' geschrieben.
Wir erläutern die Verwendung dieses 
Operators am Beispiel einer Funktion, die die Differenz zweier Mengen berechnen soll,
wobei die Mengen durch Listen dargestellt werden.  Wir werden  die Funktion \\[0.1cm]
\hspace*{1.3cm} 
$\texttt{difference}: \textsl{List}(\textsl{Number}) \times \textsl{List}(\textsl{Number}) \rightarrow \textsl{List}(\textsl{Number})$
\\[0.1cm]
durch bedingte Gleichungen spezifizieren.  Der Ausdruck \\[0.1cm]
\hspace*{1.3cm} $\mathtt{difference}(l_1,l_2)$ \\[0.1cm]
berechnet die Liste aller der Elemente aus $l_1$, die nicht Elemente der Liste $l_2$ sind.
In \textsc{Setl} könnten wir diese Funktion wie in Abbildung \ref{fig:difference.stl}
gezeigt implementieren.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    procedure difference(l1, l2);
        return [ x in l1 | not x in l2 ];
    end difference;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Implementierung der Prozedur \texttt{difference} in \textsc{Setl}.}
\label{fig:difference.stl}
\end{figure}

\noindent
In \textsl{Prolog} erfolgt die Implementierung dieser Funktion durch Rekursion im ersten Argument.
Dazu stellen wir zunächst bedingte Gleichungen auf:
\begin{enumerate}
\item $\textsl{difference}([], l) = []$.
\item $\neg \textsl{member}(h, l) \rightarrow \textsl{difference}([h|t], l) = [h |\textsl{difference}(t,l)]$,

      denn wenn das Element $h$ in der Liste $l$ nicht vorkommt, so bleibt dieses Element
      im Ergebnis erhalten.
\item $     \textsl{member}(h, l) \rightarrow \textsl{difference}([h|t], l) = \textsl{difference}(t,l)$.
\end{enumerate}

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    % difference( +List(Number), +List(Number), -List(Number) ).
    difference( [], _L, [] ).
    
    difference( [ H | T ], L, [ H | R ] ) :-
        \+ member( H, L ),
        difference( T, L, R ).
    
    difference( [ H | T ], L, R ) :-
        member( H, L ),
        difference( T, L, R ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Berechnung der Differenz zweier Listen}
  \label{fig:difference}
\end{figure}

\subsection{Semantik des Negations-Operators in \textsc{Prolog}}
Es bleibt Zu klären, wie das \textsl{Prolog}-System eine Anfrage der Form
\\[0.1cm]
\hspace*{1.3cm} \texttt{\symbol{92}+} $A$ \\[0.1cm]
beantwortet, wie also der \texttt{not}-Operator implementiert ist.
\begin{enumerate}
\item Zunächst versucht das System, die Anfrage ``$A$'' zu beantworten.
\item Falls die Beantwortung der Anfrage ``$A$'' scheitert, ist die Beantwortung
      der Anfrage ``\texttt{\symbol{92}+} $A$'' erfolgreich.  In diesem Fall werden keine
      Variablen instanziiert.
\item Falls die Beantwortung der Anfrage ``$A$'' erfolgreich ist, so scheitert die Beantwortung
      der Anfrage ``\texttt{\symbol{92}+} $A$''.
\end{enumerate}

Wichtig ist zu sehen, dass bei der Beantwortung einer negierten Anfrage in keinem Fall
Variablen instanziiert werden.  Eine negierte Anfrage
\\[0.1cm]
\hspace*{1.3cm} \texttt{\symbol{92}+} $A$ \\[0.1cm]
funktioniert daher nur dann wie erwartet, wenn die Anfrage $A$ keine Variablen mehr
enthält.  Zur Illustration betrachten wir das Programm in Abbildung \ref{fig:not-problem}.
Versuchen wir mit diesem Programm die Anfrage \\[0.1cm]
\hspace*{1.3cm} \texttt{smart1(X)} \\[0.1cm]
zu beantworten, so wird diese Anfrage reduziert zu der Anfrage \\[0.1cm]
\hspace*{1.3cm} \texttt{\symbol{92}+ roemer(X), gallier(X)}. \\[0.1cm]
Um die Anfrage ``\texttt{\symbol{92}+ roemer(X)}'' zu beantworten, 
versucht das \textsl{Prolog}-System rekursiv, die Anfrage ``\texttt{roemer(X)}''
zu beantworten.  Dies gelingt und die Variable \texttt{X} wird dabei an den Wert 
``\texttt{caesar}'' gebunden.  Da die Beantwortung der Anfrage ``\texttt{roemer(X)}''
gelingt, scheitert die Anfrage \\[0.1cm]
\hspace*{1.3cm} \texttt{\symbol{92}+ roemer(X)} \\[0.1cm]
und damit gibt es auch auf die ursprüngliche Anfrage ``\texttt{smart1(X)}'' keine Antwort.

\begin{figure}[!ht]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    gallier(miraculix).
    
    roemer(caesar).
    
    smart1(X) :- \+ roemer(X), gallier(X).
    
    smart2(X) :- gallier(X), \+ roemer(X).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Probleme mit der Negation}
  \label{fig:not-problem}
\end{figure}

Wenn wir voraussetzen, dass das Programm das Prädikate \texttt{roemer/1}
\underline{vollständi}g beschreibt, dann ist dieses Verhalten nicht korrekt, denn dann
folgt die Konjunktion \\[0.1cm]
\hspace*{1.3cm} 
$\neg \mathtt{roemer}(\mathtt{miraculix}) \wedge \mathtt{gallier}(\mathtt{miraculix})$
 \\[0.1cm]
ja aus unserem Programm.  Wenn der dem \textsl{Prolog}-System zu Grunde liegende
automatische Beweiser anders implementiert wäre, dann könnte er dies auch erkennen.
Wir können uns in diesem Beispiel damit behelfen, dass wir die Reihenfolge der
Formeln im Rumpf umdrehen, so wie dies bei der Klausel in Zeile 7 der Abbildung
\ref{fig:not-problem} geschehen ist.  Die Anfrage \\[0.1cm]
\hspace*{1.3cm} \texttt{smart2(X)} \\[0.1cm]
liefert für \texttt{X} den Wert ``\texttt{miraculix}''.
Die zweite Anfrage funktioniert, weil zu dem Zeitpunkt, an dem die negierte Anfrage
``\texttt{\symbol{92}+ roemer(X)}'' aufgerufen wird, ist die Variable \texttt{X} bereits
an den Wert \texttt{miraculix} gebunden und die Anfrage ``\texttt{roemer}(\texttt{miraculix})''
scheitert.  Generell sollte in \textsl{Prolog}-Programmen der Negations-Operator
``\texttt{\symbol{92}+}'' nur auf solche Prädikate angewendet werden, die zum Zeitpunkt
keine freien Variablen mehr enthalten.

\section{Die Tiefen-Suche in \textsl{Prolog}}
Wenn das \textsl{Prolog}-System eine Anfrage beantwortet, wird dabei als Such-Strategie
die sogenannte Tiefen-Suche (engl. \emph{depth first search}) angewendet.  Wir wollen
diese Strategie nun an einem weiteren Beispiel verdeutlichen.  Wir implementieren dazu ein
\textsl{Prolog}-Programm  
mit dessen Hilfe es möglich ist, in einem Graphen eine Verbindung von einem gegebenen
Start-Knoten zu einem Ziel-Knoten zu finden.  Als Beispiel betrachten wir den Graphen in
Abbildung \ref{fig:graph}.  Die Kanten können durch ein \textsl{Prolog}-Prädikat \texttt{edge/2}
wie folgt dargestellt werden:

\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    edge(a, b).
    edge(a, c).
    edge(b, e).
    edge(e, f).
    edge(c, f).
\end{Verbatim}

\begin{figure}[!h]
  \centering
  \epsfig{file=Figures/graph,scale=0.5}
  \caption{Ein einfacher Graph ohne Zykeln}
  \label{fig:graph}
\end{figure}

Wir wollen nun ein \textsl{Prolog}-Programm entwickeln, mit dem es möglich ist für zwei
vorgegebene Knoten $x$ und $y$ zu entscheiden, ob es einen Weg von $x$ nach $y$ gibt.
Außerdem soll dieser Weg dann als Liste von Knoten berechnet werden.
Unser erster Ansatz besteht aus dem Programm, das in Abbildung \ref{fig:connect} gezeigt
ist.  Die Idee ist, dass der Aufruf \\[0.1cm]
\hspace*{1.3cm} \texttt{find\_path(\textsl{Start}, \textsl{Goal}, \textsl{Path})} \\[0.1cm]
einen Pfad \textsl{Path} berechnet, der von \textsl{Start} nach \textsl{Goal} führt.  Wir diskutieren
die Implementierung.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    % find_path( +Point, +Point, -List(Point) ).
    find_path( X, X, [ X ] ).
    
    find_path( X, Z, [ X | Path ] ) :-
        edge( X, Y ),
        find_path( Y, Z, Path ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Berechnung von Pfaden in einem Graphen}
  \label{fig:connect}
\end{figure}

\begin{enumerate}
\item Die erste Klausel sagt aus, dass es trivialerweise einen Pfad von \texttt{X} nach
      \texttt{X} gibt.  Dieser Pfad enthält genau den Knoten \texttt{X}.
\item Die zweite Klausel sagt aus, dass es einen Weg von \texttt{X} nach \texttt{Z}
      gibt, wenn es zunächst eine direkte Verbindung von \texttt{X} zu einem Knoten
      \texttt{Y} gibt und wenn es dann von diesem Knoten \texttt{Y} eine Verbindung
      zu dem Knoten \texttt{Z} gibt.  Wir erhalten den Pfad, der von \texttt{X} nach
      \texttt{Z} führt, dadurch, dass wir vorne an den Pfad, der von \texttt{Y} nach \texttt{Z}
      führt, den Knoten \texttt{X} anfügen.
\end{enumerate}
Stellen wir an das \textsl{Prolog}-System die Anfrage \texttt{find\_path(a,f,P)}, so
erhalten wir die Antwort
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    ?- find_path(a,f,P).
 
    P = [a, b, e, f] ;   
    P = [a, c, f] ;
    No
\end{Verbatim}
Durch Backtracking werden also alle möglichen Wege von \texttt{a} nach \texttt{b} gefunden.
Als nächstes testen wir das Programm mit dem in Abbildung \ref{fig:graph2} gezeigten
Graphen.  Diesen Graphen stellen wir wie folgt in \textsl{Prolog} dar:
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    edge(a, b).
    edge(a, c).
    edge(b, e).
    edge(e, a).
    edge(e, f).
    edge(c, f).
\end{Verbatim}

\begin{figure}[!h]
  \centering
  \epsfig{file=Figures/graph2,scale=0.5}
  \caption{Ein Graph mit einem Zykel}
  \label{fig:graph2}
\end{figure}

Jetzt erhalten wir auf die Anfrage \texttt{find\_path(a,f,P)} die Antwort
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    ?- find_path(a,f,P).
    ERROR: Out of local stack
\end{Verbatim}
Die Ursache ist schnell gefunden.
\begin{enumerate}
\item Wir starten mit der Anfrage \\[0.1cm]
      \hspace*{1.3cm} \texttt{find\_path(a,f,P)}.
\item Nach Unifikation mit der zweiten Klausel haben wir die Anfrage reduziert auf \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{edge( a, Y1 ), find\_path( Y1, f, P1 )}.
\item Nach Unifikation mit dem Fakt \texttt{edge(a,b)} haben wir die neue Anfrage \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{find\_path( b, f, P1 )}.
\item Nach Unifikation mit der zweiten Klausel haben wir die Anfrage reduziert auf \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{edge( b, Y2 ), find\_path( Y2, f, P2 )}.
\item Nach Unifikation mit dem Fakt \texttt{edge(b,e)} haben wir die neue Anfrage \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{find\_path( e, f, P2 )}.
\item Nach Unifikation mit der zweiten Klausel haben wir die Anfrage reduziert auf \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{edge( e, Y3 ), find\_path( Y3, f, P3 )}.
\item Nach Unifikation mit dem Fakt \texttt{edge(e,a)} haben wir die neue Anfrage \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{find\_path( a, f, P3 )}.
\end{enumerate}
Die Anfrage ``\texttt{find\_path(a, f, P3)}'' unterscheidet sich aber von der ursprünglichen
Anfrage ``\texttt{find\_path(a,f,P)}'' nur durch den Namen der Variablen.  Wenn wir jetzt
weiterrechnen würden, würde sich die Rechnung nur wiederholen, ohne dass wir vorwärts kommen.
Das Problem ist, das \textsl{Prolog} immer die erste
Klausel nimmt, die paßt.  Wenn später die Reduktion der Anfrage scheitert, wird zwar nach
Backtracking die nächste Klausel ausprobiert, aber wenn das Programm in eine
Endlos-Schleife läuft, dann gibt es eben kein Backtracking, denn das Programm weiß ja
nicht, dass es in einer Endlos-Schleife ist.

Es ist aber leicht das Programm so umzuschreiben, dass keine Endlos-Schleife mehr
auftreten kann.  Die Idee ist, dass wir uns merken, welche Knoten wir bereits besucht
haben und diese nicht mehr auswählen.  In diesem Sinne implementieren wir nun ein Prädikat \texttt{find\_path/4}.
Die Idee ist, dass der Aufruf \\[0.1cm]
\hspace*{1.3cm} \texttt{find\_path(\textsl{Start}, \textsl{Goal}, \textsl{Visited}, \textsl{Path})} \\[0.1cm]
einen Pfad berechnet, der von \textsl{Start} nach \textsl{Goal} führt und der zusätzlich
keine Knoten benutzt, die bereits in der Liste \textsl{Visited} aufgeführt sind.  Diese Liste
füllen wir bei den rekursiven Aufrufen nach und nach mit den Knoten an, die wir bereits
besucht haben.  Mit Hilfe dieser Liste vermeiden wir es, einen Knoten zweimal zu besuchen.
Abbildung \ref{fig:connect2} zeigt die Implementierung.
\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    % find_path( +Point, +Point, +List(Point), -List(Point) )

    find_path( X, X, _Visited, [ X ] ).
    
    find_path( X, Z, Visited, [ X | Path ]) :-
        edge( X, Y ),
        \+ member( Y, Visited ),
        find_path( Y, Z, [ Y | Visited ], Path ).
    \end{Verbatim}
\vspace*{-0.3cm}
  \caption{Berechnung von Pfaden in zyklischen Graphen}
  \label{fig:connect2}
\end{figure}
\begin{enumerate}
\item In der ersten Klausel spielt das zusätzliche Argument noch keine Rolle,
      denn wenn wir das Ziel erreicht haben, ist es uns egal, welche Knoten wir schon
      besucht haben.
\item In der zweiten Klausel überprüfen wir in Zeile 7, ob der Knoten \texttt{Y}
      in der Liste \textsl{Visited}, die die Knoten enthält, die bereits besucht wurden,
      auftritt.  Nur wenn dies nicht der Fall ist, versuchen wir rekursiv von \texttt{Y}
      einen Pfad nach \texttt{Z} zu finden.  Bei dem rekursiven Aufruf erweitern wir die Liste
      \texttt{Visited} um den Knoten \texttt{Y}, den diesen Knoten wollen wir in Zukunft
      ebenfalls vermeiden.
\end{enumerate}
Mit dieser Implementierung ist es jetzt möglich, auch in dem zweiten Graphen einen Weg von
\texttt{a} nach \texttt{f} zu suchen, wir erhalten
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    ?- find_path(a,f,[a],P).
    P = [a, b, e, f] ;
    P = [a, c, f] ;    
    No
\end{Verbatim}
\pagebreak

\subsection{Missionare und Kannibalen}
Als spielerische Anwendung zeigen wir nun, wie sich mit Hilfe des oben definierten Prädikats 
\texttt{find\_path/4} bestimmte Rätsel lösen lassen und lösen exemplarisch das folgende
Rätsel:
\vspace*{0.3cm}

\begin{minipage}[c]{14cm}
{\sl Drei Missionare und drei Kannibalen wollen zusammen einen Fluß 
überqueren. Sie haben nur ein Boot, indem maximal zwei Passagiere fahren können.  
Sowohl die Kannibalen als auch die Missionare können rudern.
Die Kannibalen sind hungrig, wenn die Missionare an einem der Ufer in der Unterzahl sind, 
haben sie ein Problem.  Die Aufgabe besteht darin, einen Fahrplan zu 
erstellen, so dass hinterher alle das andere  Ufer erreichen und die
Missionare zwischendurch kein Problem haben.}
\end{minipage}
\vspace*{0.4cm}

\noindent
Die Idee ist, das Rätsel, durch einen Graphen zu modellieren.  Die Knoten dieses 
Graphen sind dann die Situationen, die während des Übersetzens auftreten.  Wir
repräsentieren diese Situationen durch Terme der Form \\[0.1cm]
\hspace*{1.3cm} $\texttt{side}(M,\;K,\;B)$.
\\[0.1cm]
Ein solcher Term repräsentiert eine Situation, bei der auf der linken Seite des Ufers $M$ Missionare, $K$
Kannibalen und $B$ Boote sind.  Unsere Aufgabe besteht nun darin, das Prädikat
\texttt{edge/2} so zu implementieren, dass \\[0.1cm]
\hspace*{1.3cm} $\texttt{edge}(\;\texttt{side}(M_1,\;K_1,\;B_1),\;\texttt{side}(M_2,\;K_2,\;B_2)\;)$
\\[0.1cm]
genau dann wahr ist, wenn die Situation $\texttt{side}(M_1,\;K_1,\;B_1)$
durch eine Boots-Überfahrt in die Situation $\texttt{side}(M_2,\;K_2,\;B_2)$ überführt
werden kann und wenn zusätzlich die Missionare in der neuen Situation kein Problem bekommen.
Abbildung \ref{fig:missionare.pl} auf Seite \pageref{fig:missionare.pl}
zeigt ein \textsl{Prolog}-Programm, was das Rätsel löst.  Den von diesem Programm
berechneten Fahrplan finden Sie in Abbildung \ref{fig:missionare-solution} 
auf Seite \pageref{fig:missionare-solution}.
Wir diskutieren dieses Programm nun Zeile für Zeile.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    MMM   KKK   B      |~~~~~|                   
                       >  KK >
    MMM   K            |~~~~~|      B    KK      
                       <  K  <
    MMM   KK    B      |~~~~~|            K      
                       >  KK >
    MMM                |~~~~~|      B   KKK      
                       <  K  <
    MMM   K     B      |~~~~~|           KK      
                       > MM  >
    M     K            |~~~~~|      B    KK    MM
                       < M K <
    MM    KK    B      |~~~~~|            K     M
                       > MM  >
          KK           |~~~~~|      B     K   MMM
                       <  K  <
          KKK   B      |~~~~~|                MMM
                       >  KK >
          K            |~~~~~|      B    KK   MMM
                       <  K  <
          KK    B      |~~~~~|            K   MMM
                       >  KK >
                       |~~~~~|      B   KKK   MMM
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Fahrplan für Missionare und Kannibalen}
  \label{fig:missionare-solution}
\end{figure}      

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    solve :-
        find_path( side(3,3,1), side(0,0,0), [ side(3,3,1) ], Path ),
        nl, write('Lösung:' ), nl, nl,
        print_path(Path).
    
    % edge( +Point, -Point ).    
    % This clause describes rowing from the left side to the right side.
    edge( side( M, K, 1 ), side( MN, KN, 0 ) ) :-
        between( 0, M, MB ),    % MB missionaries in the boat
        between( 0, K, KB ),    % KB cannibals in the boat
        MB + KB >= 1,           % boat must not be empty
        MB + KB =< 2,           % no more than two passengers
        MN is M - MB,           % missionaries left on the left side
        KN is K - KB,           % cannibals left on the left
        \+ problem( MN, KN ).   % no problem may occur
    
    % This clause describes rowing from the right side to the left side.
    edge( side( M, K, 0 ), side( MN, KN, 1 ) ) :-
        otherSide( M, K, MR, KR ),
        edge( side( MR, KR, 1 ), side( MRN, KRN, 0 ) ),
        otherSide( MRN, KRN, MN, KN ).
    
    % otherSide( +Number, +Number, -Number, -Number ).
    otherSide( M, K, M_Other, K_Other ) :-
        M_Other is 3 - M,
        K_Other is 3 - K.
    
    % problem( +Number, +Number).
    problem(M, K) :- 
            problemSide(M, K).
    
    problem(M, K) :-
        otherSide( M, K, M_Other, K_Other ),
        problemSide(M_Other, K_Other).
        
    % problem( +Number, +Number).
    problemSide(Missionare, Kannibalen) :- 
            Missionare > 0, 
            Missionare < Kannibalen.
    
    % find_path( +Point, +Point, +List(Point), -List(Point) )
    find_path( X, X, _Visited, [ X ] ).
    
    find_path( X, Z, Visited, [ X | Path ]) :-
            edge( X, Y ),
            \+ member( Y, Visited ),
            find_path( Y, Z, [ Y | Visited ], Path ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Missionare und Kannibalen}
  \label{fig:missionare.pl}
\end{figure}      

\begin{enumerate}
\item Wir beginnen mit dem  Hilfs-Prädikat \texttt{otherSide/4}, das in den
      Zeilen 27 -- 29 implementiert ist.  Für eine vorgegebene Situation
      $\texttt{side}(M,K,B)$ berechnet der Aufruf \\[0.1cm]
      \hspace*{1.3cm} $\texttt{otherSide}(\; \texttt{side}(M, K, B),\; \textsl{OtherSide} \;)$
      \\[0.1cm] 
      einen Term, der die Situation am gegenüberliegenden Ufer beschreibt.
      Wenn an einen Ufer $M$ Missionare sind, so sind am anderen Ufer die restlichen
      Missionare und da es insgesamt $3$ Missionare gibt, sind das $3 - M$.
      Die Anzahl der Kannibalen am gegenüberliegenden Ufer wird analog berechnet. 
\item Das Prädikat \texttt{problem/2} in den Zeilen 32 -- 37 überprüft, ob es bei einer vorgegeben
      Anzahl von Missionaren und Kannibalen zu einem Problem kommt.
      Da das Problem entweder am linken oder am rechten Ufer auftreten kann,
      besteht die Implementierung aus zwei Klauseln.  Die erste Klausel prüft,
      ob es auf der Seite, an der $M$ Missionare und $K$ Kannibalen sind, zum Problem
      kommt.  Die zweite Klausel überprüft, ob es auf dem gegenüberliegenden
      Ufer zu einem Problem kommt.  Als Hilfs-Prädikat verwenden wir hier das Prädikat
      \texttt{problemSide/2}.  Dieses Prädikat ist in Zeile 40 implementiert
      und überprüft die Situation an einer Seite:  Falls sich auf einer Seite $M$ Missionare
      und $K$ Kannibalen befinden, so gibt es dann ein Problem, wenn die Zahl $M$ von 0
      verschieden ist und wenn zusätzlich $M < K$ ist.
\item Bei der Implementierung des Prädikats \texttt{edge/2} verwenden wir in den Zeilen 12
      und 13 das Prädikat \texttt{between/3}, das in dem \textsl{SWI-Prolog}-System 
      vordefiniert ist.  Beim Aufruf \\[0.1cm]
      \hspace*{1.3cm} $\texttt{between}(\textsl{Low}, \textsl{High}, N)$ \\[0.1cm]
      sind \textsl{Low} und \textsl{High} ganze Zahlen mit $\textsl{Low} \leq \textsl{High}$.
      Der Aufruf instantiert die Variable $N$ nacheinander mit den Zahlen \\[0.1cm]
      \hspace*{1.3cm} $\textsl{Low},\; \textsl{Low}+1,\; \textsl{Low}+2, \cdots, \;\textsl{High}$. \\[0.1cm]
      Beispielsweise gibt die Anfrage \\[0.1cm]
      \hspace*{1.3cm} \texttt{between(1,3,N), write(N), nl, fail.}  \\[0.1cm]
      nacheinander die Zahlen 1, 2 und 3 am Bildschirm aus.
    \item Die Implementierung des Prädikats \texttt{edge/2} besteht aus zwei Klauseln.  In
      der ersten Klausel betrachten wir den Fall, dass das Boot am linken Ufer ist.  In
      der Zeilen 12 generieren wir die Zahl der Missionare $\texttt{MB}$, die im Boot übersetzen
      sollen.  Diese Zahl $\texttt{MB}$ ist durch $\texttt{M}$ beschränkt, denn es können nur die Missionare
      übersetzen, die sich am linken Ufer befinden.  Daher benutzen wir das Prädikat
      \texttt{between/3} um eine Zahl zwischen 0 und $\texttt{M}$ zu erzeugen.  Analog generieren
      wir in Zeile 13 die Zahl $\texttt{KB}$ der Kannibalen, die im Boot übersetzen.  In Zeile 14
      testen wir, dass es mindestens einen Passagier gibt, der mit dem Boot übersetzt und
      in Zeile 15 testen wir, dass es höchstens zwei Passagiere sind.  In Zeile 16 und 17
      berechnen wir die Zahl $\texttt{MN}$ der Missionare und die Zahl $\texttt{KN}$ der Kannibalen, die
      nach der Überfahrt auf dem linken Ufer verbleiben und testen dann in Zeile 18, dass es
      für diese Zahlen kein Problem gibt.
      
      Die zweite Klausel befasst sich mit dem Fall, dass das Boot am rechten Ufer liegt.
      Wir hätten diese Klausel mit \textsl{Copy \& Paste} aus der vorhergehenden Klausel
      erzeugen können, aber es ist eleganter, diesen Fall auf den vorhergehenden Fall
      zurück zu führen.  Da da Boot nun auf der rechten Seite liegt, berechnen wir daher
      in Zeile 22 die Zahl $\texttt{MR}$ der Missionare auf der rechten Seite und die Zahl
      $\texttt{KR}$ der Kannibalen auf der rechten Seite.  Dann untersuchen wir die
      Situation $\mathtt{side}(\mathtt{MR}, \mathtt{KR}, 1)$, bei der $\texttt{MR}$
      Missionare und $\texttt{KR}$ Kannibalen am linken Ufer stehen.  Wenn diese so
      übersetzen können, dass nachher $\texttt{MRN}$ Missionare und $\texttt{KRN}$
      Kannibalen am linken Ufer stehen, dann können wir in Zeile 24 berechnen, wieviele
      Missionare und Kannibalen sich dann am gegenüberliegenden Ufer befinden.
\item In den Zeilen 1 -- 6 definieren wir nun das Prädikat \texttt{solve/0}, dessen Aufruf
      das Problem löst.  Dazu wird zunächst das Prädikat \texttt{find\_path/4} 
      mit dem Start-Knoten \texttt{side(3,3,1)} und dem Ziel-Knoten \texttt{side(0,0,0)}
      aufgerufen.   Der berechnete Pfad wird dann ausgegeben mit dem Prädikat
      \texttt{print\_path/1},
      dessen Implementierung wir hier aus Platzgründen nicht angegeben haben.
\end{enumerate}

\section{Das 8-Damen-Problem in \textsl{Prolog}}
In diesem Abschnitt zeigen wir, wie sich das 8-Damen-Problem in \textsl{Prolog} lösen lässt.  Wir beginnen mit
einer naiven Implementierung, bei der es zunächst darum geht, ein möglichst einfaches Programm zu erstellen,
bei dem die Effizienz noch keine Rolle spielt.  Die Grundidee bei dem Programm ist es, zunächst alle möglichen
Lösungen zu generieren und anschließend zu testen, ob es sich tatsächlich um eine Lösung handelt.
Dazu müssen wir zunächst entscheiden, wie wir eine mögliche Lösung des $n$-Damen-Problems in Prolog
repräsentieren wollen.  Wir entscheiden uns dafür, eine Lösung als eine Liste der Länge $n$ darzustellen,
wobei die einzelnen Elemente Zahlen aus der Menge $\{1, \cdots, n\}$ sind.  Diese Elemente
interpretieren wir als Positionen der Damen.  Konkret vereinbaren wir, dass  eine Liste der Form
\[ [ c_1, c_2, \cdots c_n ] \]
spezifiziert, dass die Dame, die sich in der ersten Zeile befindet, in der Spalte $c_1$ steht,
die Dame aus der zweiten Zeile steht in der Spalte $c_2$ und allgemein steht die Dame in der $i$-ten Zeile in
der Spalte $c_i$.  Beispielsweise repräsentieren wir die in Abbildung \ref{fig:queens-solution2} 
gezeigte Lösung des 8-Damen-Problems durch die Liste
\[ [ 4, 8, 1, 3, 6, 2, 7, 5 ]. \]


\begin{figure}[!ht]
  \centering
\hspace*{0.0cm}
\vbox{\offinterlineskip
   \hrule height1pt
   \hbox{\vrule width1pt\bigchess
         \vbox{\hbox{0Z0L0Z0Z}
               \hbox{Z0Z0Z0ZQ}
               \hbox{QZ0Z0Z0Z}
               \hbox{Z0L0Z0Z0}
               \hbox{0Z0Z0L0Z}
               \hbox{ZQZ0Z0Z0}
               \hbox{0Z0Z0ZQZ}
               \hbox{Z0Z0L0Z0}}%
         \vrule width1pt}
   \hrule height1pt}

  \caption{A solution of the eight queens puzzle.}
  \label{fig:queens-solution2}
\end{figure}

Abbildung \ref{fig:queens.pl} zeigt nun unser Programm zur Lösung des $n$-Damen-Problems.
\begin{enumerate}
\item Das Prädikat \texttt{queens/2} bekommt als erstes Argument die Anzahl $N$ der zu plazierenden 
      Damen übergeben.  Es ruft zunächst das Prädikat \texttt{generate\_list/3} auf, dass alle möglichen 
      Listen der Länge $N$ erzeugt, deren Elemente Zahlen aus der Menge $\{1, \cdots, N \}$ sind.
      Abschließend überprüft das Prädikat \texttt{is\_solution/1}, ob es sich bei der erzeugten Liste
      tatsächlich um eine Lösung des $N$-Damen-Problems handelt.
\item Der Aufruf \texttt{generate\_list(L, N, T)} setzt voraus, dass die Argumente $L$ und $N$ mit natürlichen
      Zahlen instanziiert sind.  Hierbei gibt $L$ die Länge der zu erzeugenden Liste an und $N$ spezifiziert,
      dass die einzelnen Elemente der zu erzeugenden Liste Elemente der Menge $\{1, \cdots, N\}$ sein sollen. 
      Die Variable $T$ enthält dann nach einem erfolgreichen Aufruf des Prädikats die erzeugte Liste.

      Die Implementierung erfolgt durch Rekursion in der Länge $L$ der zu erzeugenden Liste.
      Solange diese Länge positiv ist, wird zunächst durch den Aufruf von \texttt{between/3} eine Zahl $C$ aus
      der Menge $\{1, \cdots, N\}$ erzeugt.  Diese Zahl ist später das erste Element der erzeugten Liste.
      Anschließend wird durch einen rekursiven Aufruf eine Liste der Länge $L-1$ erzeugt, der im Ergebnis
      die vorher erzeugte Zahl $C$ vorangestellt wird.
\item Das Prädikat \texttt{is\_solution(L)} überprüft, ob die als Argument übergebene Liste $L$
      tatsächlich das $n$-Damen-Problem löst.  Diese Überprüfung erfolgt rekursiv:  Zunächst wir überprüft, ob
      die Dame aus der ersten Zeile eine der anderen Damen angreifen kann.  Abschließend wird rekursiv
      überprüft, ob auch die Damen in den weiteren Zeilen sicher stehen.
\item Das Prädikat \texttt{attack(C, X, L)} erhält drei Argumente.  Das erste Argument spezifiziert eine
      Zeile, in der eine Dame steht.  Das zweite Argument $X$ spezifiziert, wieviele Zeilen Abstand 
      zwischen der durch $C$ spezifizierten Dame und der ersten Dame der Liste $L$ liegen.        
      Falls die durch
      $C$ spezifizierte Dame in der Zeile $r_C$ steht und die Dame, die durch das erste Element der Liste 
      $L$ spezifiziert wird, in der Zeile $r_1$ steht, so gilt
      \[ X = r_1 - r_c. \]
      Das dritte Argument $L$ ist eine Liste von Positionen von Damen.
      Die einzelnen Klauseln der Implementierung sind jetzt wie folgt zu verstehen:
      \begin{enumerate}
      \item Falls die durch $C$ spezifizierte Dame in derselben Spalte steht wie die erste
            Dame der Liste $L$, dann kann die durch $C$ spezifizierte Dame offenbar diese Dame angreifen
            und der Aufruf von \texttt{attack/3} liefert \texttt{true}.
      \item Die nächste Klausel behandelt den Fall, dass die erste Dame der Liste $L$ in derselben 
            fallenden Diagonalen steht wie die durch $C$ spezifizierte Dame.
            Um die Implementierung zu verstehen ist nur zu beachten, dass die Spalten der fallenden Diagonale,
            die von $C$ ausgeht, sich dadurch ergeben, dass wir die Spalte für jede neue Zeile um 1 hochzählen
            müssen.  Das erklärt den Term \texttt{C + X}.
      \item Analog behandelt die dritte Klausel den Fall, dass die erste Dame der Liste $L$ in derselben 
            steigenden  Diagonalen steht wie die durch $C$ spezifizierte Dame.
            Für eine steigende Diagonale müssen wir die Spalte für jede weitere Zeile um 1 dekrementieren.
            Das erklärt den Term \texttt{C - X}.
      \item Die letzte Klausel prüft schließlich rekursiv, ob die Dame in Spalte $C$ eine der restlichen Damen 
            angreifen kann.
      \end{enumerate}
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    % queens(+Number, -List(Number).    
    queens(N, S) :-
        generate_list(N, N, S),
        is_solution(S).
    
    % generate_list(+Number, +Number, -List(Number)).
    generate_list(L, N, [ C | T ]) :-
        L > 0,
        between(1, N, C),
        L1 is L - 1,
        generate_list(L1, N, T).
  
    generate_list(0, _, []).
    
    % is_solution(+List(Number)).
    is_solution([ H | T ]) :-
        \+ attack(H, 1, T),
        is_solution(T).
    
    is_solution([]).
    
    % attack(+Number, +Number, +List(Number)).
    attack(C, _, [ C | _T ]).  % same column
    
    attack(C, X, [ H | _T ]) :-
        H is C + X.
    
    attack(C, X, [ H | _T ]) :-
        H is C - X.
    
    attack(C, X, [ _H | T ]) :-
        X1 is X + 1,
        attack(C, X1, T).
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein naives Programm zur Lösung des $n$-Damen-Problems.}
\label{fig:queens.pl}
\end{figure}

Das Programm ist ineffizient, weil die Tests und die Überprüfungen zu stark getrennt sind.  So wird bei der
Lösung des 8-Damen-Problems beispielsweise zunächst die Liste $[1,1,1,1,1,1,1,1]$ erzeugt und geprüft, ob
diese Liste das Problem löst.  Nachdem dieser Versuch scheitert, wird anschließend die Liste 
$[1,1,1,1,1,1,1,2]$ erzeugt, obwohl eigentlich schon klar ist, dass diese Liste keine Lösung bringen kann,
denn schon die ersten beiden Positionen der ursprünglichen Liste verhindern eine Lösung.
Die wesentliche Idee die Effizienz dieses Programms zu steigern besteht darin, so früh wie möglich zu testen
ob eine bestimmte Position überhaupt in Frage kommt.  In dem in
Abbildung \ref{fig:queens-faster.pl} gezeigten Programm wird diese Idee dadurch umgesetzt,
dass wir ein dreistelliges Prädikat \texttt{queens/3} implementieren, das in der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{queens(N, Positioned, Solution)}
\\[0.2cm]
aufgerufen wird.  Hier bezeichnet \texttt{N} die Anzahl der zu positionierenden Damen, während
\texttt{Positioned} eine Liste von Damen angibt, die bereits gesetzt sind und von der bekannt ist, dass die
dort gesetzten Damen sich nicht gegenseitig angreifen können.  Die Implementierung dieses Prädikats besteht
aus zwei Klauseln.
\begin{enumerate}
\item  In der ersten Klausel der Implementierung von
       \texttt{queens/3} überprüfen wir zunächst, ob überhaupt noch weitere Damen zu setzen sind.  Ist dies 
       der Fall, so liefert das Prädikat \texttt{between/3} per Backtracking alle möglichen Positionen für die
       nächste zu setzende Dame.  Der Aufruf von \texttt{attack/3} überprüft dann, ob die neue Dame in
       Spalte $C$ eine der bereits in \texttt{Positioned} gesetzten Damen angreifen kann.  Falls dies nicht
       der Fall ist, wird diese Dame den Damen aus der Liste \texttt{Positioned} vorangestellt und es wird
       rekursiv versucht das Problem zu lösen.
\item Die zweite Klausel greift, wenn die Liste \texttt{Positioned} der bereits gesetzten Damen das Problem
      löst.   Dies ist der Fall wenn diese Liste bereits $N$ Damen enthält.
\end{enumerate}
Die Implementierung ist insgesamt effizienter weil jedesmal, wenn eine Dame gesetzt wird, überprüft wird, ob
dies zu Problemen mit den bereits gesetzten Damen führen kann.  Dadurch werden Teile des Suchbaums, die keine
Lösung enthalten können, frühzeitig abgeschnitten.
\pagebreak 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    % queens(+Number, -List(Number).
    queens(N, S) :-
        queens(N, [], S).
    
    % queens(+Number, +List(Number), -List(Number)).
    queens(N, Positioned, Solution) :-
        length(Positioned, M),
        M < N,
        between(1, N, C),
        \+ attack(C, 1, Positioned),
        queens(N, [C | Positioned], Solution).
    
    queens(N, Positioned, Positioned) :-
        length(Positioned, M),
        M == N.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine effizientere Lösung für das $n$-Damen-Problem.}
\label{fig:queens-faster.pl}
\end{figure}

\section{Der Cut-Operator}
Wir haben ein Prädikat als \emph{funktional} definiert,
wenn wir die einzelnen Argumente klar in Eingabe- und Ausgabe-Argumente
aufteilen können.  Wir nennen ein Prädikat \emph{deterministisch} wenn es funktional ist
und wenn außerdem zu jeder Eingabe höchstens eine Ausgabe berechnet
wird.  Diese zweite Forderung ist durchaus nicht immer erfüllt.  Betrachten wir die ersten
beiden Fakten zur Definition des Prädikats \texttt{mix/3}:
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    mix( [], Xs, Xs ).    
    mix( Xs, [], Xs ).
\end{Verbatim}
Für die Anfrage ``\texttt{mix([], [], L)}'' können beide Fakten verwendet werden.
Das Ergebnis ist zwar immer dasselbe, nämlich \texttt{L = []}, es wird aber zweimal ausgegeben:
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    ?- mix([],[],L).
    
    L = [] ;
    
    L = [] 
\end{Verbatim}
Dies kann zu Ineffizienz führen.  Aus diesem Grunde gibt es in \textsl{Prolog} den
Cut-Operator ``\texttt{!}''.  Mit diesem Operator ist es möglich, redundante Lösungen aus
dem Suchraum heraus zu schneiden.  Schreiben wir die ersten beiden Klauseln der
Implementierung von \texttt{mix/3} in der Form 
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    mix( [], Xs, Xs ) :- !.
    mix( Xs, [], Xs ) :- !.
\end{Verbatim}
so wird auf die Anfrage  ``\texttt{mix([], [], L)}'' die Lösung \texttt{L = []} nur noch
einmal generiert.  Ist allgemein eine Regel der Form \\[0.1cm]
\hspace*{1.3cm} $P \;\texttt{:-}\; Q_1, \cdots, Q_m, \texttt{!}, R_1, \cdots, R_k$ \\[0.1cm]
gegeben, und gibt es weiter eine Anfrage $A$, so dass $A$ und $P$  unifizierbar sind, so
wird die Anfrage $A$ zunächst zu der Anfrage \\[0.1cm]
\hspace*{1.3cm} $Q_1\mu, \cdots, Q_m\mu, \texttt{!}, R_1\mu, \cdots, R_k\mu$ \\[0.1cm]
reduziert.  Außerdem wird ein Auswahl-Punkt gesetzt, wenn es noch weitere Klauseln gibt,
deren Kopf mit $A$ unifiziert werden könnte.
Bei der weiteren Abarbeitung dieser Anfrage gilt folgendes:
\begin{enumerate}
\item Falls bereits die Abarbeitung einer Anfrage der Form \\[0.1cm]
      \hspace*{1.3cm} 
      $Q_i\sigma, \cdots, Q_m\sigma, \texttt{!}, R_1\sigma, \cdots, R_k\sigma$ \\[0.1cm]
      für ein $i\in\{1,\cdots,m\}$ scheitert, so wird der Cut nicht erreicht und hat keine
      Wirkung.
\item Eine Anfrage der Form \\[0.1cm]
      \hspace*{1.3cm} 
      $\texttt{!}, R_1\sigma, \cdots, R_k\sigma$ \\[0.1cm]
      wird reduziert zu \\[0.1cm]
      \hspace*{1.3cm} 
      $R_1\sigma, \cdots, R_k\sigma$. \\[0.1cm]
      Dabei werden alle Auswahl-Punkte, die bei der Beantwortung der Teilanfragen
      $Q_1, \cdots, Q_m$ gesetzt worden sind, gelöscht.  Außerdem wird ein eventuell bei
      der Reduktion der Anfrage $A$ auf die Anfrage \\[0.1cm]
      \hspace*{1.3cm} $Q_1\mu, \cdots, Q_m\mu, \texttt{!}, R_1\mu, \cdots, R_k\mu$
      \\[0.1cm]
      gesetzter Auswahl-Punkte gelöscht.
\item Sollte später die Beantwortung der Anfrage \\[0.1cm]
      \hspace*{1.3cm} $R_1\sigma, \cdots, R_k\sigma$. \\[0.1cm]
      scheitern, so scheitert auch die Beantwortung der Anfrage $A$.
\end{enumerate}
Zur Veranschaulichung betrachten wir ein Beispiel.
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    q(Z) :- p(Z).
    q(1).

    p(X) :- a(X), b(X), !, c(X,Y), d(Y).    
    p(3).
    
    a(1).    a(2).    a(3).
    
    b(2).    b(3).
    
    c(2,2).  c(2,4).
    
    d(3).
\end{Verbatim}
Wir verfolgen die Beantwortung der Anfrage \ \texttt{q(U)}. 
\begin{enumerate}
\item Zunächst wird versucht \texttt{q(U)} mit dem Kopf der ersten Klausel 
      des Prädikats \texttt{q/1}  zu unifizieren.  Dabei wird \texttt{Z} mit
      \texttt{U} instantiert und die Anfrage wird reduziert zu \\[0.1cm]
      \hspace*{1.3cm} \texttt{p(U)}. \\[0.1cm]
      Da es noch eine weiter Klausel für das Prädikat \texttt{q/1} gibt, die zur
      Beantwortung der Anfrage q(U) in Frage kommt, setzen wir Auswahl-Punkt Nr.~1.
\item Jetzt wird versucht \texttt{p(U)} mit \texttt{p(X)} zu unifizieren.  Dabei
      wird die Variable \texttt{X} an \texttt{U} gebunden und die ursprüngliche Anfrage
      wird reduziert zu der Anfrage \\[0.1cm]
      \hspace*{1.3cm}  
      \texttt{a(U), b(U), !, c(U,Y), d(Y)}. \\[0.1cm]
      Außerdem wird an dieser Stelle Auswahl-Punkt Nr.~2 gesetzt, denn die zweite Klausel
      des Prädikats \texttt{p/1} kann ja ebenfalls mit der ursprünglichen Anfrage unifiziert
      werden. 
\item Um die Teilanfrage \texttt{a(U)} zu beantworten, wird \texttt{a(U)} mit
      \texttt{a(1)} unifiziert.  Dabei wird \texttt{U} mit 1 instantiiert und die Anfrage wird reduziert zu \\[0.1cm]
      \hspace*{1.3cm} 
      \texttt{b(1), !, c(1,Y), d(Y)}. \\[0.1cm]
      Da es für das Prädikat \texttt{a/1} noch weitere Klauseln gibt, wird Auswahl-Punkt Nr.~3
      gesetzt.
\item Jetzt wird versucht, die Anfrage \\[0.1cm]
      \hspace*{1.3cm}    \texttt{b(1), !, c(1,Y), d(Y)}. \\[0.1cm]
      zu lösen.  Dieser Versuch scheitert jedoch, da sich die für das Prädikat \texttt{b/1}
      vorliegenden Fakten nicht mit \texttt{b(1)} unifizieren lassen.
\item Also springen wir zurück zum letzten Auswahl-Punkt (das ist Auswahl-Punkt Nr.~3)
      und machen die Instantiierung 
      $\texttt{U} \mapsto 1$ rückgängig.  Wir haben jetzt also wieder das Ziel \\[0.1cm]
      \hspace*{1.3cm} \texttt{a(U), b(U), !, c(U,Y), d(Y)}. 
\item Diesmal wählen wir das Fakt \texttt{a(2)} um es mit \texttt{a(U)} zu unifizieren.  Dabei wird \texttt{U} mit
      2 instantiiert und wir haben die  Anfrage \\[0.1cm]
      \hspace*{1.3cm} \texttt{b(2), !, c(2,Y), d(Y)}. \\[0.1cm]
      Da es noch eine weiter Klausel für das Prädikat \texttt{a/1} gibt, setzen wir 
      Auswahl-Punkt Nr.4 an dieser Stelle.
\item Jetzt unifizieren wir  die Teilanfrage \texttt{b(2)} mit der ersten Klausel für das Prädikat
      \texttt{b/1}.  Die verbleibende Anfrage ist \\[0.1cm]
      \hspace*{1.3cm} \texttt{!, c(2,Y), d(Y)}. 
\item Diese Anfrage wird reduziert zu \\[0.1cm]
      \hspace*{1.3cm}  \texttt{c(2,Y), d(Y)}. \\[0.1cm]
      Außerdem werden bei diesem Schritt die Auswahl-Punkte Nr.~2 und Nr.~4 gelöscht.
\item Um diese Anfrage zu beantworten, unifizieren wir \texttt{c(2,Y)} mit dem Kopf der
      ersten Klausel für das Prädikat \texttt{c/2}, also mit \texttt{c(2,2)}.
      Dabei erhalten wir die Instantiierung
      $\mathtt{Y} \mapsto 2$.  Die Anfrage ist damit reduziert zu \\[0.1cm]
      \hspace*{1.3cm}  \texttt{d(2)}. \\[0.1cm]
      Außerdem setzen wir an dieser Stelle Auswahl-Punkt Nr.~5, denn das Prädikat
      \texttt{c/2} hat ja noch eine weitere Klausel, die in Frage kommt.
\item Die Anfrage ``\texttt{d(2)}'' scheitert.  Also springen wir zurück zum Auswahl-Punkt
      Nr.~5 und machen die Instantiierung $\mathtt{Y} \mapsto 2$ rückgängig.  Wir haben
      also wieder die Anfrage \\[0.1cm]
      \hspace*{1.3cm}  \texttt{c(2,Y), d(Y)}. 
\item Zur Beantwortung dieser Anfrage nehmen wir nun die zweite Klausel der
      Implementierung von \texttt{c/2} und erhalten die Instantiierung 
      $\mathtt{Y} \mapsto 4$.  Die verbleibende Anfrage lautet dann \\[0.1cm]
      \hspace*{1.3cm} \texttt{d(4)}.
\item Da sich \texttt{d(4)} und \texttt{d(3)} nicht unifizieren lassen,
      scheitert diese Anfrage.  Wir springen jetzt zurück zum Auswahl-Punkt Nr.~1 und
      machen die Instantiierung $\mathtt{U} \mapsto \mathtt{Z}$ rückgängig.  Die Anfrage
      lautet also wieder \\[0.1cm]
      \hspace*{1.3cm} \texttt{p(U)}.
\item Wählen wir nun die zweite Klausel der Implementierung von \texttt{q/1},
      so müssen wir \texttt{q(U)} und \texttt{q(1)} unifizieren.  Diese Unifikation ist
      erfolgreich und wir erhalten die Instantiierung $\mathtt{U} \mapsto 1$, die die Anfrage beantwortet.
\end{enumerate}

\subsection{Verbesserung der Effizienz von \textsl{Prolog}-Programmen durch den Cut-Operator}
In der Praxis wird der Cut-Operator eingesetzt, um überflüssige Auswahl-Punkte zu
entfernen und dadurch die Effizienz eines Programms zu steigern.  Als Beispiel
betrachten wir eine Implementierung des Algorithmus 
``\emph{Sortieren durch Vertauschen}'' (engl.~\emph{bubble sort}).
Wir spezifizieren diesen Algorithmus zunächst durch bedingte Gleichungen.  Dabei 
benutzen wir die Funktion \\[0.1cm]
\hspace*{1.3cm} 
$\texttt{append}: \textsl{List}(\textsl{Number}) \times \textsl{List}(\textsl{Number}) \rightarrow \textsl{List}(\textsl{Number})$
\\[0.1cm]
Der Aufruf $\texttt{append}(l_1, l_2)$ liefert eine Liste, die aus allen Elementen von
$l_1$ gefolgt von den Elementen aus $l_2$ besteht.  In dem \textsl{SWI-Prolog}-System ist
ein entsprechendes Prädikat \texttt{append/3} implementiert.  Die Implementierung dieses
Prädikats deckt sich mit der Implementierung des Prädikats \texttt{concat/3}, die wir in
einem früheren Abschnitt vorgestellt hatten.  

Außerdem benutzen wir noch das Prädikat \\[0.1cm]
\hspace*{1.3cm} 
$\texttt{ordered}: \textsl{List}(\textsl{Number}) \rightarrow \mathbb{B}$, \\[0.1cm]
das überprüft, ob eine Liste geordnet ist.
Die bedingten Gleichungen
zur Spezifikation der Funktion \\[0.1cm]
\hspace*{1.3cm} 
$\texttt{bubble\_sort}: \textsl{List}(\textsl{Number}) \rightarrow \textsl{List}(\textsl{Number})$
\\[0.1cm]
lauten nun:
\begin{enumerate}
\item $\mathtt{append}(l_1, [x,y|l_2], l) \wedge x > y \rightarrow \mathtt{bubble\_sort}(l) = \mathtt{bubble\_sort}(\mathtt{append}(l_1, [y,x|l_2]))$

      Wenn die Liste $l$ in zwei Teile $l_1$ und $[x,y|l_2]$ zerlegt werden kann
      und wenn weiter $x>y$ ist, dann vertauschen wir die Elemente $x$ und $y$
      und sortieren die so entstandene Liste rekursiv.
\item $\mathtt{ordered}(l) \rightarrow \mathtt{bubble\_sort}(l) = l$

      Wenn die Liste $l$ bereits sortiert ist, dann kann die Funktion
      $\mathtt{bubble\_sort}$ diese Liste unverändert als Ergebnis zurück geben.
\end{enumerate}
Die Gleichungen um das Prädikat \texttt{ordered} zu spezifizieren lauten:
\begin{enumerate}
\item $\mathtt{ordered}([]) = \mathtt{true}$

      Die leere Liste ist offensichtlich sortiert.
\item $\mathtt{ordered}([x]) = \mathtt{true}$

      Eine Liste, die nur aus einem Element besteht, ist ebenfalls sortiert.
\item $x \leq y \rightarrow \mathtt{ordered}([x,y|r]) = \mathtt{ordered}([y|r])$.

      Eine Liste der Form $[x,y|r]$ ist sortiert, wenn $x \leq y$ ist und
      wenn außerdem die Liste $[y|r]$ sortiert ist.
\end{enumerate}

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    bubble_sort( L, Sorted ) :-
        append( L1, [ X, Y | L2 ], L ),
        X > Y,
        append( L1, [ Y, X | L2 ], Cs ),
        bubble_sort( Cs, Sorted ).
    
    bubble_sort( Sorted, Sorted ) :-
        is_ordered( Sorted ).
    
    
    is_ordered( [] ).
    
    is_ordered( [ _ ] ).
    
    is_ordered( [ X, Y | Ys ] ) :-
        X < Y,
        is_ordered( [ Y | Ys ] ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Der Bubble-Sort Algorithmus}
  \label{fig:bubble_sort}
\end{figure}

Abbildung \ref{fig:bubble_sort} zeigt die Implementierung des Bubble-Sort Algorithmus in
\textsl{Prolog}.  In Zeile 2 wird die als Eingabe gegebene Liste \texttt{L} in die beiden
Liste \texttt{L1} und \texttt{[X, Y | L2]} zerlegt.  Da es im Allgemeinen mehrere
Möglichkeiten gibt,  eine Liste in zwei Teillisten zu zerlegen, wird hierbei ein
Auswahl-Punkt gesetzt.  Anschließend wird geprüft, ob \texttt{Y} kleiner als \texttt{X}
ist.  Wenn dies der Fall ist, wird mit \texttt{append/3} die neue Liste 
\\[0.1cm]
\hspace*{1.3cm} $\mathtt{append(L_1, [Y,X|L_2])}$ \\[0.1cm]
gebildet und diese Liste wird rekursiv sortiert.  Wenn es nicht möglich ist,
die Liste \texttt{L} so in zwei Listen \texttt{L1} und \texttt{[X, Y | L2]} zu zerlegen,
dass \texttt{Y} kleiner als \texttt{X} ist, dann muss die Liste \texttt{L} schon sortiert
sein.  In diesem Fall greift die zweite Klausel, die allerdings noch Überprüfen muss, ob
\texttt{L} tatsächlich sortiert ist, denn sonst könnte beim Backtracking eine falsche
Lösung berechnet werden.

Das Problem bei dem obigen Programm ist die Effizienz.  Aufgrund der vielen Möglichkeiten
eine Liste zu zerlegen, wird beim Backtracking immer wieder dieselbe Lösung generiert. 
Beispielsweise liefert die Anfrage \\[0.1cm]
\hspace*{1.3cm} \texttt{bubble\_sort( [ 4, 3, 2, 1 ], L ), write(L), nl, fail.} \\[0.1cm]
16 mal dieselbe Lösung.  Abbildung \ref{fig:bubble_sort_cut} zeigt eine Implementierung,
bei der nur eine Lösung berechnet wird.  Dies wird durch den Cut-Operator in Zeile 4
erreicht.   Ist einmal eine Zerlegung der Liste \texttt{L} in \texttt{L1} und 
\texttt{[X, Y | L2]} gefunden, bei der \texttt{Y} kleiner als \texttt{X} ist, so bringt es
nichts mehr, nach anderen Zerlegungen zu suchen, denn die ursprünglich gegebene Liste
\texttt{L} lässt sich ja auf jeden Fall dadurch sortieren, dass rekursiv die Liste \\[0.1cm]
\hspace*{1.3cm} $\mathtt{append(L_1, [Y,X|L_2])}$ \\[0.1cm]
sortiert wird.  Dann kann auch der Aufruf der Prädikats \texttt{ordered/1} im Rumpf der zweiten
Klausel des Prädikats \texttt{bubble\_sort} entfallen, denn diese wird beim Backtracking
ja nur dann erreicht, wenn es keine Zerlegung der Liste \texttt{L} in  \texttt{L1} und 
\texttt{[X, Y | L2]} gibt, bei der \texttt{Y} kleiner als \texttt{X} ist.  Dann muss aber
die Liste \texttt{L} schon sortiert sein.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    bubble_sort( List, Sorted ) :-
        append( L1, [ X, Y | L2 ], List ),
        X > Y,
        !,
        append( L1, [ Y, X | L2 ], Cs ),
        bubble_sort( Cs, Sorted ).
    
    bubble_sort( Sorted, Sorted ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Effiziente Implementierung des  Bubble-Sort Algorithmus}
  \label{fig:bubble_sort_cut}
\end{figure}

Wenn wir bei der Entwicklung eines \textsl{Prolog}-Programms von bedingten Gleichungen
ausgehen, dann gibt es ein einfaches Verfahren, um das entstandene
\textsl{Prolog}-Programm durch die Einführung von Cut-Operator effizienter zu machen:
Der Cut-Operator sollte nach den Tests, die vor dem Junktor ``$\rightarrow$'' stehen,
gesetzt werden.  Wir erläutern dies durch ein Beispiel:  Unten sind noch einmal die
Gleichungen zur Spezifikation des Algorithmus ``\emph{Sortieren durch Mischen}'' wiedergegeben.
\begin{enumerate}
\item $\mathtt{odd}([]) = []$.
\item $\mathtt{odd}([h|t]) = [h|\mathtt{even}(t)]$.
\item $\mathtt{even}([]) = []$.
\item $\mathtt{even}([h|t]) = \mathtt{odd}(t)$.
\item $\mathtt{merge}([], l) = l$.
\item $\mathtt{merge}(l, []) = l$.
\item $x \leq y \rightarrow \mathtt{merge}([x|s], [y|t]) = [x|\mathtt{merge}(s, [y|t])]$.
\item $x  >   y \rightarrow \mathtt{merge}([x|s], [y|t]) = [y|\mathtt{merge}([x|s], t)]$.
\item $\mathtt{sort}([]) = []$.
\item $\mathtt{sort}([x]) = [x]$.
\item $\mathtt{sort}([x,y|t]) = \mathtt{merge}( \mathtt{sort}(\mathtt{odd}([x,y|t])), \mathtt{sort}(\mathtt{even}([x,y|t])))$.
\end{enumerate}
Das \textsl{Prolog}-Programm mit Cut-Operatoren sieht dann so aus wie in Abbildung
\ref{fig:merge-sort-cut} gezeigt.  Nur die Gleichungen 7.~und 8.~haben Bedingungen, bei
allen anderen Gleichungen gibt es keine Bedingungen.  Bei den Gleichungen 7.~und 8.~wird
der Cut-Operator daher nach dem Test der Bedingungen gesetzt, bei allen anderen Klauseln
wird der Cut-Operator dann am Anfang des Rumpfes gesetzt.

\begin{figure}[!h]
  \centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm
                ]
    % odd( +List(Number), -List(Number) ).    
    odd( [], [] ) :- !.    
    odd( [ X | Xs ], [ X | L ] ) :-
        !,
        even( Xs, L ).

    % even( +List(Number), -List(Number) ).
    even( [], [] ) :- !.
    even( [ _X | Xs ], L ) :-
        !,
        odd( Xs, L ).
    
    % merge( +List(Number), +List(Number), -List(Number) ).
    mix( [], Xs, Xs ) :- !.    
    mix( Xs, [], Xs ) :- !.
    mix( [ X | Xs ], [ Y | Ys ], [ X | Rest ] ) :-
        X =< Y,
        !,
        mix( Xs, [ Y | Ys ], Rest ).
    mix( [ X | Xs ], [ Y | Ys ], [ Y | Rest ] ) :-
        X > Y,
        !,
        mix( [ X | Xs ], Ys, Rest ).
    
    % merge_sort( +List(Number), -List(Number) ).
    merge_sort( [], [] ) :- !.
    merge_sort( [ X ], [ X] ) :- !.
    merge_sort( [ X, Y | Rest ], Sorted ) :-
        !,
        odd(  [ X, Y | Rest ], Odd  ),
        even( [ X, Y | Rest ], Even ),
        merge_sort( Odd,  Odd_Sorted  ),
        merge_sort( Even, Even_Sorted ),
        mix( Odd_Sorted, Even_Sorted, Sorted ).
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{Sortieren durch Mischen mit Cut-Operatoren.}
  \label{fig:merge-sort-cut}
\end{figure}

Analysieren wir das obige Programm genauer, so stellen wir fest, dass viele der
Cut-Operatoren im Grunde überflüssig sind.  Beispielsweise kann immer nur eine der beiden
Klauseln, die das Prädikat \texttt{odd/2} implementieren, greifen, denn entweder ist die
eingegebene Liste leer oder nicht.  Also sind die Cut-Operatoren in den Zeilen 2 und 4
redundant.  Andererseits stören sie auch nicht, so dass es für die Praxis das einfachste
sein dürfte Cut-Operatoren stur nach dem oben angegebenen Rezept zu setzen.

\section{Literaturhinweise}
Für eine umfangreiche und dem Thema angemessene Darstellung der Sprache \textsl{Prolog} 
fehlt in der einführenden Vorlesung leider die Zeit.  Daher wird dieses Thema in einer
späteren Vorlesung auch wieder aufgegriffen.  Den Lesern, die ihre Kenntnisse jetzt schon
vertiefen wollen, möchte ich auf die folgende Hinweise auf die Literatur geben:
\begin{enumerate}
\item \emph{The Art of Prolog} von Leon Sterling und Ehud Shapiro \cite{sterling:94}.
      Dieses Werk ist ein ausgezeichnete Lehrbuch, das auch für den Anfänger gut lesbar ist.
\item \emph{Prolog Programming for Artificial Intelligence} von Ivan Bratko
      \cite{bratko:90}.  Neben der Sprache \textsl{Prolog} führt dieses Buch auch in die
      künstliche Intelligenz ein.
\item \emph{Foundations of Logic Programnming}   von J.~W.Lloyd \cite{lloyd:87}
      beschreibt die theoretischen Grundlagen der Sprache \textsl{Prolog}.
\item \emph{Prolog: The Standard} von Pierre Deransart, Abdel Ali Ed-Dbali und Laurent
      Cervoni \cite{deransart:96} gibt den ISO-Standard für die Sprache
      \textsl{Prolog} wieder.
\item \emph{SWI-Prolog 5.6 Reference Manual} von Jan Wielemaker \cite{wielemaker:06}
      beschreibt das SWI-Prolog-System.  Dieses Dokument ist im Internet unter der Adresse 
      \\[0.1cm]
      \hspace*{1.3cm}      
      \texttt{http://www.swi-prolog.org/dl-doc.html} 
      \\[0.1cm]
      verfügbar.
\end{enumerate}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "logic"
%%% End: 
