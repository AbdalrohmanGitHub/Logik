
// compute the set of all partitions of m recursively
partitions := procedure(s) {
    if (#s == 1) {
        return { { s } };
    }
    x   := from(s);
    all := partitions(s);
    return      { p + { { x } } : p in all }
           + +/ { { { m + { x } } + (p - { m }): m in p } : p in all };
};

// transform a partion into an equivalence
partion2Equivalence := procedure(p) {
    return { [x, y] : m in p, x in m, y in m };
};

for (n in [1 .. 10]) {
    print("partitions for n = $n$:");
    all := partitions({1..n});
    for (p in all) {
        print(p);
        print(partion2Equivalence(p));
    }
    print("number of partitions for n = $n$: $#all$\n");

}
