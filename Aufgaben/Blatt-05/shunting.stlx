/////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// The following procedures find a path in a given graph if there is one.     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

findPath := procedure(start, goal, R) {
    paths    := { [start] };
    states   := { start };   // reachable states
    explored := {};          // explored states
    while (states != explored) {
        explored := states;
        paths    := { l : l in pathProduct(paths, R) | !(l[-1] in states) };
        paths    := clean(paths);
        states   += { l[-1] : l in paths };  
        if (goal in states) {
            return arb({ l : l in paths | l[-1] == goal });
        }
    }
};

// The procedure call product(p, q) computes the path product p * q.
pathProduct := procedure(p, q) {
    return { x + [ y[2] ] : x in p, y in q | x[-1] == y[1] };
};

// remove redundant paths
clean := procedure(paths) {
    states := { k[-1] : k in paths };
    return { arb({ k : k in paths | k[-1] == s }) : s in states };
};
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// The following procedure are only needed to print the solution in a   //
// readable way.                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////    

// This procedure prints the solution.
printPath := procedure(path) {
    print("Solution:\n");
    for ([a, b, c] in path) {
        printState(a, b, c);
    }
};

printState := procedure(a, b, c) {
    print("A: ", a, "; B: ", b, "; C: ", c);
}; 

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Some auxilliary procedure.                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Given a set s, this procedure returns a set containing all lists that contain
// each element of s exactly once. 
// Example: 
// toList({1,2,3}) = {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]}
toList := procedure(s) {
    if (s == {}) {
        return { [] };
    }
    return { [ x ] + l : x in s, l in toList(s - { x }) };
};

// This procedure computes the inverse of the binary relation R.
// Example:
// inverse({ ["a", 1], ["b", 2] }) = {[1, "a"], [2, "b"]}
inverse := procedure(r) {
    return { [ y, x ] : [ x, y ] in r };	
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// The definition of the relation describing the problem starts here.         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

All := { 0 .. 3 };

//  { [a,b,c] : ???
Partitions := { [A, B, C] : A in 2 ** All, B in 2 ** All, C in 2 ** All 
                          | #A + #B + #C == #All && A + B + C == All 
              };
print("Number of partitions: $#Partitions$");
States     := { [LA, LB, LC]
              : [A, B, C] in Partitions, 
                LA in toList(A), LB in toList(B), LC in toList(C) 
              };
print("Number of states: $#States$");
print("Mögliche Zustände:\n");
for ([A, B, C] in States) {
    printState(A, B, C);
}
print("\n");

// RacEast beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Osten
// zum Gleis C fährt.
RacEast    := { [ [A, B, C], [A[1..k-1], B, C + reverse(A[k..])] ] 
              : [A,B,C] in States, k in {1 .. #A}
              | 0 in A[k..]
              };
print("Number of trips from A to C via the eastern track: $#RacEast$");
print("RacEast:\n");
for ([[A1, B1, C1], [A2, B2, C2]] in RacEast) { 
    printState(A1, B1, C1);
    printState(A2, B2, C2);
    print();
}
print("\n");

// RacWest beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Westen
// zum Gleis C fährt.
RacWest    := { [ [A, B, C], [A[k+1..], B, reverse(A[1..k]) + C ] ] 
              : [A, B, C] in States, k in {1 .. #A}
              | 0 in A[1..k]
              };
print("Number of trips from A to C via the western track: $#RacWest$");
print("RACwest:\n");
for ([[A1, B1, C1], [A2, B2, C2]] in RacWest) {
    printState(A1, B1, C1);
    printState(A2, B2, C2);
    print();
}
print("\n");

Rac := RacEast + RacWest;
Rca := inverse(Rac);
// RBC beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis B
// zum Gleis C fährt.
Rbc        := { [ [A, B, C], [A, B[1..k-1], B[k..] + C] ] 
              : [A, B, C] in States, k in {1 .. #B }
              | 0 in B[k..]
              };
print("Rbc:\n");
for ([[A1, B1, C1], [A2, B2, C2]] in Rbc) {
    printState(A1, B1, C1);
    printState(A2, B2, C2);
    print();
}
print("\n");

Rcb        := inverse(Rbc);
// R ist die Menge aller Verbindungen zwischen Punkten.
R := Rac + Rca + Rbc + Rcb;

print("#R = ", #R);

// Am Anfang sind die Waggons auf Gleis A, die Lokomotive ist auf Gleis B.
start := [ [1,2,3], [0], [] ];
// Am Ende sollen die Waggons alle in der Reihenfolge 3,1,2 auf Gleis C
// stehen und die Lokomotive soll wieder auf Gleis B stehen.
goal := [ [], [0], [3,1,2] ];
// Berechne alle möglichen Pfade
Path := findPath(start, goal, R);
// und gebe diesen Schritt für Schritt aus.
print(#Path);
printPath(Path);

