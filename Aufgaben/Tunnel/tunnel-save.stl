-- Vier Personen, Chef, Chuck, Norbert und Claudia, müssen eine Tunnel durchqueren.  Der Tunnel
-- ist so eng, dass immer nur zwei Personen gleichzeitig hindurch können.  Außerdem braucht
-- man zum Durchqueren eine Taschen-Lampe.  Die vier haben aber zusammen nur eine
-- Taschen-Lampe.  Die Zeiten, die Chef, Chuck, Norbert und Claudia zum Durchqueren benötigen
-- sind 5 Minuten, 10 Minuten, 20 Minuten und 25 Minuten.  Berechnen Sie einen Plan zum
-- Durchqueren des Tunnels, der die benötigte Zeit minimiert.

-- Lösung von Johannes Unterstein, edited by Karl Stroetmann.
program main; 
    All := { "Chef", "Chuck", "Norbert", "Claudia", "Lampe" };
    -- P ist die Menge aller Punkte.
    P := pow All;
    -- von links nach Rechts
    R1 := {[S, S-T, duration(T)]: S in P, T in pow S | #T in {2, 3} and "Lampe" in T };
    -- Von rechts nach links geht genauso wie von klinks nach rechts, 
    -- wir müssen bloß die Seiten vertauschen.
    R2 := { [y, x, d] : [x, y, d] in R1 };
    -- beide Richtungen
    R := R1 + R2;
    -- Am Anfang sind alle links.
    start := All;
    -- Am Ende sollen alle rechts sein.
    goal  := {};
    -- Berechne eine Pfad zum Ziel.
    path := reachable(start, goal, R);
    print("Der Marsch dauert ", path(2), " Minuten");
    path := path(1);
    -- Gebe diesen Pfad Schritt für Schritt aus.
    for i in [1 .. #path] loop
        S1 := path(i);
        S2 := All - S1;
        print(S1, 65 * " ", S2);
        if i = #path then
            exit;
        end if;
        if (i+1) mod 2 = 0 then
            M := S1 - path(i+1);
            print("                                     >>>> ", M, " >>>> " );
        else
            M := S2 - (All - path(i+1));
            print("                                     <<<< ", M, " <<<< " );
        end if;
    end loop;

    -- Check wether there is a path from start to goal in R and compute it.
    procedure reachable(start, goal, R);
        -- In the beginning length is undefined, we have length = om.
        -- P is the set of all pathes.  Every element of P has the form
        -- [ path, length ], where path is a list of triples and length is the
        -- time associated with this path.
        P := { [[start], 0] };  
        loop
            OldP   := P;
            P      := P + pathProduct(P, R, length);
            Found  := { p in P | endsWith(p,goal) };
            length := min/ { p(2) : p in Found };
            if P = OldP then  -- fixpoint has been reached
                return arb { p in Found | p(2) = length };
            end if;
        end loop;
    end reachable;

    -- This procedure checks, whether goal ist the last point of the path p.
    procedure endsWith(p, goal);
        p := p(1);
        return p(#p) = goal;
    end endsWith;

    -- Compute the time if Persons is the set of persons crossing the tunnel,
    procedure duration(Persons);
        times := { ["Chef", 5], ["Chuck", 10], ["Norbert", 20], ["Claudia", 25], ["Lampe", 0] };
        return max/ { times(x) : x in Persons };
    end duration;

    -- The procedure call product(P, Q) computes the path product P * Q.
    procedure pathProduct(Ps, Qs, l);
        W := { add(p,q) : p in Ps, q in Qs | addable(p,q,l) };
        return { p in W | not cyclic(p) };
    end pathProduct;

    -- This procedure checks whether the path q can be added to the path p.
    -- If the resulting path would take longer than time, it is discarded.
    procedure addable(p, q, time);
        p1 := p(1);
        if time = om or p(2) + q(3) <= time then
            return p1(#p1) = q(1);
        end if;
        return false;
    end addable;

    -- The procedure not_cyclic(p) checks whether the path p is cyclic.
    procedure cyclic(p);
        p := p(1);
        return #{ x : x in p } < #p;
    end cyclic;

    -- The product call add(p,q) computes the sum of the pathes p and q.
    -- The last point of the first component of p has to be the first point 
    -- of the first component of q.
    procedure add(p, q);
        
        return [p(1) + [q(2)], p(2) + q(3)];
    end add;
end main;

