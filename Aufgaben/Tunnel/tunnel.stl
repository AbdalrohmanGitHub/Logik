-- Vier Personen, Chef, Chuck, Norbert und Claudia, müssen eine Tunnel durchqueren.  Der Tunnel
-- ist so eng, dass immer nur zwei Personen gleichzeitig hindurch können.  Außerdem braucht
-- man zum Durchqueren eine Taschen-Lampe.  Die vier haben aber zusammen nur eine
-- Taschen-Lampe.  Die Zeiten, die Chef, Chuck, Norbert und Claudia zum Durchqueren benötigen
-- sind 5 Minuten, 10 Minuten, 20 Minuten und 25 Minuten.  Berechnen Sie einen Plan zum
-- Durchqueren des Tunnels, der die benötigte Zeit minimiert.

-- Lösung von Johannes Unterstein, edited by Karl Stroetmann.
program main; 
    All := { "Chef", "Chuck", "Norbert", "Claudia", "Lampe" };
    -- P ist die Menge aller Punkte.
    P := pow All;
    -- von links nach Rechts
    R1 := {[S, S-T, duration(T)]: S in P, T in pow S | #T in {2, 3} and "Lampe" in T };
    -- Von rechts nach links geht genauso wie von links nach rechts, 
    -- wir müssen bloß die Seiten vertauschen.
    R2 := { [y, x, d] : [x, y, d] in R1 };
    -- beide Richtungen
    R := R1 + R2;
    -- Am Anfang sind alle links.
    start := All;
    -- Am Ende sollen alle rechts sein.
    goal  := {};
    -- Berechne eine Pfad zum Ziel.
    path := reachable(start, goal, R);
    n := #path;
    print("Der Marsch dauert ", path(n), " Minuten");
    -- Gebe diesen Pfad Schritt für Schritt aus.
    for i in [1 .. n-1] loop
        S1 := path(i);
        S2 := All - S1;
        print(S1, 45 * " ", S2);
        if i = n-1 then
            exit;
        end if;
        if (i+1) mod 2 = 0 then
            M := S1 - path(i+1);
            print("                               >>>> ", M, " >>>> " );
        else
            M := S2 - (All - path(i+1));
            print("                               <<<< ", M, " <<<< " );
        end if;
    end loop;

    -- Check wether there is a path from start to goal in R and compute it.
    procedure reachable(start, goal, R);
        -- In the beginning length is undefined, we have length = om.
        -- P is the set of all pathes.  Every element of P has the form
        -- [ x1, ..., xn, duration ].
        P := { [start, 0] };  
        loop
            OldP   := P;
            P      := P + pathProduct(P, R, length);
            Found  := { p in P | p(#p-1) = goal };
            length := min/ { p(#p) : p in Found };
            if P = OldP then  -- fixpoint has been reached
                return arb { p in Found | p(#p) = length };
            end if;
        end loop;
    end reachable;

    -- Compute the time if Persons is the set of persons crossing the tunnel,
    procedure duration(Persons);
        times := { ["Chef", 5], ["Chuck", 10], ["Norbert", 20], ["Claudia", 25], ["Lampe", 0] };
        return max/ { times(x) : x in Persons };
    end duration;

    -- The procedure call product(P, Q) computes the path product P * Q.
    procedure pathProduct(Ps, Qs, l);
        W := { add(p,q) : p in Ps, q in Qs | addable(p,q,l) };
        return { p in W | not cyclic(p) };
    end pathProduct;

    -- This procedure checks whether the path q can be added to the path p.
    -- If the resulting path would take longer than time, it is discarded.
    procedure addable(p, q, time);
        n := #p - 1;
        if time = om or p(n+1) + q(3) <= time then
            return p(n) = q(1);
        end if;
        return false;
    end addable;

    -- The procedure not_cyclic(p) checks whether the path p is cyclic.
    procedure cyclic(p);
        return #{ x : x in p } < #p;
    end cyclic;

    -- The product call add(p,q) computes the sum of the pathes p and q.
    -- The last point of the first component of p has to be the first point 
    -- of the first component of q.
    procedure add(p, q);        
        n := #p - 1;
        return p(1..n) + [q(2)] +[ p(n+1) + q(3)];
    end add;
end main;

