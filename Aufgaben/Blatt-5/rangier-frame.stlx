////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// The following procedures find a path in a given graph if there is one.     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

findPath := procedure(x, y, r) {
    p := { [x] };
    while (true) {
        oldP  := p;
        p     := pathProduct(p, r);
        m     := { l[#l] : l in p };  // m contains all reachable points
        if (y in m) {
            return arb({ l in p | l[#l] == y });
        }
        // reduce p so that there is only one path to a given point
        p := { arb({ l in p | l[#l] == u }) : u in m };
        if (p == oldP) {
            return;
        }
    }
};

// The procedure call product(p, q) computes the path product p * q.
pathProduct := procedure(p, q) {
    return { add(x,y) : x in p, y in q | x[#x] == y[1] && !cyclic(add(x,y)) };
};

// The procedure not_cyclic(p) checks whether the path p is cyclic.
cyclic := procedure(p) {
    return #{ x : x in p } < #p;
};

// The product call add(p,q) computes the sum of the lists p and q.
// The last point of p has to be the first point of q.
add := procedure(p, q) {
    return p + q[2..];
};

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// The following procedure are only needed to print the soloution in    //
// readable way.                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////    

// This procedure prints the solution.
printPath := procedure(path) {
    print("Lösung:\n");
    for ([a, b, c] in path) {
        printState(a, b, c);
    }
};

printState := procedure(a, b, c) {
    print("A: ", a, "; B: ", b, "; C: ", c);
}; 

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Some auxilliary procedure.                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Given a set s, this procedure returns a set containing all lists that contain
// each element of s exactly once. 
// Example: 
// toList({1,2,3}) = {[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]}
toList := procedure(s) {
    if (s == {}) {
        return { [] };
    }
    return { [ x ] + l : x in s, l in toList(s - { x }) };
};

// This procedure computes the inverse of the binary relation R.
// Example:
// inverse({ ["a", 1], ["b", 2] }) = {[1, "a"], [2, "b"]}
inverse := procedure(r) {

};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// The definition of the relation describing the problem starts here.         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

all := { 0 .. 3 };

partitions := "???"; 
//  { [a,b,c] : ???




print("Number of partitions: $#partitions$");
p := "???";



print("Number of states: $#p$");
// print("Mögliche Zustände:\n");
// for ([a, b, c] in p) {
//     printState(a, b, c);
// }
// print("\n");

// racEast beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Osten
// zum Gleis C fährt.
racEast := "???";



print("Number of trips from A to C via the eastern track: $#racEast$");
// print("racEast:\n");
// for ([[a1, b1, c1], [a2, b2, c2]] in racEast) { 
//     printState(a1, b1, c1);
//     printState(a2, b2, c2);
//     print();
// }
// print("\n");

// RACwest beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Westen
// zum Gleis C fährt.
racWest := "???";



print("Number of trips from A to C via the western track: $#racWest$");
print("RACwest:\n");
// for ([[a1, b1, c1], [a2, b2, c2]] in racWest) {
//     printState(a1, b1, c1);
//     printState(a2, b2, c2);
//     print();
// }
// print("\n");

rac := racEast + racWest;
rca := "???";

// RBC beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis B
// zum Gleis C fährt.
rbc := "???";



print("RBC:\n");
// for ([[a1, b1, c1], [a2, b2, c2]] in rbc) {
//     printState(a1, b1, c1);
//     printState(a2, b2, c2);
//     print();
// }
// print("\n");

rcb := "???";

// R ist die Menge aller Verbindungen zwischen Punkten.
r := rac + rca + rbc + rcb;

print("#r = ", #r);

// Am Anfang sind die Waggons auf Gleis A, die Lokomotive ist auf Gleis B.
start := [ [1,2,3], [0], [] ];
// Am Ende sollen die Waggons alle in der Reihenfolge 3,1,2 auf Gleis C
// stehen und die Lokomotive soll wieder auf Gleis B stehen.
goal := [ [], [0], [3,1,2] ];
// Berechne alle möglichen Pfade
path := findPath(start, goal, r);
// und gebe diesen Schritt für Schritt aus.
printPath(path);


