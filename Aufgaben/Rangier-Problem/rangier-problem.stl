program main;
    All := { 0 .. 3 };
    Partitions := { [ A, B, C ] : A in pow All, B in pow All, C in pow All | 
                                  A * B = {} and A * C = {} and B * C = {} and A + B + C = All };
    print(#Partitions);
    P := { [LA,LB,LC] : [A,B,C] in Partitions, 
                        LA in toList(A), LB in toList(B), LC in toList(C) };

    print(#P);
    -- print("Mögliche Zustände:\n");
    -- for [A, B, C] in P loop
    --     printState(A, B, C);
    -- end loop;
    -- print("\n");

    -- RACeast beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Osten
    -- zum Gleis C fährt.
    RACeast := { [ [ A, B, C ], [ A(1..k-1), B, C + reverse(A(k..)) ] ] 
               : [ A,B,C ] in P, k in {1 .. #A } | 0 in A(k..)
               };
    print(#RACeast);
    -- print("RACeast:\n");
    -- for [[A1, B1, C1], [A2, B2, C2]] in RACeast loop
    --     printState(A1, B1, C1);
    --     printState(A2, B2, C2);
    --     print();
    -- end loop;
    -- print("\n");

    -- RACwest beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis A nach Westen
    -- zum Gleis C fährt.
    RACwest := { [ [ A, B, C ], [ A(k+1..), B, reverse(A(1..k)) + C ] ] 
               : [ A,B,C ] in P, k in {1 .. #A } | 0 in A(1..k)
               };
    print(#RACwest);
    -- print("RACwest:\n");
    -- for [[A1, B1, C1], [A2, B2, C2]] in RACwest loop
    --     printState(A1, B1, C1);
    --     printState(A2, B2, C2);
    --     print();
    -- end loop;
    -- print("\n");

    RAC := RACeast + RACwest;
    RCA := inverse(RAC);

    -- RBC beschreibt Zustandsübergänge, bei denen die Lokomotive vom Gleis B
    -- zum Gleis C fährt.
    RBC := { [ [ A, B, C ], [ A, B(1..k-1), B(k..) + C ] ] 
           : [ A,B,C ] in P, k in {1 .. #B }
           | 0 in B(k..)
           };
    -- print("RBC:\n");
    -- for [[A1, B1, C1], [A2, B2, C2]] in RBC loop
    --     printState(A1, B1, C1);
    --     printState(A2, B2, C2);
    --     print();
    -- end loop;
    -- print("\n");

    RCB := inverse(RBC);

    -- R ist die Menge aller Verbindungen zwischen Punkten.
    R := RAC + RCA + RBC + RCB;

    print("#R = ", #R);

    -- Am Anfang sind die Waggons auf Gleis A, die Lokomotive ist auf Gleis B.
    start := [ [1,2,3], [0], [] ];
    -- Am Ende sollen die Waggons alle in der Reihenfolge 3,1,2 auf Gleis C
    -- stehen und die Lokomotive soll auf Gleis B stehen.
    goal := [ [], [0], [3,1,2] ];
    -- Berechne alle möglichen Pfade.
    path  := reachable(start, goal, R);
    -- und geben diesen Schritt für Schritt aus.
    printPath(path);

    -- Check wether there is a path from x to y in R and compute it.
    procedure reachable(x, y, R);
        -- P contains all new pathes.
        P := { [x] };
        loop
            Old_P := P;
            P     := path_product(P, R);
            print("#P = ", #P, " length = ", max/ { #l : l in P } );
            -- M contains all end points of known pathes.
            M     := { p(#p) : p in P };  
            -- P is reduced so that there is only on path leading to a given end point.
            P     := { arb { p in P | p(#p) = x } : x in M };
            print("#P = ", #P);
            Found := { p in P | p(1) = x and p(#p) = y };
            if Found /= {} then
                return arb Found;
            end if;
            if P = Old_P then
                return;
            end if;
        end loop;
    end reachable;

    -- The procedure call product(P, Q) computes the path product P * Q.
    procedure path_product(P, Q);
        return { add(p,q) : p in P, q in Q | p(#p) = q(1) and not cyclic(add(p,q)) };
    end path_product;    

    -- The procedure not_cyclic(p) checks whether the path p is cyclic.
    procedure cyclic(p);
        return #{ x : x in p } < #p;
    end cyclic;

    -- The product call add(p,q) computes the sum of the lists p and q.
    -- The last point of p has to be the first point of q.
    procedure add(p, q);
        return p + q(2..);
    end add;    
    
    -- Given a set S, this procedure returns a set containing all lists that contain
    -- each element of S exactly once. 
    procedure toList(S);
        if S = {} then
            return { [] };
        end if;
        return { [ x ] + l : x in S, l in toList(S - { x }) };
    end toList;

    -- This procedure reverses the given list.
    procedure reverse(L);
        n := #L;
        return [ L(n-i) : i in { 0 .. n-1 } ]; 
    end reverse;

    -- This procedure computes the inverse of the binary relation R.
    procedure inverse(R);
        return { [ y, x ] : [ x, y ] in R };
    end inverse;

    --------------------------------------------------------------------------
    --                                                                      --
    -- Die folgenden Prozeduren dienen nur dem Ausdrucken der Lösung.       --
    --                                                                      --
    --------------------------------------------------------------------------    

    -- DiesesPrädikat druckt die Lösung aus.
    procedure printPath(path);
        print("Lösung:\n");
        for [A, B, C] in path loop
            printState(A, B, C);
        end loop;
    end printPath;

    procedure printState(A, B, C);
        print("A: ", A, "; B: ", B, "; C: ", C);
    end printState;    
end main;

