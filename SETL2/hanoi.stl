-- Die Türme von Hanoi.
program main;
    All := { 1, 2,3 };

    -- P ist die Menge aller Punkte.  Jeder Punkt repräsentiert einen Zustand
    -- der Türme von Hanoi.  Punkte sind deshalb 3-Tupel der Form 
    --                                                            
    --              [ L1, L2, L3 ]                                
    --                                                            
    -- Dabei sind L1, L2 und L3 Listen von Scheiben. Zum Beispiel repräsentiert 
    -- die Liste [ 1, 2, 3 ] einen Turm, der folgendes Aussehen hat:
    --                                                              
    --                     |                                        
    --                    111                                       
    --                   22222                                      
    --                  3333333                                     
    --              ===============                                 
    --                                                              
    -- Hier liegt oben die Scheibe 1, darunter die Scheibe 2 und ganz unten die 
    -- Scheibe 3. Die Liste L1 repräsentiert den ersten Turm, L2 repräsentiert 
    -- den Turm in der Mitte und L3 repräsentiert den letzten Turm.  Das 3-Tupel
    --  [ [1,2,3], [], [] ] repräsentiert also die Ausgangs-Situation bei der 
    -- drei Scheiben auf dem ersten Turm liegen und die anderen beiden Türme 
    -- leer sind:                                                     
    --                                                                
    --           |                    |                   |           
    --          111                   |                   |           
    --         22222                  |                   |           
    --        3333333                 |                   |           
    -- ===============================================================
    --                                                                
    P := { [ sort(S1), sort(S2), sort(S3) ] : S1 in pow All, S2 in pow All, S3 in pow All | 
                                              partition(S1, S2, S3, All) };
    print("P = ", P);

    -- R12 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem ersten Turm auf den zweiten Turm legen.  
    R12 := { [ [ L1, L2, L3 ], [ L1(2..), [ L1(1) ] + L2, L3 ] ] : [ L1, L2, L3 ] in P | movePossible(L1, L2) };
    -- R21 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem zweiten Turm auf den ersten Turm legen. 
    R21 := { [ [ L1, L2, L3 ], [ [ L2(1) ] + L1, L2(2..), L3 ] ] : [ L1, L2, L3 ] in P | movePossible(L2, L1) };
    -- R13 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem ersten Turm auf den dritten Turm legen.  
    R13 := { [ [ L1, L2, L3 ], [ L1(2..), L2, [ L1(1) ] + L3 ] ] : [ L1, L2, L3 ] in P | movePossible(L1, L3) };
    -- R31 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem dritten Turm auf den ersten Turm legen. 
    R31 := { [ [ L1, L2, L3 ], [ [ L3(1) ] + L1, L2, L3(2..) ] ] : [ L1, L2, L3 ] in P | movePossible(L3, L1) };
    -- R23 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem zweiten Turm auf den dritten Turm legen.  
    R23 := { [ [ L1, L2, L3 ], [ L1, L2(2..), [ L2(1) ] + L3 ] ] : [ L1, L2, L3 ] in P | movePossible(L2, L3) };
    -- R32 sind die Verbindungen, die wir erhalten, wenn wir die oberste Scheibe
    -- von dem dritten Turm auf den zweiten Turm legen. 
    R32 := { [ [ L1, L2, L3 ], [ L1, [ L3(1) ] + L2, L3(2..) ] ] : [ L1, L2, L3 ] in P | movePossible(L3, L2) };

    --    Testausgabe
    for [x,y] in R12 loop
         print(x, "  ->   ", y);
    end loop; 

    -- R ist die Menge aller Verbindungen zwischen Punkten.
    R := R12 + R21 + R31 + R13 + R23 + R32;

    --    Testausgabe von R
    print("R:");
    for [x,y] in R loop
        print(x, "  ->   ", y);
    end loop; 
    print();

    -- Am Anfang sind alle links.
    start := [ [1,2,3], [], [] ];
    -- Am Ende sollen alle Scheiben in der Mitte sein.
    goal := [ [], [1,2,3], [] ];
    -- Berechne alle möglichen Pfade.
    path := reachable(start, goal, R);
    -- und geben diesen Schritt für Schritt aus

    for i in [1 .. #path] loop
        t1 := lastChars(path(i)(1), 20);
        t2 := lastChars(path(i)(2), 20);
        t3 := lastChars(path(i)(3), 20);
        print(t1, t2, t3);
    end loop;

    -- Die Prozedur lastChars(x, n) wandelt x in einen String der Länge n um.
    -- Dabei wird der String von links mit Leerzeichen aufgefüllt.
    procedure lastChars(x, n);
        s := str(x);
        m := n - #s;
        return m * " " + s;
    end lastChars;

    -- Die Prozedur sort(S) erzeugt aus der Menge S eine aufsteigend sortierte
    -- Liste.
    procedure sort(S);
        return [ n in [1 .. 0 max/ S] | n in S ];
    end sort;

    -- Die Prozedur partition(S1, S2, S3, All) liefert genau dann "true",
    -- wenn die Menge {S1, S2, S3} eine Partition der Menge All ist.
    procedure partition(S1, S2, S3, All);
        return S1 + S2 + S3 = All and
               S1 * S2 = {}       and
               S1 * S3 = {}       and
               S2 * S3 = {};
    end partition;

    procedure movePossible(Source, Target);
        return Source /= [] and (Target = [] or Source(1) < Target(1));
    end movePossible;


    --------------------------------------------------------------------------
    --                                                                      --
    -- Die unten aufgeführten Prozeduren sind 1-zu-1 aus dem Programm zur   --
    -- Lösung des Wolf-Ziege-Kohl-Problems kopiert.                         --
    --                                                                      --
    --------------------------------------------------------------------------

    -- PS ist eine Menge von Pfaden, R ist eine binäre Relation.  Die Prozedur
    -- verlängert alle Pfade aus PR, die mit einem Punkt y enden, für den es
    -- ein Paar [y,z] in R gibt. 
    procedure oneStep(PS, R);
           return { p + [ z ] : p in PS, [y, z] in R | p(#p) = y };
    end oneStep;
    
    -- Entfernt alle Pfade aus PS die zyklisch sind.
    procedure eliminateCycles(PS);
       	return { p in PS | not cyclic(p) };
    end eliminateCycles;
    
    -- Liefert true, wenn der Pfad p einen Zyklus enthält.
    procedure cyclic(p);
        return #{ x : x in p } < #p;
    end cyclic;

    -- Berechnet eine Pfad von x nach y. Dabei beschreibt die Relation R die 
    -- Verbindungen zwischen den Punkten.  Falls kein Pfad gefunden werden
    -- kann wird Omega zurück gegeben.
    procedure reachable(x, y, R);
        PS := { [x] };
        loop
            old_PS := PS;
            PS := eliminateCycles(PS + oneStep(PS, R));
            -- P ist die Menge aller Pfade, die am Zielpunkt y enden.
            P := { p in PS | p(#p) = y };
            if P /= {} then
                -- Wenn P nicht leer ist, geben wir ein beliebiges Element aus P
                -- zurück.
                return arb P;
            end if;
            if old_PS = PS then
               -- Wenn das Programm bis hier kommt, sind alle möglichen Pfade 
               -- berechnet worden.  Aufgrund des obigen Tests P /= {} wissen
               -- wir, dass keiner dieser Pfade zum Ziel führt.  Daher können
               -- wir jetzt Omega zurück geben.  Omega wird implizit dann zurück
               -- gegeben, wenn hinter mdem "return" kein Wert steht.
               return;
           end if;
        end loop;
    end reachable;

end main;

