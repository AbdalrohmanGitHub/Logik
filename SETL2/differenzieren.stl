program main;

    testDiff("x ** 2", "x");
    testDiff("x", "x");
    testDiff("1 - x", "x");
    testDiff("1", "x");
    testDiff("x * x", "x");
    testDiff("c * x + d", "x");
    testDiff("1 / x", "x");
    testDiff("x - x - x", "x");
    testDiff("x - (x - x)", "x");
    testDiff("x / x", "x");
    testDiff("sin(x) / cos(x)", "x");
    testDiff("tan(x)", "x");
    testDiff("sqrt(x)", "x");
    testDiff("arctan(x)", "x");
    testDiff("exp(x)", "x");
    testDiff("ln(x)", "x");
    testDiff("exp(ln(x))", "x");
    testDiff("ln(exp(x))", "x");
    testDiff("x ** x", "x");

    -- Die Prozedur testDiff(E, V) bekommt als Eingabe zwei Strings E und V.
    -- E beschreibt einen  arithmetischen Ausdruck und V ist der Name einer
    -- Variablen.  Der Ausdruck E wird nach dieser Variablen abgeleitet und
    -- das Ergebnis wird ausgegeben.
    procedure testDiff(E, V);
        TokenList := scanExpr(E);
        Expr      := parseExpr(TokenList);
        DiffExpr  := diff(Expr, V);
        Simple    := simplify(DiffExpr);
        print("Ableitung von ", prettyPrint(E), " nach ", V, ": ", prettyPrint(DiffExpr));
        print("Vereinfacht:  ", prettyPrint(Simple), "\n");
    end testDiff;

    -- Expr repräsentiert einen arithmetischen Ausdruck und X ist der Name 
    -- einer Variablen. Der Ausdruck wird nach dieser Variablen abgeleitet.
    -- Die arithmetischen Ausdrücke werden durch die im folgenden definierte
    -- Funktion 
    --          rep: Expr -> SETLObj
    -- dargestellt:
    --
    -- 1. rep(v) := v  für alle Variablen v.  Variablen werden als Strings dargestellt.
    -- 2. rep(x) := x  für alle Zahlen x.
    --
    -- 3. rep(s + t)  := [ rep(s), "+", rep(t) ] für arithmetische Ausdrücke s und t.
    -- 4. rep(s - t)  := [ rep(s), "-", rep(t) ] für arithmetische Ausdrücke s und t.
    -- 5. rep(s * t)  := [ rep(s), "*", rep(t) ] für arithmetische Ausdrücke s und t.
    -- 6. rep(s / t)  := [ rep(s), "/", rep(t) ] für arithmetische Ausdrücke s und t.
    -- 7. rep(s ** t) := [ rep(s), "**", rep(t) ] für arithmetische Ausdrücke s und t.
    --
    -- 8.  rep(sqrt(t))   := [ "sqrt", rep(t) ] für arithmetische Ausdrücke t.
    -- 9.  rep(sin(t))    := [ "sin", rep(t) ] für arithmetische Ausdrücke t.
    -- 10. rep(cos(t))    := [ "cos", rep(t) ] für arithmetische Ausdrücke t.
    -- 11. rep(tan(t))    := [ "tan", rep(t) ] für arithmetische Ausdrücke t.
    -- 12. rep(arctan(t)) := [ "arctan", rep(t) ] für arithmetische Ausdrücke t.
    -- 13. rep(exp(t))    := [ "exp", rep(t) ] für arithmetische Ausdrücke t.
    -- 14. rep(ln(t))     := [ "ln", rep(t) ] für arithmetische Ausdrücke t.
    procedure diff(Expr, X);
        case 
            when is_string(Expr) => 
                if Expr = X then 
                    return 1;
                else
                    return 0;
                end if;
            when is_integer(Expr)   => return 0;
            when is_real(Expr)      => return 0;
            when Expr(1) = "-"      => return [ "-", diff(Expr(2), X) ];
            when Expr(2) = "+"      => return [ diff(Expr(1), X), "+", diff(Expr(3), X) ];
            when Expr(2) = "-"      => return [ diff(Expr(1), X), "-", diff(Expr(3), X) ];
            when Expr(2) = "*"      => 
                 return [ [ diff(Expr(1), X), "*", Expr(3) ], "+", [ Expr(1), "*", diff(Expr(3), X) ] ];
            when Expr(2) = "/"      => 
                 return [ [ [ diff(Expr(1), X), "*", Expr(3) ], "-", [ Expr(1), "*", diff(Expr(3), X) ] ], 
                          "/", 
                          [ Expr(3), "*", Expr(3) ]
                        ];
            when Expr(2) = "**" and is_integer(Expr(3)) => 
                 return [ [ Expr(3), "*", [ Expr(1), "**", Expr(3) - 1 ] ], "*", diff(Expr(1), X) ];
            when Expr(2) = "**"     => return diff( [ "exp", [ Expr(3), "*", [ "ln", Expr(1) ] ] ], X );

            when Expr(1) = "sqrt"   => return [ diff(Expr(2), X), "/", [ 2, "*", Expr ] ];
            when Expr(1) = "sin"    => return [ diff(Expr(2), X), "*", [ "cos", Expr(2) ] ];
            when Expr(1) = "cos"    => return [ "-", [ diff(Expr(2), X), "*", [ "sin", Expr(2) ] ] ];
            when Expr(1) = "tan"    => 
                 return [ diff(Expr(2),X), "/", [ [ "cos", Expr(2) ], "*", [ "cos", Expr(2) ] ] ];
            when Expr(1) = "arctan" => return [ diff(Expr(2),X), "/", [ 1, "+", [ Expr(2), "*", Expr(2) ] ] ];
            when Expr(1) = "exp"    => return [ diff(Expr(2),X), "*", Expr ];
            when Expr(1) = "ln"     => return [ diff(Expr(2),X), "/", Expr(2) ];
            otherwise               => abort("Error in diff( " + str(Expr) + ", " + str(X) + " )");
        end case;
    end diff;

    -- Die Prozedur simplify(Expr) versucht den Ausdruck Expr durch Anwendung von 
    -- Regeln der Form
    --    0 * x = x * 0 = 0,
    --    1 * x = x * 1 = 1,
    --    0 + x = x + 0 = x
    --    0 - x = - x
    --    x - 0 = x
    --    x - x = 0
    --    x / x = 1
    --    0 / x = 0
    --    x ** 1 = x
    -- soweit wie möglich zu vereinfachen.
    procedure simplify(Expr);
        case 
            when is_string(Expr)  => return Expr;
            when is_integer(Expr) => return Expr;
            when is_real(Expr)    => return Expr; 
            -- 0 + x = x
            when Expr(2) = "+" and simplify(Expr(1)) = 0 => return simplify(Expr(3));  
            -- x + 0 = x
            when Expr(2) = "+" and simplify(Expr(3)) = 0 => return simplify(Expr(1));
            -- 0 * x = 0
            when Expr(2) = "*" and simplify(Expr(1)) = 0 => return 0;
            -- x * 0 = 0
            when Expr(2) = "*" and simplify(Expr(3)) = 0 => return 0;
            -- 1 * x = x
            when Expr(2) = "*" and simplify(Expr(1)) = 1 => return simplify(Expr(3));
            -- x * 1 = x
            when Expr(2) = "*" and simplify(Expr(3)) = 1 => return simplify(Expr(1));
            -- 0 - x = - x
            when Expr(2) = "-" and simplify(Expr(1)) = 0 => return [ "-", simplify(Expr(3)) ];
            -- x - 0 = x
            when Expr(2) = "-" and simplify(Expr(3)) = 0 => return simplify(Expr(1));
            -- x - x = 0
            when Expr(2) = "-" and simplify(Expr(1)) = simplify(Expr(3)) => return 0;
            -- x / x = 0
            when Expr(2) = "/" and simplify(Expr(1)) = simplify(Expr(3)) => return 1;
            -- 0 / x = 0
            when Expr(2) = "/" and simplify(Expr(1)) = 0 => return 0;
            -- x ** 1 = x
            when Expr(2) = "**" and simplify(Expr(3)) = 1 => return simplify(Expr(1));
            when #Expr = 2 => return [ Expr(1), simplify(Expr(2)) ];
            when #Expr = 3 => return [ simplify(Expr(1)), Expr(2), simplify(Expr(3)) ];
            otherwise      => abort("Error in simplify( " + str(Expr) + " )");
        end case;
    end simplify;

    ------------------------------------------------------------------------------
    -- Ausdrucken und Parsen                                                                         --
    ------------------------------------------------------------------------------

    -- Wandelt einen arithmetischen Ausdruck in einen String um.
    procedure prettyPrint(Expr);
        case 
            when is_string(Expr)  => return Expr;
            when is_integer(Expr) => return str(Expr);
            when is_real(Expr)    => return str(Expr);
            when Expr(2) = "+"      => return prettyPrint(Expr(1)) + " + " + prettyPrint(Expr(3));
            when Expr(2) = "-"      => return prettyPrint(Expr(1)) + " - " + prettyPrintParen(Expr(3));
            when Expr(2) = "*"      => return prettyPrintParen(Expr(1)) + " * " + prettyPrintParen(Expr(3));
            when Expr(2) = "/"      => return prettyPrintParen(Expr(1)) + " / " + prettyPrintParen(Expr(3));
            when Expr(2) = "**"     => return prettyPrintParen(Expr(1)) + " ** " + prettyPrintParen(Expr(3));
            when #Expr = 2 and Expr(1) = "-"      => return  "- " + prettyPrintParen(Expr(2));
            when #Expr = 2 and Expr(1) = "+"      => return prettyPrint(Expr(2));
            when #Expr = 2 and Expr(1) = "sin"    => return "sin(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "cos"    => return "cos(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "tan"    => return "tan(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "sqrt"   => return "sqrt(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "arctan" => return "arctan(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "exp"    => return "exp(" + prettyPrint(Expr(2)) +")";
            when #Expr = 2 and Expr(1) = "ln"     => return "ln(" + prettyPrint(Expr(2)) +")";
            otherwise =>
                abort("Error in prettyPrint( " + str(Expr) + " )");
        end case;
    end prettyPrint;

    -- Wandelt den arithmetischen Ausdruck in einen String um, der von Klammern
    -- umgeben ist, falls das nötig ist.
    procedure prettyPrintParen(Expr);
        FunctionNames := { "sin", "cos", "tan", "sqrt", "arctan", "exp", "ln" };
        case 
            when is_string(Expr)  => return Expr;
            when is_integer(Expr) => return str(Expr);
            when is_real(Expr)    => return str(Expr);
            when #Expr = 2 and Expr(1) in FunctionNames =>
                 return prettyPrint(Expr);
            otherwise             =>
                 return "(" + prettyPrint(Expr) + ")";
        end case;
    end prettyPrintParen;

    --------------------------------------------------------------------------
    -- Die restlichen Prozeduren dienen dem Parsen von Ausdrücken.          --
    --------------------------------------------------------------------------

    -- Diese Prozedur erhält eine Liste von Tokens als Eingabe und wandelt 
    -- diese in die interne Darstellung eines arithmetischen Ausdrucks um.
    -- Die Art und Weise, wie arithmetische Ausdrücke in SETL repräsentiert
    -- werden, ist im Kommentar der Prozedur diff(Expr, X) beschrieben.
    procedure parseExpr(TokenList);
        Nesting := computeNesting(TokenList, 0, 1);
        IdxSet  := { index : [ index, level ] in Nesting | 
                           level = 0 and TokenList(index) in { "+", "-" } };
        if IdxSet /= {} then
            -- Wir bilden das Maximum, weil "+" und "-" links-assoziativ sind.
            opIdx := max/ IdxSet;
            if opIdx > 1 then
                f     := parseExpr( TokenList(1 .. opIdx - 1) );
                g     := parseExpr( TokenList(opIdx + 1 ..  ) );
                return [ f, TokenList(opIdx), g ];
            else 
                return [ TokenList(opIdx), parseExpr(TokenList(2 ..)) ];
            end if;
        end if;
        -- Jetzt enthält IdxSet die Indices derjenigen Operatoren "*" und "/",
        -- die nicht in Klammern eingeschlossen sind.
        IdxSet  := { index : [ index, level ] in Nesting | 
                             level = 0 and TokenList(index) in { "*", "/" } };
        if IdxSet /= {} then
            -- Wir bilden das Maximum, weil "*" und "*" links-assoziativ sind.
            opIdx := max/ IdxSet;
            f     := parseExpr( TokenList(1 .. opIdx - 1) );
            g     := parseExpr( TokenList(opIdx + 1 ..  ) );
            return [ f, TokenList(opIdx), g ];
        end if;
        IdxSet  := { index : [ index, level ] in Nesting | 
                           level = 0 and TokenList(index) in { "**" } };
        if IdxSet /= {} then
            -- Jetzt wählen wir das Maximum, weil "**"  rechts-assoziativ ist.
            opIdx := min/ IdxSet;
            f     := parseExpr( TokenList(1 .. opIdx - 1) );
            g     := parseExpr( TokenList(opIdx + 1 ..  ) );
            return [ f, TokenList(opIdx), g ];
        end if;
        if TokenList(1) = "(" and TokenList(#TokenList) = ")" then
            return parseExpr( TokenList( 2 .. #TokenList - 1 ) );
        end if;
        -- Wenn wir bis hier kommen, dann liegt ein Funktions-Aufruf vor.
        if TokenList(2) = "(" and TokenList(#TokenList) = ")" then
            return [ TokenList(1), parseExpr( TokenList( 3 .. #TokenList - 1 ) ) ];
        end if;
        if #TokenList = 1 then
            return TokenList(1);
        end if;
        abort("Error in parseExpr( " + str(TokenList) + " )" );
    end parseExpr;    

    -- Die Prozedur computeNesting(TokenList, level, index) berechnet eine Liste von
    -- Paaren der Form [ idx, level ].  Dabei gibt idx einen Index in der Liste
    -- TokenList an und level ist eine Zahl, die angibt, wieviel öffnende Klammern
    -- noch nicht wieder geschlossen wurden.  Beispiel:
    --   computeNesting( [ "sin", "(", "x", ")" ], 0, 1 ) = {[1, 0], [3, 1]}
    -- Das Argument level gibt an, wieviele Klammern schon offen sind und index
    -- ist der Index des ersten Elements von TokenList.
    procedure computeNesting(TokenList, level, index);
        if TokenList = [] then
            return {};
        end if;
        if TokenList(1) = "(" then
            return computeNesting( TokenList(2..), level + 1, index + 1);
        end if;
        if TokenList(1) = ")" then
            return computeNesting( TokenList(2..), level - 1, index + 1);
        end if;
        return { [ index, level ] } + 
               computeNesting( TokenList(2..), level, index + 1 );
    end computeNesting;

    -- Liest einen String und zerlegt ihn in eine Liste von Tokens, die zurück
    -- gegeben wird.
    procedure scanExpr(s);
        letters := {};
        -- collect all letters and digits
        for x in { 46 } + { 48 .. 57 } + { 65 .. 90 } + { 97 .. 122 } loop
            letters := letters + { char(x) };
        end loop;
        case 
            when #s > 1 and s(1..2) = "**" => 
                 return [ "**" ] + scanExpr( s(3..) );
            when s = ""            => return [];
            when s(1) = "("        => return [ "("  ] + scanExpr( s(2..) );
            when s(1) = ")"        => return [ ")"  ] + scanExpr( s(2..) );
            when s(1) = "+"        => return [ "+"  ] + scanExpr( s(2..) );
            when s(1) = "-"        => return [ "-"  ] + scanExpr( s(2..) );
            when s(1) = "*"        => return [ "*"  ] + scanExpr( s(2..) );
            when s(1) = "/"        => return [ "/"  ] + scanExpr( s(2..) );
            when s(1) = " "        => return            scanExpr( s(2..) );
            when s(1) = "\t"       => return            scanExpr( s(2..) );
            when s(1) = "\n"       => return            scanExpr( s(2..) );
        end case;
        index := 1;
        word  := "";
        if s(index) notin letters then
            abort("Error in scanExpr(" + s + ")");
        end if;
        while s(index) in letters and index < #s loop
            index := index + 1;
        end loop;
        if onlyDigits( s(1 .. index-1) ) then
            token := ascii2int( s(1 .. index-1) );
        else
            token := s(1 .. index-1);
        end if;
        if not s(index) in letters then
            return [ token ] + scanExpr( s(index ..) );
        end if;
        if index = #s then
            if onlyDigits( s(1 .. index) ) then
                token := ascii2int( s(1 .. index) );
            else
                token := s(1 .. index);
            end if;
            return [ token ];
        end if;
        abort( "Error in scanExpr: s = " + s );
    end scanExpr;

    -- Der Aufruf onlyDigits(s) liefert genau dann true, wenn der String "s" 
    -- nur aus den Ziffern "0", ..., "9" besteht.
    procedure onlyDigits(s);
        return { s(i) : i in [1..#s] } <= { char(i) : i in [abs("0")..abs("9")] };
    end onlyDigits;

    -- Wandelt den gegebenen String, der nur aus Ziffern bestehen darf, in
    -- eine ganze Zahl um.
    procedure ascii2int(s);
        -- Die Funktion abs c berechnet den ASCII-Code, der dem Zeichen c
        -- zugeordnet ist.
        return +/ [ (abs(s(i)) - abs("0")) * 10 ** (#s - i) : i in [1..#s] ];
    end ascii2int;

end main;