%!PS-Adobe-3.0
%%Title: blatt-2-1+2.stl, blatt-2-3+4.stl, wolf-ziege-kohl.stl, knf.stl
%%For: Karl Stroetmann
%%Creator: a2ps version 4.13
%%CreationDate: Mon Feb 23 16:43:04 2004
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 5
%%PageOrder: Ascend
%%DocumentMedia: letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Define these in case they're not in the FontInfo (also, here
    % they're easier to get to.
    /UnderlinePosition 1 def
    /UnderlineThickness 1 def
    
    % Get the underline position and thickness if they're defined.
    currentdict /FontInfo known {
      FontInfo
      
      dup /UnderlinePosition known {
	dup /UnderlinePosition get
	0 exch FontMatrix transform exch pop
	/UnderlinePosition exch def
      } if
      
      dup /UnderlineThickness known {
	/UnderlineThickness get
	0 exch FontMatrix transform exch pop
	/UnderlineThickness exch def
      } if
      
    } if
    currentdict 
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.060185 def
/cw 4.236111 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 86.400000 mul
def
/ph
   520.335631 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 5 def
/tab 4 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1,1) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1) # (program main;) p n
(2) # (    -- Eine bin\344re Relation R:) N
(3) # (    R := { [1,2], [2,3], [1,3], [2,4], [4,5], [5,1], [17, 29], ) N
(4) # (           [29, 42], [42, 5] ) N
(5) # (         };) N
(6) # (    x := 1;) N
(7) # (    print\("oneStep\(x, R\)   = ", oneStep\(x, R\)\);) N
(8) # (    print\("reachable\(x, R\) = ", reachable\(x, R\)\);) N
(9) # () N
(10) # (-- Aufgabe 1: Der Aufruf oneStep\(x, R\) berechnet f\374r einen Punkt x und eine ) N
(11) # (-- bin\344re Relation R alle die Punkte, die von x aus in einem Schritt erreicht) N
(12) # (-- werden k\366nnen.) N
(13) # (procedure oneStep\(x, R\);) N
(14) # (    return { b : [ a, b ] in R | a = x };) N
(15) # (end oneStep;) N
(16) # () N
(17) # (-- Der Aufruf oneStepSet\(M, R\) berechnet f\374r eine Menge M  und eine bin\344re ) N
(18) # (-- Relation R alle die Punkte, die ausgehend von einem Punkt aus M, in einem ) N
(19) # (-- Schritt erreicht werden k\366nnen.) N
(20) # (procedure oneStepSet\(M, R\);) N
(21) # (    return { b : [ a, b ] in R | a in M };) N
(22) # (end oneStepSet;) N
(23) # () N
(24) # (-- Aufgabe 2:  Der Aufruf reachable\(x, R\) berechnet f\374r einen Punkt x und eine ) N
(25) # (-- bin\344re Relation R alle die Punkte, die von x aus in beliebig vielen Schritten) N
(26) # (-- erreicht werden k\366nnen. ) N
(27) # (procedure reachable\(x, R\);) N
(28) # (    M := { x };) N
(29) # (    loop) N
(30) # (        OldM := M;) N
(31) # (        M := M + oneStepSet\(M, R\);) N
(32) # (        if M = OldM then) N
(33) # (            return M;) N
(34) # (        end if;) N
(35) # (    end loop;) N
(36) # (end reachable;) N
(37) # () N
(38) # (end main;) N
(39) # () N
(40) # () N
(blatt-2-1+2.stl) (Page 1/1) (Feb 23, 04 16:27) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1) # (program main;) p n
(2) # (    -- Eine Abstands-Funktion D:) N
(3) # (    D := { [[1,2], 2], [[ 2,3], 1], [[1,3], 4], [[2,4], 7 ], [[4,5], 1], ) N
(4) # (           [[5, 1], 2], [[17, 29], 3], [[29, 42], 5], [[42, 5], 2] ) N
(5) # (         }; ) N
(6) # (    x := 1;) N
(7) # (    print\("oneStepSet\({[x, 0]}, D\) = ", oneStepSet\({[x,0]}, D\)\);) N
(8) # (    print\("reachable\(x, D\)         = ", reachable\(x, D\)\);) N
(9) # () N
(10) # (-- Aufgabe 3: Der Aufruf oneStepSetNoUse\(M, R\) berechnet alle die Paare [y, l],) N
(11) # (-- f\374r die es einen Punkt x aus gibt, so dass es eine direkte Verbindung von) N
(12) # (-- x nach y der L\344nge l gibt) N
(13) # (procedure oneStepSetNoUse\(M, D\);) N
(14) # (    return { [ y, l ] : [ [ x, y ], l ] in D | x in M };) N
(15) # (end oneStepSetNoUse;) N
(16) # () N
(17) # (-- E ist eine Menge von Paaren der Form [y, l1], wobei l1 die Entfernung zu ) N
(18) # (-- einem gegebenem Punkt x angibt. D ist eine Abstands-Funktion.  Der Aufruf ) N
(19) # (-- oneStepSetExtended\(E, D\) berechnet alle die Paare [z, l1 + l2], f\374r die ) N
(20) # (-- der Punkt z in einem Schritt von einem Punkt y aus E erreicht werden kann.) N
(21) # (-- l1 ist der Abstand, den y von dem Punkt x hat, l2 ist der Abstand, den) N
(22) # (-- z von y hat.) N
(23) # (procedure oneStepSet\(E, D\);) N
(24) # (    return { [z, l1 + l2] : [y1, l1] in E, [ [y2, z], l2 ] in D | y1 = y2 };) N
(25) # (end oneStepSet;) N
(26) # () N
(27) # (-- Aufgabe 4:  Der Aufruf reachable\(x, D\) berechnet f\374r einen Punkt x und eine ) N
(28) # (-- Abstands-Funktion D alle die Paare [y, l], f\374r die es einen Punkt x aus gibt,) N
(29) # (-- so dass es eine Verbindung von x nach y der L\344nge l gibt.) N
(30) # (procedure reachable\(x, D\);) N
(31) # (    E := { [ x, 0 ] };) N
(32) # (    loop) N
(33) # (        OldE := E;) N
(34) # (        E := minimize\(E + oneStepSet\(E, D\)\);) N
(35) # (        if E = OldE then) N
(36) # (            return E;) N
(37) # (        end if;) N
(38) # (    end loop;) N
(39) # (end reachable;) N
(40) # () N
(41) # (-- E ist eine Menge von Paaren der Form [y, l], wobei l die Entfernung zu einem) N
(42) # (-- gegebenem Punkt angibt. Die Prozedur minimize entfernt alle die Paare ) N
(43) # (-- [y, l1], f\374r die es ein Paar [y, l2] in E gibt, so dass l2 < l1 ist. ) N
(44) # (procedure minimize\(E\);) N
(45) # (    return { [ y, l ] in E | l = min/ { d : [ z, d ] in E | y = z } };) N
(46) # (end minimize;) N
(47) # () N
(48) # (end main;) N
(49) # () N
(50) # () N
(blatt-2-3+4.stl) (Page 1/1) (Feb 23, 04 16:28) title
border
grestore
(Printed by Karl Stroetmann) rhead
(blatt-2-1+2.stl, blatt-2-3+4.stl) (1/5) (Monday February 23, 2004) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1) # (-- Es war einmal ein Bauer, der wollte mit einem Wolf, einer Ziege und) p n
(2) # (-- einer Kiste Kohl \374ber einen Flu\337 \374bersetzen.  In dem Boot war aber) N
(3) # (-- nicht genug Platz f\374r alles, der Bauer konnte maximal ein Tiere oder ) N
(4) # (-- das Gem\374se mitnehmen.  Er konnte aber auch Wolf und Ziege nicht ) N
(5) # (-- alleine lassen, denn dann h\344tte der Wolf die Ziege gefressen.) N
(6) # (-- Ebensowenig konnte er die Ziege mit dem Kohl alleine lassen, denn) N
(7) # (-- dann h\344tte die Ziege den Kohl gefressen.) N
(8) # () N
(9) # (program main;) N
(10) # (    All := { "Bauer", "Wolf", "Ziege", "Kohl" };) N
(11) # (    -- P ist die Menge aller Punkte.) N
(12) # (    P := { [ S1, S2 ] : S1 in pow All, S2 in pow All | ) N
(13) # (                        S1 + S2 = All and S1 * S2 = {} };) N
(14) # (    -- R ist die Menge der Verbindungen zwischen Punkten.) N
(15) # (    R := computeR\(P\);) N
(16) # (    -- Am Anfang sind alle links.) N
(17) # (    start := [ All, {} ];) N
(18) # (    -- Am Ende sollen alle rechts sein.) N
(19) # (    goal := [ {}, All ];) N
(20) # (    -- Berechne alle m\366glichen Pfade.) N
(21) # (    PathSet := reachable\(start, R\);) N
(22) # (    -- Wir berechnen die L\344nge des k\374rzesten Pfades zum Ziel.) N
(23) # (    length := min/ { #p : p in PathSet | p\(#p\) = goal };) N
(24) # (    -- Wir w\344hlen einen beliebigen minimalen Pfad ) N
(25) # (    path := arb { p in PathSet | p\(#p\) = goal and #p = length };) N
(26) # (    -- und geben diesen Schritt f\374r Schritt aus.) N
(27) # (    for i in [1 .. #path] loop) N
(28) # (        S1 := path\(i\)\(1\);) N
(29) # (        S2 := path\(i\)\(2\);) N
(30) # (        print\(S1, 67 * " ", S2\);) N
(31) # (        if i = #path then) N
(32) # (            exit;) N
(33) # (        end if;) N
(34) # (        if "Bauer" in S1 then) N
(35) # (            M := S1 - path\(i+1\)\(1\);) N
(36) # (            print\("                                    >>>> ", M, " >>>> " \);) N
(37) # (        else) N
(38) # (            M := S2 - path\(i+1\)\(2\);) N
(39) # (            print\("                                    <<<< ", M, " <<<< " \);) N
(40) # (        end if;) N
(41) # (    end loop;) N
(42) # () N
(43) # (    -- Die Prozedur berechnet die m\366glichen Verbindungen zwischen Punkten.) N
(44) # (    procedure computeR\(P\);) N
(45) # (        -- Ein neuer Punkt ist erreichbare, wenn der Bauer von links nach ) N
(46) # (        -- rechts \374bersetzt und h\366chstens ein Objekte mitnimmt.) N
(47) # (        R1 := { [ [S1, S2], [S1 - M, S2 + M] ] : [S1, S2] in P, M in pow S1 |) N
(48) # (                  "Bauer" in M and #M <= 2 and not problem\(S1 - M\) };) N
(49) # (        -- Genauso, wie der Bauer von links nach rechts \374bersetzen kann, ) N
(50) # (        -- geht es auch von rechts nach links.) N
(51) # (        R2 := { [ [S1, S2], [S1 + M, S2 - M] ] : [S1, S2] in P, M in pow S2 |) N
(52) # (                  "Bauer" in M and #M <= 2 and not problem\(S2 - M\) };) N
(53) # (        return R1 + R2;) N
(54) # (    end computeR;) N
(55) # () N
(56) # (    -- Die Menge S ist problematisch, wenn entweder Ziege und Kohl ) N
(57) # (    -- oder Wolf und Ziege zusammen sind.) N
(58) # (    procedure problem\(S\);) N
(59) # (        return \("Ziege" in S and "Kohl" in S\) or \("Wolf" in S and "Ziege" in S\);) N
(60) # (    end problem;) N
(61) # () N
(62) # (    -- Berechnet alle Pfade der L\344nge 1 mit x als Anfangspunkt.) N
(63) # (    procedure createPathSet\(x, R\);) N
(64) # (       return { [a, b] in R | a = x };) N
(65) # (    end createPathSet;) N
(66) # (    ) N
(67) # (    -- PS ist eine Menge von Pfaden, R ist eine bin\344re Relation.  Die Prozedur) N
(68) # (    -- verl\344ngert alle Pfade aus PR, die mit einem Punkt y enden, f\374r den es) N
(69) # (    -- ein Paar [y,z] in R gibt. ) N
(70) # (    procedure oneStep\(PS, R\);) N
(71) # (           return{ p + [ z ] : p in PS, [y, z] in R | p\(#p\) = y };) N
(72) # (    end oneStep;) N
(73) # (    ) N
(wolf-ziege-kohl.stl) (Page 1/2) (Feb 23, 04 16:31) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(74) # (    -- Entfernt alle Pfade aus PS die zyklisch sind.) p n
(75) # (    procedure eliminateCycles\(PS\);) N
(76) # (       ) S 8 T (return{ p in PS | not cyclic\(p\) };) N
(77) # (    end eliminateCycles;) N
(78) # (    ) N
(79) # (    -- Liefert true, wenn der Pfad p einen Zyklus enth\344lt.) N
(80) # (    procedure cyclic\(p\);) N
(81) # (        return #{ x : x in p } < #p;) N
(82) # (    end cyclic;) N
(83) # () N
(84) # (    -- Berechnet alle von x mit der Relation R erreichbaren Punkte.) N
(85) # (    procedure reachable\(x, R\);) N
(86) # (        PS := createPathSet\(x, R\);) N
(87) # (        loop) N
(88) # (            old_PS := PS;) N
(89) # (            PS := eliminateCycles\(PS + oneStep\(PS, R\)\);) N
(90) # (            if old_PS = PS then) N
(91) # (               return PS;) N
(92) # (           end if;) N
(93) # (        end loop;) N
(94) # (    end reachable;) N
(95) # () N
(96) # (end main;) N
(97) # () N
(wolf-ziege-kohl.stl) (Page 2/2) (Feb 23, 04 16:31) title
border
grestore
(Printed by Karl Stroetmann) rhead
(wolf-ziege-kohl.stl) (2/5) (Monday February 23, 2004) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1) # (program main;) p n
(2) # () N
(3) # (--  z.B. "\(p folgt q\) gdw \(nicht q folgt nicht p\)";) N
(4) # (--    print\("Bitte Formel eingeben"\);) N
(5) # (--    get\(s\);) N
(6) # (    s := "\(p folgt q\) gdw \(nicht q folgt nicht p\)";) N
(7) # (    l := scan_formula\(s\);) N
(8) # (    f := parse_formula\(l\);) N
(9) # (    n := normalize\(f\);) N
(10) # (    print\( pretty_print_knf\(n\) \);) N
(11) # () N
(12) # (    -- Diese Prozedur \374berf\374hrt die Formel f in konjunktive Normalform.) N
(13) # (    procedure normalize\(f\);) N
(14) # (        n1 := eliminate_gdw\(f\);) N
(15) # (        n2 := eliminate_folgt\(n1\);) N
(16) # (        n3 := nnf\(n2\);) N
(17) # (        n4 := knf\(n3\);) N
(18) # (        return n4;) N
(19) # (    end normalize;) N
(20) # () N
(21) # (    -- Eliminiert den Operator "gdw" aus der eingegebenen Formel f.) N
(22) # (    procedure eliminate_gdw\(f\);) N
(23) # (        case) N
(24) # (            when f = "1"                   =>  return "1";) N
(25) # (            when f = "0"                   =>  return "0";) N
(26) # (            when #f = 1                    =>  return f;) N
(27) # (            when #f = 2 and f\(1\) = "-" =>  ) N
(28) # (                return [ "-", eliminate_gdw\( f\(2\) \) ];) N
(29) # (            when #f = 3 and f\(1\) = "*"   =>  ) N
(30) # (                return [ "*", eliminate_gdw\( f\(2\) \), eliminate_gdw\( f\(3\) \) ];) N
(31) # (            when #f = 3 and f\(1\) = "+"  =>  ) N
(32) # (                return [ "+", eliminate_gdw\( f\(2\) \), eliminate_gdw\( f\(3\) \) ];) N
(33) # (            when #f = 3 and f\(1\) = "->" =>  ) N
(34) # (                return [ "->", eliminate_gdw\( f\(2\) \), eliminate_gdw\( f\(3\) \) ];) N
(35) # (            when #f = 3 and f\(1\) = "<->"   =>  ) N
(36) # (                f2 := eliminate_gdw\( f\(2\) \);) N
(37) # (                f3 := eliminate_gdw\( f\(3\) \);) N
(38) # (                return [ "*", [ "->", f2, f3 ], [ "->", f3, f2 ] ];) N
(39) # (            otherwise  => print\("Fehler in eliminate_gdw\( ", f, "\)" \);) N
(40) # (        end case;) N
(41) # (    end eliminate_gdw;) N
(42) # () N
(43) # (    -- Eliminiert den Operator "->" aus der eingegebenen Formel f.) N
(44) # (    -- Es wird vorausgesetzt, dass der Operator "<->" bereits vorher ) N
(45) # (    -- eliminiert wurde.) N
(46) # (    procedure eliminate_folgt\(f\);) N
(47) # (        case) N
(48) # (            when f = "1"                   =>  return "1";) N
(49) # (            when f = "0"                   =>  return "0";) N
(50) # (            when #f = 1                    =>  return f;) N
(51) # (            when #f = 2 and f\(1\) = "-"     =>  ) N
(52) # (                return [ "-", eliminate_folgt\( f\(2\) \) ];) N
(53) # (            when #f = 3 and f\(1\) = "*"     =>  ) N
(54) # (                return [ "*", eliminate_folgt\(f\(2\)\), eliminate_folgt\(f\(3\)\) ];) N
(55) # (            when #f = 3 and f\(1\) = "+"     =>  ) N
(56) # (                return [ "+", eliminate_folgt\(f\(2\)\), eliminate_folgt\(f\(3\)\) ];) N
(57) # (            when #f = 3 and f\(1\) = "->"    =>  ) N
(58) # (                f2 := eliminate_folgt\( f\(2\) \);) N
(59) # (                f3 := eliminate_folgt\( f\(3\) \);) N
(60) # (                return [ "+", [ "-", f2 ], f3 ];) N
(61) # (            otherwise  => print\("Fehler in eliminate_folgt\( ", f, "\)" \);) N
(62) # (        end case;) N
(63) # (    end eliminate_folgt;) N
(64) # () N
(65) # (    -- Berechnet die Negations-Normalform der Formel f.) N
(66) # (    procedure nnf\(f\);) N
(67) # (        case) N
(68) # (            when f = "1"               =>  return "1";) N
(69) # (            when f = "0"               =>  return "0";) N
(70) # (            when #f = 1                =>  return f;) N
(71) # (            when #f = 2 and f\(1\) = "-" =>  return negiere\( f\(2\) \);) N
(72) # (            when #f = 3 and f\(1\) = "*" =>  return [ "*", nnf\( f\(2\) \), nnf\( f\(3\) ) N
0 T (\) ];) N
(knf.stl) (Page 1/5) (Feb 23, 04 16:43) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(73) # (            when #f = 3 and f\(1\) = "+" =>  return [ "+", nnf\( f\(2\) \), nnf\( f\(3\) ) p n
0 T (\) ];) N
(74) # (            otherwise  => print\("Fehler in nnf\( ", f, "\)" \);) N
(75) # (        end case;) N
(76) # (    end nnf;) N
(77) # () N
(78) # (    -- Diese Funktion berechnet die Negations--Normalform von \(nicht f\) und schi) N
0 T (ebt dabei) N
(79) # (    -- das Negationszeichen soweit wie m\366glich nach innen.) N
(80) # (    procedure negiere\(f\);) N
(81) # (        case) N
(82) # (            when f = "1"               => return "0";) N
(83) # (            when f = "0"               => return "1";) N
(84) # (            when #f = 1                => return [ "-", f ];) N
(85) # (            when #f = 2 and f\(1\) = "-" => return nnf\( f\(2\) \);) N
(86) # (            when #f = 3 and f\(1\) = "*" => ) N
(87) # (                return [ "+", negiere\( f\(2\) \), negiere\( f\(3\) \) ];) N
(88) # (            when #f = 3 and f\(1\) = "+" => ) N
(89) # (                return [ "*", negiere\( f\(2\) \), negiere\( f\(3\) \) ];) N
(90) # (            otherwise  => print\("Fehler in negiere\( ", f, "\)" \);) N
(91) # (        end case;) N
(92) # (    end negiere;) N
(93) # () N
(94) # (    -- Diese Funktion berechnet die KNF von f durch Ausmultiplizieren.) N
(95) # (    -- Die KNF wird als Menge von Mengen dargestellt.  Es wird vorausgesetzt,) N
(96) # (    -- dass die Funktion f bereits in Negations--Normalform ist.) N
(97) # (    procedure knf\(f\);) N
(98) # (        case) N
(99) # (            when f = "1"               =>  return { };) N
(100) # (            when f = "0"               =>  return { {} };) N
(101) # (            when #f = 1                =>  return { { f } };) N
(102) # (            when #f = 2 and f\(1\) = "-" =>  return { { f } };) N
(103) # (            when #f = 3 and f\(1\) = "*" =>  return knf\( f\(2\) \) + knf\( f\(3\) \);) N
(104) # (            when #f = 3 and f\(1\) = "+" =>  ) N
(105) # (                f2 := knf\( f\(2\) \);) N
(106) # (                f3 := knf\( f\(3\) \);) N
(107) # (                return oder_knf\( f2, f3 \);) N
(108) # (            otherwise  => print\("Fehler in knf\( ", f, "\)" \);) N
(109) # (        end case;) N
(110) # (    end knf;) N
(111) # () N
(112) # (    -- Diese Funktion berechnet die KNF von \(f1 oder f2\) durch Ausmultiplizieren) N
0 T (.) N
(113) # (    -- Es wird vorausgesetzt, dass f1 und f2 bereits in KNF sind.) N
(114) # (    procedure oder_knf\(f1, f2\);) N
(115) # (        -- Als KNF rep\344sentiert die leere Menge den Wert "true".) N
(116) # (        if f1 = {} then) N
(117) # (            return {};) N
(118) # (        end if;) N
(119) # (        k from f1;) N
(120) # (        k1 := oder_klausel\(k, f2\);) N
(121) # (        k2 := oder_knf\(f1, f2\);) N
(122) # (        return k1 + k2;) N
(123) # (    end oder_knf;) N
(124) # () N
(125) # (    -- Diese Funktion bekommt als Eingabe eine Klausel k und ein Formel f in KNF) N
0 T (.) N
(126) # (    -- Berechnet wird die Formel k oder f.  Die Berechnung wird so durchgef\374hrt,) N
(127) # (    -- dass das Ergebnis hinterher in KNF vorliegt. ) N
(128) # (    procedure oder_klausel\(k, f\);) N
(129) # (        -- Als KNF rep\344sentiert die leere Menge den Wert "true".) N
(130) # (        if f = {} then) N
(131) # (            return {};) N
(132) # (        end if;) N
(133) # (        k1 from f;) N
(134) # (        return { k1 + k } + oder_klausel\( k, f \);) N
(135) # (    end oder_klausel;) N
(136) # () N
(knf.stl) (Page 2/5) (Feb 23, 04 16:43) title
border
grestore
(Printed by Karl Stroetmann) rhead
(knf.stl) (3/5) (Monday February 23, 2004) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(137) # (    -- Druckt die Formel f am Bildschirm aus.) p n
(138) # (    procedure prettyPrint\(f\);) N
(139) # (        case) N
(140) # (            when f = "1"                  =>  return "1";) N
(141) # (            when f = "0"                  =>  return "0";) N
(142) # (            when #f = 1                   =>  return f\(1\);) N
(143) # (            when #f = 2 and f\(1\) = "-"    =>  return "-" + prettyPrint\( f\(2\) \);) N
(144) # (            when #f = 3 and f\(1\) = "*"    =>  ) N
(145) # (                return "\(" + prettyPrint\( f\(2\) \) + " * "   + prettyPrint\( f\(3\) \)) N
0 T ( + "\)";) N
(146) # (            when #f = 3 and f\(1\) = "+"    =>  ) N
(147) # (                return "\(" + prettyPrint\( f\(2\) \) + " + "   + prettyPrint\( f\(3\) \)) N
0 T ( + "\)";) N
(148) # (            when #f = 3 and f\(1\) = "->"   =>  ) N
(149) # (                return "\(" + prettyPrint\( f\(2\) \) + " -> "  + prettyPrint\( f\(3\) \)) N
0 T ( + "\)";) N
(150) # (            when #f = 3 and f\(1\) = "<->"  =>  ) N
(151) # (                return "\(" + prettyPrint\( f\(2\) \) + " <-> " + prettyPrint\( f\(3\) \)) N
0 T ( + "\)";) N
(152) # (            otherwise => abort\("Error in prettyPrint: " + str\(f\)\);) N
(153) # (        end case;) N
(154) # (    end prettyPrint;) N
(155) # () N
(156) # (    -- Liest einen String und scannt den String.  Es wird eine Liste von Token) N
(157) # (    -- zur\374ck gegeben.) N
(158) # (    procedure scanFormula\(s\);) N
(159) # (        letters := {};) N
(160) # (        -- collect all letters and digits) N
(161) # (        for x in { 48 .. 57 } + { 65 .. 90 } + { 97 .. 122 } loop) N
(162) # (            letters := letters + { char\(x\) };) N
(163) # (        end loop;) N
(164) # (        case ) N
(165) # (            when s = ""                      => return [];) N
(166) # (            when s\(1\) = "\("                  => return [ "\(" ] + scanFormula\( s\() N
0 T (2..\) \);) N
(167) # (            when s\(1\) = "\)"                  => return [ "\)" ] + scanFormula\( s\() N
0 T (2..\) \);) N
(168) # (            when s\(1\) = "+"                  => return [ "+" ] + scanFormula\( s\() N
0 T (2..\) \);) N
(169) # (            when s\(1\) = "*"                  => return [ "*" ] + scanFormula\( s\() N
0 T (2..\) \);) N
(170) # (            when #s >= 2 and s\(1..2\) = "->"  => return [ "->" ] + scanFormula\( s) N
0 T (\(3..\) \);) N
(171) # (            when #s >= 3 and s\(1..3\) = "<->" => return [ "<->" ] + scanFormula\( ) N
0 T (s\(4..\) \);) N
(172) # (            when s\(1\) = "-"                  => return [ "-" ] + scanFormula\( s\() N
0 T (2..\) \);) N
(173) # (            when s\(1\) = " " or s\(1\) = "    " => return scanFormula\( s\(2..\) \);) N
(174) # (        end case;) N
(175) # (        index := 1;) N
(176) # (        word  := "";) N
(177) # (        if s\(index\) notin letters then) N
(178) # (            abort\("Error in scanFormula\(" + s + "\)"\);) N
(179) # (        end if;) N
(180) # (        while s\(index\) in letters and index < #s loop) N
(181) # (            index := index + 1;) N
(182) # (        end loop;) N
(183) # (        if not s\(index\) in letters then) N
(184) # (            return [ s\(1 .. index - 1\) ] + scanFormula\( s\(index ..\) \);) N
(185) # (        end if;) N
(186) # (        if index = #s then) N
(187) # (            return [ s ];) N
(188) # (        end if;) N
(189) # (        print\( "Error in scanFormula: s = ", s \);) N
(190) # (    end scanFormula;) N
(191) # () N
(192) # (    -- Interpretiert eine Liste L von Tokens als Formel und gibt die gefundene ) N
(193) # (    -- Formel zur\374ck.  Es wird ein Backtracking-Algorithmus verwendet.) N
(194) # (    procedure parse_formula\(L\);) N
(195) # (        f := parse_parentheses\(L\);) N
(196) # (        if f /= om then) N
(197) # (            return f;) N
(198) # (        end if;) N
(knf.stl) (Page 3/5) (Feb 23, 04 16:43) title
border
/v 1 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(199) # (        -- Nun wird nach einem bin\344ren Operator gesucht.  Die Reihenfolge, in de) p n
0 T (r) N
(200) # (        -- gesucht wird, richtet sich nach der Bindungsst\344rke der Operatoren ) N
(201) # (        f := parse_equivalence\(L\);) N
(202) # (        if f /= om then) N
(203) # (            return f;) N
(204) # (        end if;) N
(205) # (        f := parse_implication\(L\);) N
(206) # (        if f /= om then) N
(207) # (            return f;) N
(208) # (        end if;) N
(209) # (        f := parse_conjunction\(L\);) N
(210) # (        if f /= om then) N
(211) # (            return f;) N
(212) # (        end if;) N
(213) # (        f := parse_disjunction\(L\);) N
(214) # (        if f /= om then) N
(215) # (            return f;) N
(216) # (        end if;) N
(217) # (        f := parse_negation\(L\);) N
(218) # (        if f /= om then) N
(219) # (            return f;) N
(220) # (        end if;) N
(221) # (        f := parse_atom\(L\);) N
(222) # (        if f /= om then) N
(223) # (            return f;) N
(224) # (        end if;) N
(225) # (    end parse_formula;) N
(226) # () N
(227) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine geklammerte Formel) N
(228) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(229) # (    -- undefiniert, also Omega.) N
(230) # (    procedure parse_parentheses\(L\);) N
(231) # (        if L\(1\) = "\(" and L\(#L\) = "\)" then) N
(232) # (            return parse_formula\( l\(2 .. #L - 1\) \);) N
(233) # (        end if;) N
(234) # (    end parse_parentheses;) N
(235) # () N
(236) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine Formel der Art) N
(237) # (    --       f1 <-> f2) N
(238) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(239) # (    -- undefiniert, also Omega.) N
(240) # (    procedure parse_equivalence\(L\);) N
(241) # (        for i in [ 2 .. #L - 1 ] loop) N
(242) # (            if L\(i\) = "<->" then) N
(243) # (                f1 := parse_formula\( L\(1 .. i - 1\) \);) N
(244) # (                if f1 /= om then) N
(245) # (                    f2 := parse_formula\( L\(i + 1 .. #L\) \);) N
(246) # (                    if f2 /= om then) N
(247) # (                        return [ "<->", f1, f2 ];) N
(248) # (                    end if;) N
(249) # (                end if;) N
(250) # (            end if;) N
(251) # (        end loop;) N
(252) # (    end parse_equivalence;) N
(253) # () N
(254) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine Formel der Art) N
(255) # (    --       f1 -> f2) N
(256) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(257) # (    -- undefiniert, also Omega.) N
(258) # (    procedure parse_implication\(L\);) N
(259) # (        for i in [ 2 .. #L - 1 ] loop) N
(260) # (            if L\(i\) = "->" then) N
(261) # (                f1 := parse_formula\( L\(1 .. i - 1\) \);) N
(262) # (                if f1 /= om then) N
(263) # (                    f2 := parse_formula\( L\(i + 1 .. #L\) \);) N
(264) # (                    if f2 /= om then) N
(265) # (                        return [ "->", f1, f2 ];) N
(266) # (                    end if;) N
(267) # (                end if;) N
(268) # (            end if;) N
(269) # (        end loop;) N
(270) # (    end parse_implication;) N
(knf.stl) (Page 4/5) (Feb 23, 04 16:43) title
border
grestore
(Printed by Karl Stroetmann) rhead
(knf.stl) (4/5) (Monday February 23, 2004) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 2.965278 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(271) # () p n
(272) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine Formel der Art) N
(273) # (    --       f1 * f2) N
(274) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(275) # (    -- undefiniert, also Omega.) N
(276) # (    procedure parse_conjunction\(L\);) N
(277) # (        for i in [ 2 .. #L - 1 ] loop) N
(278) # (            if L\(i\) = "*" then) N
(279) # (                f1 := parse_formula\( L\(1 .. i - 1\) \);) N
(280) # (                if f1 /= om then) N
(281) # (                    f2 := parse_formula\( L\(i + 1 .. #L\) \);) N
(282) # (                    if f2 /= om then) N
(283) # (                        return [ "*", f1, f2 ];) N
(284) # (                    end if;) N
(285) # (                end if;) N
(286) # (            end if;) N
(287) # (        end loop;) N
(288) # (    end parse_conjunction;) N
(289) # () N
(290) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine Formel der Art) N
(291) # (    --       f1 + f2) N
(292) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(293) # (    -- undefiniert, also Omega.) N
(294) # (    procedure parse_disjunction\(L\);) N
(295) # (        for i in [ 2 .. #L - 1 ] loop) N
(296) # (            if L\(i\) = "+" then) N
(297) # (                f1 := parse_formula\( L\(1 .. i - 1\) \);) N
(298) # (                if f1 /= om then) N
(299) # (                    f2 := parse_formula\( L\(i + 1 .. #L\) \);) N
(300) # (                    if f2 /= om then) N
(301) # (                        return [ "+", f1, f2 ];) N
(302) # (                    end if;) N
(303) # (                end if;) N
(304) # (            end if;) N
(305) # (        end loop;) N
(306) # (    end parse_disjunction;) N
(307) # () N
(308) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine Formel der Art) N
(309) # (    --       - f1) N
(310) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(311) # (    -- undefiniert, also Omega.) N
(312) # (    procedure parse_negation\(L\);) N
(313) # (        if L\(1\) = "-" then) N
(314) # (            f := parse_formula\( L\(2 .. #L\) \);) N
(315) # (            if f /= om then) N
(316) # (                return [ "-", f ];) N
(317) # (            end if;) N
(318) # (        end if;) N
(319) # (    end parse_negation;) N
(320) # () N
(321) # (    -- L ist eine Liste von Tokens.  Wenn diese Liste eine atomare Formel ) N
(322) # (    --       p) N
(323) # (    -- darstellt, dann wird diese Formel zur\374ck gegeben, sonst ist das Ergebnis) N
(324) # (    -- undefiniert, also Omega.) N
(325) # (    procedure parse_atom\(L\);) N
(326) # (        if #L = 1  and L\(1\) in { "0", "false" } then) N
(327) # (            return "0";) N
(328) # (        end if;) N
(329) # (        if #L = 1  and L\(1\) in { "1", "true" } then) N
(330) # (            return "1";) N
(331) # (        end if;) N
(332) # (        if #L = 1 then) N
(333) # (            return L;) N
(334) # (        end if;) N
(335) # (    end parse_atom;) N
(336) # () N
(337) # (end main;) N
(knf.stl) (Page 5/5) (Feb 23, 04 16:43) title
border
grestore
(Printed by Karl Stroetmann) rhead
(knf.stl) (5/5) (Monday February 23, 2004) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
